// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/canbus/proto/zhongyun.proto

#ifndef PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fzhongyun_2eproto
#define PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fzhongyun_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto 

namespace protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto
namespace apollo {
namespace canbus {
class Brake_control_a4;
class Brake_control_a4DefaultTypeInternal;
extern Brake_control_a4DefaultTypeInternal _Brake_control_a4_default_instance_;
class Enable_state_feedback_c3;
class Enable_state_feedback_c3DefaultTypeInternal;
extern Enable_state_feedback_c3DefaultTypeInternal _Enable_state_feedback_c3_default_instance_;
class Error_state_e1;
class Error_state_e1DefaultTypeInternal;
extern Error_state_e1DefaultTypeInternal _Error_state_e1_default_instance_;
class Gear_control_a1;
class Gear_control_a1DefaultTypeInternal;
extern Gear_control_a1DefaultTypeInternal _Gear_control_a1_default_instance_;
class Parking_control_a5;
class Parking_control_a5DefaultTypeInternal;
extern Parking_control_a5DefaultTypeInternal _Parking_control_a5_default_instance_;
class Steering_control_a2;
class Steering_control_a2DefaultTypeInternal;
extern Steering_control_a2DefaultTypeInternal _Steering_control_a2_default_instance_;
class Torque_control_a3;
class Torque_control_a3DefaultTypeInternal;
extern Torque_control_a3DefaultTypeInternal _Torque_control_a3_default_instance_;
class Vehicle_state_feedback_2_c4;
class Vehicle_state_feedback_2_c4DefaultTypeInternal;
extern Vehicle_state_feedback_2_c4DefaultTypeInternal _Vehicle_state_feedback_2_c4_default_instance_;
class Vehicle_state_feedback_c1;
class Vehicle_state_feedback_c1DefaultTypeInternal;
extern Vehicle_state_feedback_c1DefaultTypeInternal _Vehicle_state_feedback_c1_default_instance_;
class Zhongyun;
class ZhongyunDefaultTypeInternal;
extern ZhongyunDefaultTypeInternal _Zhongyun_default_instance_;
}  // namespace canbus
}  // namespace apollo
namespace google {
namespace protobuf {
template<> ::apollo::canbus::Brake_control_a4* Arena::CreateMaybeMessage<::apollo::canbus::Brake_control_a4>(Arena*);
template<> ::apollo::canbus::Enable_state_feedback_c3* Arena::CreateMaybeMessage<::apollo::canbus::Enable_state_feedback_c3>(Arena*);
template<> ::apollo::canbus::Error_state_e1* Arena::CreateMaybeMessage<::apollo::canbus::Error_state_e1>(Arena*);
template<> ::apollo::canbus::Gear_control_a1* Arena::CreateMaybeMessage<::apollo::canbus::Gear_control_a1>(Arena*);
template<> ::apollo::canbus::Parking_control_a5* Arena::CreateMaybeMessage<::apollo::canbus::Parking_control_a5>(Arena*);
template<> ::apollo::canbus::Steering_control_a2* Arena::CreateMaybeMessage<::apollo::canbus::Steering_control_a2>(Arena*);
template<> ::apollo::canbus::Torque_control_a3* Arena::CreateMaybeMessage<::apollo::canbus::Torque_control_a3>(Arena*);
template<> ::apollo::canbus::Vehicle_state_feedback_2_c4* Arena::CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_2_c4>(Arena*);
template<> ::apollo::canbus::Vehicle_state_feedback_c1* Arena::CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_c1>(Arena*);
template<> ::apollo::canbus::Zhongyun* Arena::CreateMaybeMessage<::apollo::canbus::Zhongyun>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace apollo {
namespace canbus {

enum Gear_control_a1_Gear_state_targetType {
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_P = 1,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_N = 2,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_D = 3,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_R = 4,
  Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_INVALID = 5
};
bool Gear_control_a1_Gear_state_targetType_IsValid(int value);
const Gear_control_a1_Gear_state_targetType Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MIN = Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_P;
const Gear_control_a1_Gear_state_targetType Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MAX = Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_INVALID;
const int Gear_control_a1_Gear_state_targetType_Gear_state_targetType_ARRAYSIZE = Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gear_control_a1_Gear_state_targetType_descriptor();
inline const ::std::string& Gear_control_a1_Gear_state_targetType_Name(Gear_control_a1_Gear_state_targetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gear_control_a1_Gear_state_targetType_descriptor(), value);
}
inline bool Gear_control_a1_Gear_state_targetType_Parse(
    const ::std::string& name, Gear_control_a1_Gear_state_targetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gear_control_a1_Gear_state_targetType>(
    Gear_control_a1_Gear_state_targetType_descriptor(), name, value);
}
enum Gear_control_a1_Gear_enable_controlType {
  Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL = 0,
  Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL = 1
};
bool Gear_control_a1_Gear_enable_controlType_IsValid(int value);
const Gear_control_a1_Gear_enable_controlType Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MIN = Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL;
const Gear_control_a1_Gear_enable_controlType Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MAX = Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL;
const int Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_ARRAYSIZE = Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Gear_control_a1_Gear_enable_controlType_descriptor();
inline const ::std::string& Gear_control_a1_Gear_enable_controlType_Name(Gear_control_a1_Gear_enable_controlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Gear_control_a1_Gear_enable_controlType_descriptor(), value);
}
inline bool Gear_control_a1_Gear_enable_controlType_Parse(
    const ::std::string& name, Gear_control_a1_Gear_enable_controlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gear_control_a1_Gear_enable_controlType>(
    Gear_control_a1_Gear_enable_controlType_descriptor(), name, value);
}
enum Torque_control_a3_Driven_enable_controlType {
  Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL = 0,
  Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_AUTO = 1
};
bool Torque_control_a3_Driven_enable_controlType_IsValid(int value);
const Torque_control_a3_Driven_enable_controlType Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MIN = Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL;
const Torque_control_a3_Driven_enable_controlType Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MAX = Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_AUTO;
const int Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_ARRAYSIZE = Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Torque_control_a3_Driven_enable_controlType_descriptor();
inline const ::std::string& Torque_control_a3_Driven_enable_controlType_Name(Torque_control_a3_Driven_enable_controlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Torque_control_a3_Driven_enable_controlType_descriptor(), value);
}
inline bool Torque_control_a3_Driven_enable_controlType_Parse(
    const ::std::string& name, Torque_control_a3_Driven_enable_controlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Torque_control_a3_Driven_enable_controlType>(
    Torque_control_a3_Driven_enable_controlType_descriptor(), name, value);
}
enum Steering_control_a2_Steering_enable_controlType {
  Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL = 0,
  Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL = 1
};
bool Steering_control_a2_Steering_enable_controlType_IsValid(int value);
const Steering_control_a2_Steering_enable_controlType Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MIN = Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL;
const Steering_control_a2_Steering_enable_controlType Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MAX = Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL;
const int Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_ARRAYSIZE = Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Steering_control_a2_Steering_enable_controlType_descriptor();
inline const ::std::string& Steering_control_a2_Steering_enable_controlType_Name(Steering_control_a2_Steering_enable_controlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Steering_control_a2_Steering_enable_controlType_descriptor(), value);
}
inline bool Steering_control_a2_Steering_enable_controlType_Parse(
    const ::std::string& name, Steering_control_a2_Steering_enable_controlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Steering_control_a2_Steering_enable_controlType>(
    Steering_control_a2_Steering_enable_controlType_descriptor(), name, value);
}
enum Parking_control_a5_Parking_targetType {
  Parking_control_a5_Parking_targetType_PARKING_TARGET_RELEASE = 0,
  Parking_control_a5_Parking_targetType_PARKING_TARGET_PARKING_TRIGGER = 1
};
bool Parking_control_a5_Parking_targetType_IsValid(int value);
const Parking_control_a5_Parking_targetType Parking_control_a5_Parking_targetType_Parking_targetType_MIN = Parking_control_a5_Parking_targetType_PARKING_TARGET_RELEASE;
const Parking_control_a5_Parking_targetType Parking_control_a5_Parking_targetType_Parking_targetType_MAX = Parking_control_a5_Parking_targetType_PARKING_TARGET_PARKING_TRIGGER;
const int Parking_control_a5_Parking_targetType_Parking_targetType_ARRAYSIZE = Parking_control_a5_Parking_targetType_Parking_targetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Parking_control_a5_Parking_targetType_descriptor();
inline const ::std::string& Parking_control_a5_Parking_targetType_Name(Parking_control_a5_Parking_targetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Parking_control_a5_Parking_targetType_descriptor(), value);
}
inline bool Parking_control_a5_Parking_targetType_Parse(
    const ::std::string& name, Parking_control_a5_Parking_targetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Parking_control_a5_Parking_targetType>(
    Parking_control_a5_Parking_targetType_descriptor(), name, value);
}
enum Parking_control_a5_Parking_enable_controlType {
  Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL = 0,
  Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL = 1
};
bool Parking_control_a5_Parking_enable_controlType_IsValid(int value);
const Parking_control_a5_Parking_enable_controlType Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MIN = Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL;
const Parking_control_a5_Parking_enable_controlType Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MAX = Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL;
const int Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_ARRAYSIZE = Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Parking_control_a5_Parking_enable_controlType_descriptor();
inline const ::std::string& Parking_control_a5_Parking_enable_controlType_Name(Parking_control_a5_Parking_enable_controlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Parking_control_a5_Parking_enable_controlType_descriptor(), value);
}
inline bool Parking_control_a5_Parking_enable_controlType_Parse(
    const ::std::string& name, Parking_control_a5_Parking_enable_controlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Parking_control_a5_Parking_enable_controlType>(
    Parking_control_a5_Parking_enable_controlType_descriptor(), name, value);
}
enum Brake_control_a4_Brake_enable_controlType {
  Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_MANUAL = 0,
  Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_AUTO = 1
};
bool Brake_control_a4_Brake_enable_controlType_IsValid(int value);
const Brake_control_a4_Brake_enable_controlType Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MIN = Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_MANUAL;
const Brake_control_a4_Brake_enable_controlType Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MAX = Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_AUTO;
const int Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_ARRAYSIZE = Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Brake_control_a4_Brake_enable_controlType_descriptor();
inline const ::std::string& Brake_control_a4_Brake_enable_controlType_Name(Brake_control_a4_Brake_enable_controlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Brake_control_a4_Brake_enable_controlType_descriptor(), value);
}
inline bool Brake_control_a4_Brake_enable_controlType_Parse(
    const ::std::string& name, Brake_control_a4_Brake_enable_controlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Brake_control_a4_Brake_enable_controlType>(
    Brake_control_a4_Brake_enable_controlType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Parking_enable_stateType {
  Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_MANUALCONTROL = 0,
  Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_AUTOCONTROL = 1,
  Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Parking_enable_stateType_IsValid(int value);
const Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MIN = Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_MANUALCONTROL;
const Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MAX = Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_TAKEOVER;
const int Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Enable_state_feedback_c3_Parking_enable_stateType_descriptor();
inline const ::std::string& Enable_state_feedback_c3_Parking_enable_stateType_Name(Enable_state_feedback_c3_Parking_enable_stateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Enable_state_feedback_c3_Parking_enable_stateType_descriptor(), value);
}
inline bool Enable_state_feedback_c3_Parking_enable_stateType_Parse(
    const ::std::string& name, Enable_state_feedback_c3_Parking_enable_stateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Enable_state_feedback_c3_Parking_enable_stateType>(
    Enable_state_feedback_c3_Parking_enable_stateType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Steering_enable_stateType {
  Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUALCONTROL = 0,
  Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_AUTOCONTROL = 1,
  Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Steering_enable_stateType_IsValid(int value);
const Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MIN = Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUALCONTROL;
const Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MAX = Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER;
const int Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Enable_state_feedback_c3_Steering_enable_stateType_descriptor();
inline const ::std::string& Enable_state_feedback_c3_Steering_enable_stateType_Name(Enable_state_feedback_c3_Steering_enable_stateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Enable_state_feedback_c3_Steering_enable_stateType_descriptor(), value);
}
inline bool Enable_state_feedback_c3_Steering_enable_stateType_Parse(
    const ::std::string& name, Enable_state_feedback_c3_Steering_enable_stateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Enable_state_feedback_c3_Steering_enable_stateType>(
    Enable_state_feedback_c3_Steering_enable_stateType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Gear_enable_actualType {
  Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL = 0,
  Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_AUTOCONTROL = 1,
  Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Gear_enable_actualType_IsValid(int value);
const Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MIN = Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL;
const Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MAX = Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER;
const int Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_ARRAYSIZE = Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Enable_state_feedback_c3_Gear_enable_actualType_descriptor();
inline const ::std::string& Enable_state_feedback_c3_Gear_enable_actualType_Name(Enable_state_feedback_c3_Gear_enable_actualType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Enable_state_feedback_c3_Gear_enable_actualType_descriptor(), value);
}
inline bool Enable_state_feedback_c3_Gear_enable_actualType_Parse(
    const ::std::string& name, Enable_state_feedback_c3_Gear_enable_actualType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Enable_state_feedback_c3_Gear_enable_actualType>(
    Enable_state_feedback_c3_Gear_enable_actualType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Driven_enable_stateType {
  Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_MANUAL = 0,
  Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_AUTO = 1,
  Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Driven_enable_stateType_IsValid(int value);
const Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MIN = Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_MANUAL;
const Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MAX = Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER;
const int Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Enable_state_feedback_c3_Driven_enable_stateType_descriptor();
inline const ::std::string& Enable_state_feedback_c3_Driven_enable_stateType_Name(Enable_state_feedback_c3_Driven_enable_stateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Enable_state_feedback_c3_Driven_enable_stateType_descriptor(), value);
}
inline bool Enable_state_feedback_c3_Driven_enable_stateType_Parse(
    const ::std::string& name, Enable_state_feedback_c3_Driven_enable_stateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Enable_state_feedback_c3_Driven_enable_stateType>(
    Enable_state_feedback_c3_Driven_enable_stateType_descriptor(), name, value);
}
enum Enable_state_feedback_c3_Brake_enable_stateType {
  Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_MANUAL = 0,
  Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_AUTO = 1,
  Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_TAKEOVER = 2
};
bool Enable_state_feedback_c3_Brake_enable_stateType_IsValid(int value);
const Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MIN = Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_MANUAL;
const Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MAX = Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_TAKEOVER;
const int Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_ARRAYSIZE = Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Enable_state_feedback_c3_Brake_enable_stateType_descriptor();
inline const ::std::string& Enable_state_feedback_c3_Brake_enable_stateType_Name(Enable_state_feedback_c3_Brake_enable_stateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Enable_state_feedback_c3_Brake_enable_stateType_descriptor(), value);
}
inline bool Enable_state_feedback_c3_Brake_enable_stateType_Parse(
    const ::std::string& name, Enable_state_feedback_c3_Brake_enable_stateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Enable_state_feedback_c3_Brake_enable_stateType>(
    Enable_state_feedback_c3_Brake_enable_stateType_descriptor(), name, value);
}
enum Vehicle_state_feedback_c1_Parking_actualType {
  Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_RELEASE = 0,
  Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_PARKING_TRIGGER = 1
};
bool Vehicle_state_feedback_c1_Parking_actualType_IsValid(int value);
const Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MIN = Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_RELEASE;
const Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MAX = Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_PARKING_TRIGGER;
const int Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_ARRAYSIZE = Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Vehicle_state_feedback_c1_Parking_actualType_descriptor();
inline const ::std::string& Vehicle_state_feedback_c1_Parking_actualType_Name(Vehicle_state_feedback_c1_Parking_actualType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Vehicle_state_feedback_c1_Parking_actualType_descriptor(), value);
}
inline bool Vehicle_state_feedback_c1_Parking_actualType_Parse(
    const ::std::string& name, Vehicle_state_feedback_c1_Parking_actualType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Vehicle_state_feedback_c1_Parking_actualType>(
    Vehicle_state_feedback_c1_Parking_actualType_descriptor(), name, value);
}
enum Vehicle_state_feedback_c1_Gear_state_actualType {
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_P = 1,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_N = 2,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_D = 3,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_R = 4,
  Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_INVALID = 5
};
bool Vehicle_state_feedback_c1_Gear_state_actualType_IsValid(int value);
const Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MIN = Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_P;
const Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MAX = Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_INVALID;
const int Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_ARRAYSIZE = Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Vehicle_state_feedback_c1_Gear_state_actualType_descriptor();
inline const ::std::string& Vehicle_state_feedback_c1_Gear_state_actualType_Name(Vehicle_state_feedback_c1_Gear_state_actualType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Vehicle_state_feedback_c1_Gear_state_actualType_descriptor(), value);
}
inline bool Vehicle_state_feedback_c1_Gear_state_actualType_Parse(
    const ::std::string& name, Vehicle_state_feedback_c1_Gear_state_actualType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Vehicle_state_feedback_c1_Gear_state_actualType>(
    Vehicle_state_feedback_c1_Gear_state_actualType_descriptor(), name, value);
}
enum Error_state_e1_Brake_error_codeType {
  Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Brake_error_codeType_IsValid(int value);
const Error_state_e1_Brake_error_codeType Error_state_e1_Brake_error_codeType_Brake_error_codeType_MIN = Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_NO_ERROR;
const Error_state_e1_Brake_error_codeType Error_state_e1_Brake_error_codeType_Brake_error_codeType_MAX = Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_ERROR;
const int Error_state_e1_Brake_error_codeType_Brake_error_codeType_ARRAYSIZE = Error_state_e1_Brake_error_codeType_Brake_error_codeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_state_e1_Brake_error_codeType_descriptor();
inline const ::std::string& Error_state_e1_Brake_error_codeType_Name(Error_state_e1_Brake_error_codeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_state_e1_Brake_error_codeType_descriptor(), value);
}
inline bool Error_state_e1_Brake_error_codeType_Parse(
    const ::std::string& name, Error_state_e1_Brake_error_codeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_state_e1_Brake_error_codeType>(
    Error_state_e1_Brake_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Driven_error_codeType {
  Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Driven_error_codeType_IsValid(int value);
const Error_state_e1_Driven_error_codeType Error_state_e1_Driven_error_codeType_Driven_error_codeType_MIN = Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_NO_ERROR;
const Error_state_e1_Driven_error_codeType Error_state_e1_Driven_error_codeType_Driven_error_codeType_MAX = Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_ERROR;
const int Error_state_e1_Driven_error_codeType_Driven_error_codeType_ARRAYSIZE = Error_state_e1_Driven_error_codeType_Driven_error_codeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_state_e1_Driven_error_codeType_descriptor();
inline const ::std::string& Error_state_e1_Driven_error_codeType_Name(Error_state_e1_Driven_error_codeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_state_e1_Driven_error_codeType_descriptor(), value);
}
inline bool Error_state_e1_Driven_error_codeType_Parse(
    const ::std::string& name, Error_state_e1_Driven_error_codeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_state_e1_Driven_error_codeType>(
    Error_state_e1_Driven_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Steering_error_codeType {
  Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Steering_error_codeType_IsValid(int value);
const Error_state_e1_Steering_error_codeType Error_state_e1_Steering_error_codeType_Steering_error_codeType_MIN = Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_NO_ERROR;
const Error_state_e1_Steering_error_codeType Error_state_e1_Steering_error_codeType_Steering_error_codeType_MAX = Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_ERROR;
const int Error_state_e1_Steering_error_codeType_Steering_error_codeType_ARRAYSIZE = Error_state_e1_Steering_error_codeType_Steering_error_codeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_state_e1_Steering_error_codeType_descriptor();
inline const ::std::string& Error_state_e1_Steering_error_codeType_Name(Error_state_e1_Steering_error_codeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_state_e1_Steering_error_codeType_descriptor(), value);
}
inline bool Error_state_e1_Steering_error_codeType_Parse(
    const ::std::string& name, Error_state_e1_Steering_error_codeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_state_e1_Steering_error_codeType>(
    Error_state_e1_Steering_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Parking_error_codeType {
  Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_NO_ERROR = 0,
  Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_ERROR = 1
};
bool Error_state_e1_Parking_error_codeType_IsValid(int value);
const Error_state_e1_Parking_error_codeType Error_state_e1_Parking_error_codeType_Parking_error_codeType_MIN = Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_NO_ERROR;
const Error_state_e1_Parking_error_codeType Error_state_e1_Parking_error_codeType_Parking_error_codeType_MAX = Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_ERROR;
const int Error_state_e1_Parking_error_codeType_Parking_error_codeType_ARRAYSIZE = Error_state_e1_Parking_error_codeType_Parking_error_codeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_state_e1_Parking_error_codeType_descriptor();
inline const ::std::string& Error_state_e1_Parking_error_codeType_Name(Error_state_e1_Parking_error_codeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_state_e1_Parking_error_codeType_descriptor(), value);
}
inline bool Error_state_e1_Parking_error_codeType_Parse(
    const ::std::string& name, Error_state_e1_Parking_error_codeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_state_e1_Parking_error_codeType>(
    Error_state_e1_Parking_error_codeType_descriptor(), name, value);
}
enum Error_state_e1_Gear_error_msgType {
  Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_NO_ERROR = 0,
  Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_ERROR = 1
};
bool Error_state_e1_Gear_error_msgType_IsValid(int value);
const Error_state_e1_Gear_error_msgType Error_state_e1_Gear_error_msgType_Gear_error_msgType_MIN = Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_NO_ERROR;
const Error_state_e1_Gear_error_msgType Error_state_e1_Gear_error_msgType_Gear_error_msgType_MAX = Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_ERROR;
const int Error_state_e1_Gear_error_msgType_Gear_error_msgType_ARRAYSIZE = Error_state_e1_Gear_error_msgType_Gear_error_msgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_state_e1_Gear_error_msgType_descriptor();
inline const ::std::string& Error_state_e1_Gear_error_msgType_Name(Error_state_e1_Gear_error_msgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_state_e1_Gear_error_msgType_descriptor(), value);
}
inline bool Error_state_e1_Gear_error_msgType_Parse(
    const ::std::string& name, Error_state_e1_Gear_error_msgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_state_e1_Gear_error_msgType>(
    Error_state_e1_Gear_error_msgType_descriptor(), name, value);
}
// ===================================================================

class Gear_control_a1 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Gear_control_a1) */ {
 public:
  Gear_control_a1();
  virtual ~Gear_control_a1();

  Gear_control_a1(const Gear_control_a1& from);

  inline Gear_control_a1& operator=(const Gear_control_a1& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Gear_control_a1(Gear_control_a1&& from) noexcept
    : Gear_control_a1() {
    *this = ::std::move(from);
  }

  inline Gear_control_a1& operator=(Gear_control_a1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gear_control_a1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gear_control_a1* internal_default_instance() {
    return reinterpret_cast<const Gear_control_a1*>(
               &_Gear_control_a1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Gear_control_a1* other);
  friend void swap(Gear_control_a1& a, Gear_control_a1& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Gear_control_a1* New() const final {
    return CreateMaybeMessage<Gear_control_a1>(NULL);
  }

  Gear_control_a1* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Gear_control_a1>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Gear_control_a1& from);
  void MergeFrom(const Gear_control_a1& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gear_control_a1* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Gear_control_a1_Gear_state_targetType Gear_state_targetType;
  static const Gear_state_targetType GEAR_STATE_TARGET_P =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_P;
  static const Gear_state_targetType GEAR_STATE_TARGET_N =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_N;
  static const Gear_state_targetType GEAR_STATE_TARGET_D =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_D;
  static const Gear_state_targetType GEAR_STATE_TARGET_R =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_R;
  static const Gear_state_targetType GEAR_STATE_TARGET_INVALID =
    Gear_control_a1_Gear_state_targetType_GEAR_STATE_TARGET_INVALID;
  static inline bool Gear_state_targetType_IsValid(int value) {
    return Gear_control_a1_Gear_state_targetType_IsValid(value);
  }
  static const Gear_state_targetType Gear_state_targetType_MIN =
    Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MIN;
  static const Gear_state_targetType Gear_state_targetType_MAX =
    Gear_control_a1_Gear_state_targetType_Gear_state_targetType_MAX;
  static const int Gear_state_targetType_ARRAYSIZE =
    Gear_control_a1_Gear_state_targetType_Gear_state_targetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gear_state_targetType_descriptor() {
    return Gear_control_a1_Gear_state_targetType_descriptor();
  }
  static inline const ::std::string& Gear_state_targetType_Name(Gear_state_targetType value) {
    return Gear_control_a1_Gear_state_targetType_Name(value);
  }
  static inline bool Gear_state_targetType_Parse(const ::std::string& name,
      Gear_state_targetType* value) {
    return Gear_control_a1_Gear_state_targetType_Parse(name, value);
  }

  typedef Gear_control_a1_Gear_enable_controlType Gear_enable_controlType;
  static const Gear_enable_controlType GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL =
    Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_MANUALCONTROL;
  static const Gear_enable_controlType GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL =
    Gear_control_a1_Gear_enable_controlType_GEAR_ENABLE_CONTROL_GEAR_AUTOCONTROL;
  static inline bool Gear_enable_controlType_IsValid(int value) {
    return Gear_control_a1_Gear_enable_controlType_IsValid(value);
  }
  static const Gear_enable_controlType Gear_enable_controlType_MIN =
    Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MIN;
  static const Gear_enable_controlType Gear_enable_controlType_MAX =
    Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_MAX;
  static const int Gear_enable_controlType_ARRAYSIZE =
    Gear_control_a1_Gear_enable_controlType_Gear_enable_controlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gear_enable_controlType_descriptor() {
    return Gear_control_a1_Gear_enable_controlType_descriptor();
  }
  static inline const ::std::string& Gear_enable_controlType_Name(Gear_enable_controlType value) {
    return Gear_control_a1_Gear_enable_controlType_Name(value);
  }
  static inline bool Gear_enable_controlType_Parse(const ::std::string& name,
      Gear_enable_controlType* value) {
    return Gear_control_a1_Gear_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Gear_control_a1.Gear_enable_controlType gear_enable_control = 2;
  bool has_gear_enable_control() const;
  void clear_gear_enable_control();
  static const int kGearEnableControlFieldNumber = 2;
  ::apollo::canbus::Gear_control_a1_Gear_enable_controlType gear_enable_control() const;
  void set_gear_enable_control(::apollo::canbus::Gear_control_a1_Gear_enable_controlType value);

  // optional .apollo.canbus.Gear_control_a1.Gear_state_targetType gear_state_target = 1;
  bool has_gear_state_target() const;
  void clear_gear_state_target();
  static const int kGearStateTargetFieldNumber = 1;
  ::apollo::canbus::Gear_control_a1_Gear_state_targetType gear_state_target() const;
  void set_gear_state_target(::apollo::canbus::Gear_control_a1_Gear_state_targetType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Gear_control_a1)
 private:
  void set_has_gear_state_target();
  void clear_has_gear_state_target();
  void set_has_gear_enable_control();
  void clear_has_gear_enable_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int gear_enable_control_;
  int gear_state_target_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Torque_control_a3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Torque_control_a3) */ {
 public:
  Torque_control_a3();
  virtual ~Torque_control_a3();

  Torque_control_a3(const Torque_control_a3& from);

  inline Torque_control_a3& operator=(const Torque_control_a3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Torque_control_a3(Torque_control_a3&& from) noexcept
    : Torque_control_a3() {
    *this = ::std::move(from);
  }

  inline Torque_control_a3& operator=(Torque_control_a3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Torque_control_a3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Torque_control_a3* internal_default_instance() {
    return reinterpret_cast<const Torque_control_a3*>(
               &_Torque_control_a3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Torque_control_a3* other);
  friend void swap(Torque_control_a3& a, Torque_control_a3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Torque_control_a3* New() const final {
    return CreateMaybeMessage<Torque_control_a3>(NULL);
  }

  Torque_control_a3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Torque_control_a3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Torque_control_a3& from);
  void MergeFrom(const Torque_control_a3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Torque_control_a3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Torque_control_a3_Driven_enable_controlType Driven_enable_controlType;
  static const Driven_enable_controlType DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL =
    Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_MANUAL;
  static const Driven_enable_controlType DRIVEN_ENABLE_CONTROL_DRIVE_AUTO =
    Torque_control_a3_Driven_enable_controlType_DRIVEN_ENABLE_CONTROL_DRIVE_AUTO;
  static inline bool Driven_enable_controlType_IsValid(int value) {
    return Torque_control_a3_Driven_enable_controlType_IsValid(value);
  }
  static const Driven_enable_controlType Driven_enable_controlType_MIN =
    Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MIN;
  static const Driven_enable_controlType Driven_enable_controlType_MAX =
    Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_MAX;
  static const int Driven_enable_controlType_ARRAYSIZE =
    Torque_control_a3_Driven_enable_controlType_Driven_enable_controlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Driven_enable_controlType_descriptor() {
    return Torque_control_a3_Driven_enable_controlType_descriptor();
  }
  static inline const ::std::string& Driven_enable_controlType_Name(Driven_enable_controlType value) {
    return Torque_control_a3_Driven_enable_controlType_Name(value);
  }
  static inline bool Driven_enable_controlType_Parse(const ::std::string& name,
      Driven_enable_controlType* value) {
    return Torque_control_a3_Driven_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double driven_torque = 1;
  bool has_driven_torque() const;
  void clear_driven_torque();
  static const int kDrivenTorqueFieldNumber = 1;
  double driven_torque() const;
  void set_driven_torque(double value);

  // optional .apollo.canbus.Torque_control_a3.Driven_enable_controlType driven_enable_control = 2;
  bool has_driven_enable_control() const;
  void clear_driven_enable_control();
  static const int kDrivenEnableControlFieldNumber = 2;
  ::apollo::canbus::Torque_control_a3_Driven_enable_controlType driven_enable_control() const;
  void set_driven_enable_control(::apollo::canbus::Torque_control_a3_Driven_enable_controlType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Torque_control_a3)
 private:
  void set_has_driven_torque();
  void clear_has_driven_torque();
  void set_has_driven_enable_control();
  void clear_has_driven_enable_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double driven_torque_;
  int driven_enable_control_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Steering_control_a2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Steering_control_a2) */ {
 public:
  Steering_control_a2();
  virtual ~Steering_control_a2();

  Steering_control_a2(const Steering_control_a2& from);

  inline Steering_control_a2& operator=(const Steering_control_a2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Steering_control_a2(Steering_control_a2&& from) noexcept
    : Steering_control_a2() {
    *this = ::std::move(from);
  }

  inline Steering_control_a2& operator=(Steering_control_a2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Steering_control_a2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Steering_control_a2* internal_default_instance() {
    return reinterpret_cast<const Steering_control_a2*>(
               &_Steering_control_a2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Steering_control_a2* other);
  friend void swap(Steering_control_a2& a, Steering_control_a2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Steering_control_a2* New() const final {
    return CreateMaybeMessage<Steering_control_a2>(NULL);
  }

  Steering_control_a2* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Steering_control_a2>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Steering_control_a2& from);
  void MergeFrom(const Steering_control_a2& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Steering_control_a2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Steering_control_a2_Steering_enable_controlType Steering_enable_controlType;
  static const Steering_enable_controlType STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL =
    Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_MANUALCONTROL;
  static const Steering_enable_controlType STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL =
    Steering_control_a2_Steering_enable_controlType_STEERING_ENABLE_CONTROL_STEERING_AUTOCONTROL;
  static inline bool Steering_enable_controlType_IsValid(int value) {
    return Steering_control_a2_Steering_enable_controlType_IsValid(value);
  }
  static const Steering_enable_controlType Steering_enable_controlType_MIN =
    Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MIN;
  static const Steering_enable_controlType Steering_enable_controlType_MAX =
    Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_MAX;
  static const int Steering_enable_controlType_ARRAYSIZE =
    Steering_control_a2_Steering_enable_controlType_Steering_enable_controlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Steering_enable_controlType_descriptor() {
    return Steering_control_a2_Steering_enable_controlType_descriptor();
  }
  static inline const ::std::string& Steering_enable_controlType_Name(Steering_enable_controlType value) {
    return Steering_control_a2_Steering_enable_controlType_Name(value);
  }
  static inline bool Steering_enable_controlType_Parse(const ::std::string& name,
      Steering_enable_controlType* value) {
    return Steering_control_a2_Steering_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double steering_target = 1;
  bool has_steering_target() const;
  void clear_steering_target();
  static const int kSteeringTargetFieldNumber = 1;
  double steering_target() const;
  void set_steering_target(double value);

  // optional .apollo.canbus.Steering_control_a2.Steering_enable_controlType steering_enable_control = 2;
  bool has_steering_enable_control() const;
  void clear_steering_enable_control();
  static const int kSteeringEnableControlFieldNumber = 2;
  ::apollo::canbus::Steering_control_a2_Steering_enable_controlType steering_enable_control() const;
  void set_steering_enable_control(::apollo::canbus::Steering_control_a2_Steering_enable_controlType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Steering_control_a2)
 private:
  void set_has_steering_target();
  void clear_has_steering_target();
  void set_has_steering_enable_control();
  void clear_has_steering_enable_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double steering_target_;
  int steering_enable_control_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Parking_control_a5 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Parking_control_a5) */ {
 public:
  Parking_control_a5();
  virtual ~Parking_control_a5();

  Parking_control_a5(const Parking_control_a5& from);

  inline Parking_control_a5& operator=(const Parking_control_a5& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Parking_control_a5(Parking_control_a5&& from) noexcept
    : Parking_control_a5() {
    *this = ::std::move(from);
  }

  inline Parking_control_a5& operator=(Parking_control_a5&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parking_control_a5& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parking_control_a5* internal_default_instance() {
    return reinterpret_cast<const Parking_control_a5*>(
               &_Parking_control_a5_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Parking_control_a5* other);
  friend void swap(Parking_control_a5& a, Parking_control_a5& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Parking_control_a5* New() const final {
    return CreateMaybeMessage<Parking_control_a5>(NULL);
  }

  Parking_control_a5* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Parking_control_a5>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Parking_control_a5& from);
  void MergeFrom(const Parking_control_a5& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parking_control_a5* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Parking_control_a5_Parking_targetType Parking_targetType;
  static const Parking_targetType PARKING_TARGET_RELEASE =
    Parking_control_a5_Parking_targetType_PARKING_TARGET_RELEASE;
  static const Parking_targetType PARKING_TARGET_PARKING_TRIGGER =
    Parking_control_a5_Parking_targetType_PARKING_TARGET_PARKING_TRIGGER;
  static inline bool Parking_targetType_IsValid(int value) {
    return Parking_control_a5_Parking_targetType_IsValid(value);
  }
  static const Parking_targetType Parking_targetType_MIN =
    Parking_control_a5_Parking_targetType_Parking_targetType_MIN;
  static const Parking_targetType Parking_targetType_MAX =
    Parking_control_a5_Parking_targetType_Parking_targetType_MAX;
  static const int Parking_targetType_ARRAYSIZE =
    Parking_control_a5_Parking_targetType_Parking_targetType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Parking_targetType_descriptor() {
    return Parking_control_a5_Parking_targetType_descriptor();
  }
  static inline const ::std::string& Parking_targetType_Name(Parking_targetType value) {
    return Parking_control_a5_Parking_targetType_Name(value);
  }
  static inline bool Parking_targetType_Parse(const ::std::string& name,
      Parking_targetType* value) {
    return Parking_control_a5_Parking_targetType_Parse(name, value);
  }

  typedef Parking_control_a5_Parking_enable_controlType Parking_enable_controlType;
  static const Parking_enable_controlType PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL =
    Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_MANUALCONTROL;
  static const Parking_enable_controlType PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL =
    Parking_control_a5_Parking_enable_controlType_PARKING_ENABLE_CONTROL_PARKING_AUTOCONTROL;
  static inline bool Parking_enable_controlType_IsValid(int value) {
    return Parking_control_a5_Parking_enable_controlType_IsValid(value);
  }
  static const Parking_enable_controlType Parking_enable_controlType_MIN =
    Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MIN;
  static const Parking_enable_controlType Parking_enable_controlType_MAX =
    Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_MAX;
  static const int Parking_enable_controlType_ARRAYSIZE =
    Parking_control_a5_Parking_enable_controlType_Parking_enable_controlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Parking_enable_controlType_descriptor() {
    return Parking_control_a5_Parking_enable_controlType_descriptor();
  }
  static inline const ::std::string& Parking_enable_controlType_Name(Parking_enable_controlType value) {
    return Parking_control_a5_Parking_enable_controlType_Name(value);
  }
  static inline bool Parking_enable_controlType_Parse(const ::std::string& name,
      Parking_enable_controlType* value) {
    return Parking_control_a5_Parking_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Parking_control_a5.Parking_targetType parking_target = 1;
  bool has_parking_target() const;
  void clear_parking_target();
  static const int kParkingTargetFieldNumber = 1;
  ::apollo::canbus::Parking_control_a5_Parking_targetType parking_target() const;
  void set_parking_target(::apollo::canbus::Parking_control_a5_Parking_targetType value);

  // optional .apollo.canbus.Parking_control_a5.Parking_enable_controlType parking_enable_control = 2;
  bool has_parking_enable_control() const;
  void clear_parking_enable_control();
  static const int kParkingEnableControlFieldNumber = 2;
  ::apollo::canbus::Parking_control_a5_Parking_enable_controlType parking_enable_control() const;
  void set_parking_enable_control(::apollo::canbus::Parking_control_a5_Parking_enable_controlType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Parking_control_a5)
 private:
  void set_has_parking_target();
  void clear_has_parking_target();
  void set_has_parking_enable_control();
  void clear_has_parking_enable_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int parking_target_;
  int parking_enable_control_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Brake_control_a4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Brake_control_a4) */ {
 public:
  Brake_control_a4();
  virtual ~Brake_control_a4();

  Brake_control_a4(const Brake_control_a4& from);

  inline Brake_control_a4& operator=(const Brake_control_a4& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Brake_control_a4(Brake_control_a4&& from) noexcept
    : Brake_control_a4() {
    *this = ::std::move(from);
  }

  inline Brake_control_a4& operator=(Brake_control_a4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Brake_control_a4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brake_control_a4* internal_default_instance() {
    return reinterpret_cast<const Brake_control_a4*>(
               &_Brake_control_a4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Brake_control_a4* other);
  friend void swap(Brake_control_a4& a, Brake_control_a4& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Brake_control_a4* New() const final {
    return CreateMaybeMessage<Brake_control_a4>(NULL);
  }

  Brake_control_a4* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Brake_control_a4>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Brake_control_a4& from);
  void MergeFrom(const Brake_control_a4& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brake_control_a4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Brake_control_a4_Brake_enable_controlType Brake_enable_controlType;
  static const Brake_enable_controlType BRAKE_ENABLE_CONTROL_BRAKE_MANUAL =
    Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_MANUAL;
  static const Brake_enable_controlType BRAKE_ENABLE_CONTROL_BRAKE_AUTO =
    Brake_control_a4_Brake_enable_controlType_BRAKE_ENABLE_CONTROL_BRAKE_AUTO;
  static inline bool Brake_enable_controlType_IsValid(int value) {
    return Brake_control_a4_Brake_enable_controlType_IsValid(value);
  }
  static const Brake_enable_controlType Brake_enable_controlType_MIN =
    Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MIN;
  static const Brake_enable_controlType Brake_enable_controlType_MAX =
    Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_MAX;
  static const int Brake_enable_controlType_ARRAYSIZE =
    Brake_control_a4_Brake_enable_controlType_Brake_enable_controlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brake_enable_controlType_descriptor() {
    return Brake_control_a4_Brake_enable_controlType_descriptor();
  }
  static inline const ::std::string& Brake_enable_controlType_Name(Brake_enable_controlType value) {
    return Brake_control_a4_Brake_enable_controlType_Name(value);
  }
  static inline bool Brake_enable_controlType_Parse(const ::std::string& name,
      Brake_enable_controlType* value) {
    return Brake_control_a4_Brake_enable_controlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double brake_torque = 1;
  bool has_brake_torque() const;
  void clear_brake_torque();
  static const int kBrakeTorqueFieldNumber = 1;
  double brake_torque() const;
  void set_brake_torque(double value);

  // optional .apollo.canbus.Brake_control_a4.Brake_enable_controlType brake_enable_control = 2;
  bool has_brake_enable_control() const;
  void clear_brake_enable_control();
  static const int kBrakeEnableControlFieldNumber = 2;
  ::apollo::canbus::Brake_control_a4_Brake_enable_controlType brake_enable_control() const;
  void set_brake_enable_control(::apollo::canbus::Brake_control_a4_Brake_enable_controlType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Brake_control_a4)
 private:
  void set_has_brake_torque();
  void clear_has_brake_torque();
  void set_has_brake_enable_control();
  void clear_has_brake_enable_control();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double brake_torque_;
  int brake_enable_control_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Enable_state_feedback_c3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Enable_state_feedback_c3) */ {
 public:
  Enable_state_feedback_c3();
  virtual ~Enable_state_feedback_c3();

  Enable_state_feedback_c3(const Enable_state_feedback_c3& from);

  inline Enable_state_feedback_c3& operator=(const Enable_state_feedback_c3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Enable_state_feedback_c3(Enable_state_feedback_c3&& from) noexcept
    : Enable_state_feedback_c3() {
    *this = ::std::move(from);
  }

  inline Enable_state_feedback_c3& operator=(Enable_state_feedback_c3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Enable_state_feedback_c3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enable_state_feedback_c3* internal_default_instance() {
    return reinterpret_cast<const Enable_state_feedback_c3*>(
               &_Enable_state_feedback_c3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Enable_state_feedback_c3* other);
  friend void swap(Enable_state_feedback_c3& a, Enable_state_feedback_c3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Enable_state_feedback_c3* New() const final {
    return CreateMaybeMessage<Enable_state_feedback_c3>(NULL);
  }

  Enable_state_feedback_c3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Enable_state_feedback_c3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Enable_state_feedback_c3& from);
  void MergeFrom(const Enable_state_feedback_c3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enable_state_feedback_c3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Enable_state_feedback_c3_Parking_enable_stateType Parking_enable_stateType;
  static const Parking_enable_stateType PARKING_ENABLE_STATE_PARKING_MANUALCONTROL =
    Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_MANUALCONTROL;
  static const Parking_enable_stateType PARKING_ENABLE_STATE_PARKING_AUTOCONTROL =
    Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_AUTOCONTROL;
  static const Parking_enable_stateType PARKING_ENABLE_STATE_PARKING_TAKEOVER =
    Enable_state_feedback_c3_Parking_enable_stateType_PARKING_ENABLE_STATE_PARKING_TAKEOVER;
  static inline bool Parking_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Parking_enable_stateType_IsValid(value);
  }
  static const Parking_enable_stateType Parking_enable_stateType_MIN =
    Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MIN;
  static const Parking_enable_stateType Parking_enable_stateType_MAX =
    Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_MAX;
  static const int Parking_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Parking_enable_stateType_Parking_enable_stateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Parking_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Parking_enable_stateType_descriptor();
  }
  static inline const ::std::string& Parking_enable_stateType_Name(Parking_enable_stateType value) {
    return Enable_state_feedback_c3_Parking_enable_stateType_Name(value);
  }
  static inline bool Parking_enable_stateType_Parse(const ::std::string& name,
      Parking_enable_stateType* value) {
    return Enable_state_feedback_c3_Parking_enable_stateType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Steering_enable_stateType Steering_enable_stateType;
  static const Steering_enable_stateType STEERING_ENABLE_STATE_STEERING_MANUALCONTROL =
    Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUALCONTROL;
  static const Steering_enable_stateType STEERING_ENABLE_STATE_STEERING_AUTOCONTROL =
    Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_AUTOCONTROL;
  static const Steering_enable_stateType STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER =
    Enable_state_feedback_c3_Steering_enable_stateType_STEERING_ENABLE_STATE_STEERING_MANUAL_TAKEOVER;
  static inline bool Steering_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Steering_enable_stateType_IsValid(value);
  }
  static const Steering_enable_stateType Steering_enable_stateType_MIN =
    Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MIN;
  static const Steering_enable_stateType Steering_enable_stateType_MAX =
    Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_MAX;
  static const int Steering_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Steering_enable_stateType_Steering_enable_stateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Steering_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Steering_enable_stateType_descriptor();
  }
  static inline const ::std::string& Steering_enable_stateType_Name(Steering_enable_stateType value) {
    return Enable_state_feedback_c3_Steering_enable_stateType_Name(value);
  }
  static inline bool Steering_enable_stateType_Parse(const ::std::string& name,
      Steering_enable_stateType* value) {
    return Enable_state_feedback_c3_Steering_enable_stateType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Gear_enable_actualType Gear_enable_actualType;
  static const Gear_enable_actualType GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL =
    Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUALCONTROL;
  static const Gear_enable_actualType GEAR_ENABLE_ACTUAL_GEAR_AUTOCONTROL =
    Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_AUTOCONTROL;
  static const Gear_enable_actualType GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER =
    Enable_state_feedback_c3_Gear_enable_actualType_GEAR_ENABLE_ACTUAL_GEAR_MANUAL_TAKEOVER;
  static inline bool Gear_enable_actualType_IsValid(int value) {
    return Enable_state_feedback_c3_Gear_enable_actualType_IsValid(value);
  }
  static const Gear_enable_actualType Gear_enable_actualType_MIN =
    Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MIN;
  static const Gear_enable_actualType Gear_enable_actualType_MAX =
    Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_MAX;
  static const int Gear_enable_actualType_ARRAYSIZE =
    Enable_state_feedback_c3_Gear_enable_actualType_Gear_enable_actualType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gear_enable_actualType_descriptor() {
    return Enable_state_feedback_c3_Gear_enable_actualType_descriptor();
  }
  static inline const ::std::string& Gear_enable_actualType_Name(Gear_enable_actualType value) {
    return Enable_state_feedback_c3_Gear_enable_actualType_Name(value);
  }
  static inline bool Gear_enable_actualType_Parse(const ::std::string& name,
      Gear_enable_actualType* value) {
    return Enable_state_feedback_c3_Gear_enable_actualType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Driven_enable_stateType Driven_enable_stateType;
  static const Driven_enable_stateType DRIVEN_ENABLE_STATE_DRIVE_MANUAL =
    Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_MANUAL;
  static const Driven_enable_stateType DRIVEN_ENABLE_STATE_DRIVE_AUTO =
    Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_AUTO;
  static const Driven_enable_stateType DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER =
    Enable_state_feedback_c3_Driven_enable_stateType_DRIVEN_ENABLE_STATE_DRIVE_TAKEOVER;
  static inline bool Driven_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Driven_enable_stateType_IsValid(value);
  }
  static const Driven_enable_stateType Driven_enable_stateType_MIN =
    Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MIN;
  static const Driven_enable_stateType Driven_enable_stateType_MAX =
    Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_MAX;
  static const int Driven_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Driven_enable_stateType_Driven_enable_stateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Driven_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Driven_enable_stateType_descriptor();
  }
  static inline const ::std::string& Driven_enable_stateType_Name(Driven_enable_stateType value) {
    return Enable_state_feedback_c3_Driven_enable_stateType_Name(value);
  }
  static inline bool Driven_enable_stateType_Parse(const ::std::string& name,
      Driven_enable_stateType* value) {
    return Enable_state_feedback_c3_Driven_enable_stateType_Parse(name, value);
  }

  typedef Enable_state_feedback_c3_Brake_enable_stateType Brake_enable_stateType;
  static const Brake_enable_stateType BRAKE_ENABLE_STATE_BRAKE_MANUAL =
    Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_MANUAL;
  static const Brake_enable_stateType BRAKE_ENABLE_STATE_BRAKE_AUTO =
    Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_AUTO;
  static const Brake_enable_stateType BRAKE_ENABLE_STATE_BRAKE_TAKEOVER =
    Enable_state_feedback_c3_Brake_enable_stateType_BRAKE_ENABLE_STATE_BRAKE_TAKEOVER;
  static inline bool Brake_enable_stateType_IsValid(int value) {
    return Enable_state_feedback_c3_Brake_enable_stateType_IsValid(value);
  }
  static const Brake_enable_stateType Brake_enable_stateType_MIN =
    Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MIN;
  static const Brake_enable_stateType Brake_enable_stateType_MAX =
    Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_MAX;
  static const int Brake_enable_stateType_ARRAYSIZE =
    Enable_state_feedback_c3_Brake_enable_stateType_Brake_enable_stateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brake_enable_stateType_descriptor() {
    return Enable_state_feedback_c3_Brake_enable_stateType_descriptor();
  }
  static inline const ::std::string& Brake_enable_stateType_Name(Brake_enable_stateType value) {
    return Enable_state_feedback_c3_Brake_enable_stateType_Name(value);
  }
  static inline bool Brake_enable_stateType_Parse(const ::std::string& name,
      Brake_enable_stateType* value) {
    return Enable_state_feedback_c3_Brake_enable_stateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Enable_state_feedback_c3.Parking_enable_stateType parking_enable_state = 1;
  bool has_parking_enable_state() const;
  void clear_parking_enable_state();
  static const int kParkingEnableStateFieldNumber = 1;
  ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType parking_enable_state() const;
  void set_parking_enable_state(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType value);

  // optional .apollo.canbus.Enable_state_feedback_c3.Steering_enable_stateType steering_enable_state = 2;
  bool has_steering_enable_state() const;
  void clear_steering_enable_state();
  static const int kSteeringEnableStateFieldNumber = 2;
  ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType steering_enable_state() const;
  void set_steering_enable_state(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType value);

  // optional .apollo.canbus.Enable_state_feedback_c3.Gear_enable_actualType gear_enable_actual = 3;
  bool has_gear_enable_actual() const;
  void clear_gear_enable_actual();
  static const int kGearEnableActualFieldNumber = 3;
  ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType gear_enable_actual() const;
  void set_gear_enable_actual(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType value);

  // optional .apollo.canbus.Enable_state_feedback_c3.Driven_enable_stateType driven_enable_state = 4;
  bool has_driven_enable_state() const;
  void clear_driven_enable_state();
  static const int kDrivenEnableStateFieldNumber = 4;
  ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType driven_enable_state() const;
  void set_driven_enable_state(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType value);

  // optional .apollo.canbus.Enable_state_feedback_c3.Brake_enable_stateType brake_enable_state = 5;
  bool has_brake_enable_state() const;
  void clear_brake_enable_state();
  static const int kBrakeEnableStateFieldNumber = 5;
  ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType brake_enable_state() const;
  void set_brake_enable_state(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Enable_state_feedback_c3)
 private:
  void set_has_parking_enable_state();
  void clear_has_parking_enable_state();
  void set_has_steering_enable_state();
  void clear_has_steering_enable_state();
  void set_has_gear_enable_actual();
  void clear_has_gear_enable_actual();
  void set_has_driven_enable_state();
  void clear_has_driven_enable_state();
  void set_has_brake_enable_state();
  void clear_has_brake_enable_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int parking_enable_state_;
  int steering_enable_state_;
  int gear_enable_actual_;
  int driven_enable_state_;
  int brake_enable_state_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_state_feedback_c1 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Vehicle_state_feedback_c1) */ {
 public:
  Vehicle_state_feedback_c1();
  virtual ~Vehicle_state_feedback_c1();

  Vehicle_state_feedback_c1(const Vehicle_state_feedback_c1& from);

  inline Vehicle_state_feedback_c1& operator=(const Vehicle_state_feedback_c1& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_state_feedback_c1(Vehicle_state_feedback_c1&& from) noexcept
    : Vehicle_state_feedback_c1() {
    *this = ::std::move(from);
  }

  inline Vehicle_state_feedback_c1& operator=(Vehicle_state_feedback_c1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_state_feedback_c1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_state_feedback_c1* internal_default_instance() {
    return reinterpret_cast<const Vehicle_state_feedback_c1*>(
               &_Vehicle_state_feedback_c1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Vehicle_state_feedback_c1* other);
  friend void swap(Vehicle_state_feedback_c1& a, Vehicle_state_feedback_c1& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_state_feedback_c1* New() const final {
    return CreateMaybeMessage<Vehicle_state_feedback_c1>(NULL);
  }

  Vehicle_state_feedback_c1* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_state_feedback_c1>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle_state_feedback_c1& from);
  void MergeFrom(const Vehicle_state_feedback_c1& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_state_feedback_c1* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Vehicle_state_feedback_c1_Parking_actualType Parking_actualType;
  static const Parking_actualType PARKING_ACTUAL_RELEASE =
    Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_RELEASE;
  static const Parking_actualType PARKING_ACTUAL_PARKING_TRIGGER =
    Vehicle_state_feedback_c1_Parking_actualType_PARKING_ACTUAL_PARKING_TRIGGER;
  static inline bool Parking_actualType_IsValid(int value) {
    return Vehicle_state_feedback_c1_Parking_actualType_IsValid(value);
  }
  static const Parking_actualType Parking_actualType_MIN =
    Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MIN;
  static const Parking_actualType Parking_actualType_MAX =
    Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_MAX;
  static const int Parking_actualType_ARRAYSIZE =
    Vehicle_state_feedback_c1_Parking_actualType_Parking_actualType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Parking_actualType_descriptor() {
    return Vehicle_state_feedback_c1_Parking_actualType_descriptor();
  }
  static inline const ::std::string& Parking_actualType_Name(Parking_actualType value) {
    return Vehicle_state_feedback_c1_Parking_actualType_Name(value);
  }
  static inline bool Parking_actualType_Parse(const ::std::string& name,
      Parking_actualType* value) {
    return Vehicle_state_feedback_c1_Parking_actualType_Parse(name, value);
  }

  typedef Vehicle_state_feedback_c1_Gear_state_actualType Gear_state_actualType;
  static const Gear_state_actualType GEAR_STATE_ACTUAL_P =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_P;
  static const Gear_state_actualType GEAR_STATE_ACTUAL_N =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_N;
  static const Gear_state_actualType GEAR_STATE_ACTUAL_D =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_D;
  static const Gear_state_actualType GEAR_STATE_ACTUAL_R =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_R;
  static const Gear_state_actualType GEAR_STATE_ACTUAL_INVALID =
    Vehicle_state_feedback_c1_Gear_state_actualType_GEAR_STATE_ACTUAL_INVALID;
  static inline bool Gear_state_actualType_IsValid(int value) {
    return Vehicle_state_feedback_c1_Gear_state_actualType_IsValid(value);
  }
  static const Gear_state_actualType Gear_state_actualType_MIN =
    Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MIN;
  static const Gear_state_actualType Gear_state_actualType_MAX =
    Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_MAX;
  static const int Gear_state_actualType_ARRAYSIZE =
    Vehicle_state_feedback_c1_Gear_state_actualType_Gear_state_actualType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gear_state_actualType_descriptor() {
    return Vehicle_state_feedback_c1_Gear_state_actualType_descriptor();
  }
  static inline const ::std::string& Gear_state_actualType_Name(Gear_state_actualType value) {
    return Vehicle_state_feedback_c1_Gear_state_actualType_Name(value);
  }
  static inline bool Gear_state_actualType_Parse(const ::std::string& name,
      Gear_state_actualType* value) {
    return Vehicle_state_feedback_c1_Gear_state_actualType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double brake_torque_feedback = 2;
  bool has_brake_torque_feedback() const;
  void clear_brake_torque_feedback();
  static const int kBrakeTorqueFeedbackFieldNumber = 2;
  double brake_torque_feedback() const;
  void set_brake_torque_feedback(double value);

  // optional double steering_actual = 4;
  bool has_steering_actual() const;
  void clear_steering_actual();
  static const int kSteeringActualFieldNumber = 4;
  double steering_actual() const;
  void set_steering_actual(double value);

  // optional double speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  double speed() const;
  void set_speed(double value);

  // optional .apollo.canbus.Vehicle_state_feedback_c1.Parking_actualType parking_actual = 1;
  bool has_parking_actual() const;
  void clear_parking_actual();
  static const int kParkingActualFieldNumber = 1;
  ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType parking_actual() const;
  void set_parking_actual(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType value);

  // optional .apollo.canbus.Vehicle_state_feedback_c1.Gear_state_actualType gear_state_actual = 3;
  bool has_gear_state_actual() const;
  void clear_gear_state_actual();
  static const int kGearStateActualFieldNumber = 3;
  ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType gear_state_actual() const;
  void set_gear_state_actual(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Vehicle_state_feedback_c1)
 private:
  void set_has_parking_actual();
  void clear_has_parking_actual();
  void set_has_brake_torque_feedback();
  void clear_has_brake_torque_feedback();
  void set_has_gear_state_actual();
  void clear_has_gear_state_actual();
  void set_has_steering_actual();
  void clear_has_steering_actual();
  void set_has_speed();
  void clear_has_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double brake_torque_feedback_;
  double steering_actual_;
  double speed_;
  int parking_actual_;
  int gear_state_actual_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_state_e1 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Error_state_e1) */ {
 public:
  Error_state_e1();
  virtual ~Error_state_e1();

  Error_state_e1(const Error_state_e1& from);

  inline Error_state_e1& operator=(const Error_state_e1& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_state_e1(Error_state_e1&& from) noexcept
    : Error_state_e1() {
    *this = ::std::move(from);
  }

  inline Error_state_e1& operator=(Error_state_e1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_state_e1& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error_state_e1* internal_default_instance() {
    return reinterpret_cast<const Error_state_e1*>(
               &_Error_state_e1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Error_state_e1* other);
  friend void swap(Error_state_e1& a, Error_state_e1& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_state_e1* New() const final {
    return CreateMaybeMessage<Error_state_e1>(NULL);
  }

  Error_state_e1* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error_state_e1>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error_state_e1& from);
  void MergeFrom(const Error_state_e1& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error_state_e1* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Error_state_e1_Brake_error_codeType Brake_error_codeType;
  static const Brake_error_codeType BRAKE_ERROR_CODE_NO_ERROR =
    Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_NO_ERROR;
  static const Brake_error_codeType BRAKE_ERROR_CODE_ERROR =
    Error_state_e1_Brake_error_codeType_BRAKE_ERROR_CODE_ERROR;
  static inline bool Brake_error_codeType_IsValid(int value) {
    return Error_state_e1_Brake_error_codeType_IsValid(value);
  }
  static const Brake_error_codeType Brake_error_codeType_MIN =
    Error_state_e1_Brake_error_codeType_Brake_error_codeType_MIN;
  static const Brake_error_codeType Brake_error_codeType_MAX =
    Error_state_e1_Brake_error_codeType_Brake_error_codeType_MAX;
  static const int Brake_error_codeType_ARRAYSIZE =
    Error_state_e1_Brake_error_codeType_Brake_error_codeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brake_error_codeType_descriptor() {
    return Error_state_e1_Brake_error_codeType_descriptor();
  }
  static inline const ::std::string& Brake_error_codeType_Name(Brake_error_codeType value) {
    return Error_state_e1_Brake_error_codeType_Name(value);
  }
  static inline bool Brake_error_codeType_Parse(const ::std::string& name,
      Brake_error_codeType* value) {
    return Error_state_e1_Brake_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Driven_error_codeType Driven_error_codeType;
  static const Driven_error_codeType DRIVEN_ERROR_CODE_NO_ERROR =
    Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_NO_ERROR;
  static const Driven_error_codeType DRIVEN_ERROR_CODE_ERROR =
    Error_state_e1_Driven_error_codeType_DRIVEN_ERROR_CODE_ERROR;
  static inline bool Driven_error_codeType_IsValid(int value) {
    return Error_state_e1_Driven_error_codeType_IsValid(value);
  }
  static const Driven_error_codeType Driven_error_codeType_MIN =
    Error_state_e1_Driven_error_codeType_Driven_error_codeType_MIN;
  static const Driven_error_codeType Driven_error_codeType_MAX =
    Error_state_e1_Driven_error_codeType_Driven_error_codeType_MAX;
  static const int Driven_error_codeType_ARRAYSIZE =
    Error_state_e1_Driven_error_codeType_Driven_error_codeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Driven_error_codeType_descriptor() {
    return Error_state_e1_Driven_error_codeType_descriptor();
  }
  static inline const ::std::string& Driven_error_codeType_Name(Driven_error_codeType value) {
    return Error_state_e1_Driven_error_codeType_Name(value);
  }
  static inline bool Driven_error_codeType_Parse(const ::std::string& name,
      Driven_error_codeType* value) {
    return Error_state_e1_Driven_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Steering_error_codeType Steering_error_codeType;
  static const Steering_error_codeType STEERING_ERROR_CODE_NO_ERROR =
    Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_NO_ERROR;
  static const Steering_error_codeType STEERING_ERROR_CODE_ERROR =
    Error_state_e1_Steering_error_codeType_STEERING_ERROR_CODE_ERROR;
  static inline bool Steering_error_codeType_IsValid(int value) {
    return Error_state_e1_Steering_error_codeType_IsValid(value);
  }
  static const Steering_error_codeType Steering_error_codeType_MIN =
    Error_state_e1_Steering_error_codeType_Steering_error_codeType_MIN;
  static const Steering_error_codeType Steering_error_codeType_MAX =
    Error_state_e1_Steering_error_codeType_Steering_error_codeType_MAX;
  static const int Steering_error_codeType_ARRAYSIZE =
    Error_state_e1_Steering_error_codeType_Steering_error_codeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Steering_error_codeType_descriptor() {
    return Error_state_e1_Steering_error_codeType_descriptor();
  }
  static inline const ::std::string& Steering_error_codeType_Name(Steering_error_codeType value) {
    return Error_state_e1_Steering_error_codeType_Name(value);
  }
  static inline bool Steering_error_codeType_Parse(const ::std::string& name,
      Steering_error_codeType* value) {
    return Error_state_e1_Steering_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Parking_error_codeType Parking_error_codeType;
  static const Parking_error_codeType PARKING_ERROR_CODE_NO_ERROR =
    Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_NO_ERROR;
  static const Parking_error_codeType PARKING_ERROR_CODE_ERROR =
    Error_state_e1_Parking_error_codeType_PARKING_ERROR_CODE_ERROR;
  static inline bool Parking_error_codeType_IsValid(int value) {
    return Error_state_e1_Parking_error_codeType_IsValid(value);
  }
  static const Parking_error_codeType Parking_error_codeType_MIN =
    Error_state_e1_Parking_error_codeType_Parking_error_codeType_MIN;
  static const Parking_error_codeType Parking_error_codeType_MAX =
    Error_state_e1_Parking_error_codeType_Parking_error_codeType_MAX;
  static const int Parking_error_codeType_ARRAYSIZE =
    Error_state_e1_Parking_error_codeType_Parking_error_codeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Parking_error_codeType_descriptor() {
    return Error_state_e1_Parking_error_codeType_descriptor();
  }
  static inline const ::std::string& Parking_error_codeType_Name(Parking_error_codeType value) {
    return Error_state_e1_Parking_error_codeType_Name(value);
  }
  static inline bool Parking_error_codeType_Parse(const ::std::string& name,
      Parking_error_codeType* value) {
    return Error_state_e1_Parking_error_codeType_Parse(name, value);
  }

  typedef Error_state_e1_Gear_error_msgType Gear_error_msgType;
  static const Gear_error_msgType GEAR_ERROR_MSG_NO_ERROR =
    Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_NO_ERROR;
  static const Gear_error_msgType GEAR_ERROR_MSG_ERROR =
    Error_state_e1_Gear_error_msgType_GEAR_ERROR_MSG_ERROR;
  static inline bool Gear_error_msgType_IsValid(int value) {
    return Error_state_e1_Gear_error_msgType_IsValid(value);
  }
  static const Gear_error_msgType Gear_error_msgType_MIN =
    Error_state_e1_Gear_error_msgType_Gear_error_msgType_MIN;
  static const Gear_error_msgType Gear_error_msgType_MAX =
    Error_state_e1_Gear_error_msgType_Gear_error_msgType_MAX;
  static const int Gear_error_msgType_ARRAYSIZE =
    Error_state_e1_Gear_error_msgType_Gear_error_msgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gear_error_msgType_descriptor() {
    return Error_state_e1_Gear_error_msgType_descriptor();
  }
  static inline const ::std::string& Gear_error_msgType_Name(Gear_error_msgType value) {
    return Error_state_e1_Gear_error_msgType_Name(value);
  }
  static inline bool Gear_error_msgType_Parse(const ::std::string& name,
      Gear_error_msgType* value) {
    return Error_state_e1_Gear_error_msgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Error_state_e1.Brake_error_codeType brake_error_code = 1;
  bool has_brake_error_code() const;
  void clear_brake_error_code();
  static const int kBrakeErrorCodeFieldNumber = 1;
  ::apollo::canbus::Error_state_e1_Brake_error_codeType brake_error_code() const;
  void set_brake_error_code(::apollo::canbus::Error_state_e1_Brake_error_codeType value);

  // optional .apollo.canbus.Error_state_e1.Driven_error_codeType driven_error_code = 2;
  bool has_driven_error_code() const;
  void clear_driven_error_code();
  static const int kDrivenErrorCodeFieldNumber = 2;
  ::apollo::canbus::Error_state_e1_Driven_error_codeType driven_error_code() const;
  void set_driven_error_code(::apollo::canbus::Error_state_e1_Driven_error_codeType value);

  // optional .apollo.canbus.Error_state_e1.Steering_error_codeType steering_error_code = 3;
  bool has_steering_error_code() const;
  void clear_steering_error_code();
  static const int kSteeringErrorCodeFieldNumber = 3;
  ::apollo::canbus::Error_state_e1_Steering_error_codeType steering_error_code() const;
  void set_steering_error_code(::apollo::canbus::Error_state_e1_Steering_error_codeType value);

  // optional .apollo.canbus.Error_state_e1.Parking_error_codeType parking_error_code = 4;
  bool has_parking_error_code() const;
  void clear_parking_error_code();
  static const int kParkingErrorCodeFieldNumber = 4;
  ::apollo::canbus::Error_state_e1_Parking_error_codeType parking_error_code() const;
  void set_parking_error_code(::apollo::canbus::Error_state_e1_Parking_error_codeType value);

  // optional .apollo.canbus.Error_state_e1.Gear_error_msgType gear_error_msg = 5;
  bool has_gear_error_msg() const;
  void clear_gear_error_msg();
  static const int kGearErrorMsgFieldNumber = 5;
  ::apollo::canbus::Error_state_e1_Gear_error_msgType gear_error_msg() const;
  void set_gear_error_msg(::apollo::canbus::Error_state_e1_Gear_error_msgType value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Error_state_e1)
 private:
  void set_has_brake_error_code();
  void clear_has_brake_error_code();
  void set_has_driven_error_code();
  void clear_has_driven_error_code();
  void set_has_steering_error_code();
  void clear_has_steering_error_code();
  void set_has_parking_error_code();
  void clear_has_parking_error_code();
  void set_has_gear_error_msg();
  void clear_has_gear_error_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int brake_error_code_;
  int driven_error_code_;
  int steering_error_code_;
  int parking_error_code_;
  int gear_error_msg_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vehicle_state_feedback_2_c4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Vehicle_state_feedback_2_c4) */ {
 public:
  Vehicle_state_feedback_2_c4();
  virtual ~Vehicle_state_feedback_2_c4();

  Vehicle_state_feedback_2_c4(const Vehicle_state_feedback_2_c4& from);

  inline Vehicle_state_feedback_2_c4& operator=(const Vehicle_state_feedback_2_c4& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vehicle_state_feedback_2_c4(Vehicle_state_feedback_2_c4&& from) noexcept
    : Vehicle_state_feedback_2_c4() {
    *this = ::std::move(from);
  }

  inline Vehicle_state_feedback_2_c4& operator=(Vehicle_state_feedback_2_c4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_state_feedback_2_c4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle_state_feedback_2_c4* internal_default_instance() {
    return reinterpret_cast<const Vehicle_state_feedback_2_c4*>(
               &_Vehicle_state_feedback_2_c4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Vehicle_state_feedback_2_c4* other);
  friend void swap(Vehicle_state_feedback_2_c4& a, Vehicle_state_feedback_2_c4& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vehicle_state_feedback_2_c4* New() const final {
    return CreateMaybeMessage<Vehicle_state_feedback_2_c4>(NULL);
  }

  Vehicle_state_feedback_2_c4* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle_state_feedback_2_c4>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vehicle_state_feedback_2_c4& from);
  void MergeFrom(const Vehicle_state_feedback_2_c4& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle_state_feedback_2_c4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double driven_torque_feedback = 2;
  bool has_driven_torque_feedback() const;
  void clear_driven_torque_feedback();
  static const int kDrivenTorqueFeedbackFieldNumber = 2;
  double driven_torque_feedback() const;
  void set_driven_torque_feedback(double value);

  // optional int32 motor_speed = 1;
  bool has_motor_speed() const;
  void clear_motor_speed();
  static const int kMotorSpeedFieldNumber = 1;
  ::google::protobuf::int32 motor_speed() const;
  void set_motor_speed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Vehicle_state_feedback_2_c4)
 private:
  void set_has_motor_speed();
  void clear_has_motor_speed();
  void set_has_driven_torque_feedback();
  void clear_has_driven_torque_feedback();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double driven_torque_feedback_;
  ::google::protobuf::int32 motor_speed_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Zhongyun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.canbus.Zhongyun) */ {
 public:
  Zhongyun();
  virtual ~Zhongyun();

  Zhongyun(const Zhongyun& from);

  inline Zhongyun& operator=(const Zhongyun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Zhongyun(Zhongyun&& from) noexcept
    : Zhongyun() {
    *this = ::std::move(from);
  }

  inline Zhongyun& operator=(Zhongyun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zhongyun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Zhongyun* internal_default_instance() {
    return reinterpret_cast<const Zhongyun*>(
               &_Zhongyun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Zhongyun* other);
  friend void swap(Zhongyun& a, Zhongyun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Zhongyun* New() const final {
    return CreateMaybeMessage<Zhongyun>(NULL);
  }

  Zhongyun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Zhongyun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Zhongyun& from);
  void MergeFrom(const Zhongyun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Zhongyun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.canbus.Gear_control_a1 gear_control_a1 = 1;
  bool has_gear_control_a1() const;
  void clear_gear_control_a1();
  static const int kGearControlA1FieldNumber = 1;
  private:
  const ::apollo::canbus::Gear_control_a1& _internal_gear_control_a1() const;
  public:
  const ::apollo::canbus::Gear_control_a1& gear_control_a1() const;
  ::apollo::canbus::Gear_control_a1* release_gear_control_a1();
  ::apollo::canbus::Gear_control_a1* mutable_gear_control_a1();
  void set_allocated_gear_control_a1(::apollo::canbus::Gear_control_a1* gear_control_a1);

  // optional .apollo.canbus.Torque_control_a3 torque_control_a3 = 2;
  bool has_torque_control_a3() const;
  void clear_torque_control_a3();
  static const int kTorqueControlA3FieldNumber = 2;
  private:
  const ::apollo::canbus::Torque_control_a3& _internal_torque_control_a3() const;
  public:
  const ::apollo::canbus::Torque_control_a3& torque_control_a3() const;
  ::apollo::canbus::Torque_control_a3* release_torque_control_a3();
  ::apollo::canbus::Torque_control_a3* mutable_torque_control_a3();
  void set_allocated_torque_control_a3(::apollo::canbus::Torque_control_a3* torque_control_a3);

  // optional .apollo.canbus.Steering_control_a2 steering_control_a2 = 3;
  bool has_steering_control_a2() const;
  void clear_steering_control_a2();
  static const int kSteeringControlA2FieldNumber = 3;
  private:
  const ::apollo::canbus::Steering_control_a2& _internal_steering_control_a2() const;
  public:
  const ::apollo::canbus::Steering_control_a2& steering_control_a2() const;
  ::apollo::canbus::Steering_control_a2* release_steering_control_a2();
  ::apollo::canbus::Steering_control_a2* mutable_steering_control_a2();
  void set_allocated_steering_control_a2(::apollo::canbus::Steering_control_a2* steering_control_a2);

  // optional .apollo.canbus.Parking_control_a5 parking_control_a5 = 4;
  bool has_parking_control_a5() const;
  void clear_parking_control_a5();
  static const int kParkingControlA5FieldNumber = 4;
  private:
  const ::apollo::canbus::Parking_control_a5& _internal_parking_control_a5() const;
  public:
  const ::apollo::canbus::Parking_control_a5& parking_control_a5() const;
  ::apollo::canbus::Parking_control_a5* release_parking_control_a5();
  ::apollo::canbus::Parking_control_a5* mutable_parking_control_a5();
  void set_allocated_parking_control_a5(::apollo::canbus::Parking_control_a5* parking_control_a5);

  // optional .apollo.canbus.Brake_control_a4 brake_control_a4 = 5;
  bool has_brake_control_a4() const;
  void clear_brake_control_a4();
  static const int kBrakeControlA4FieldNumber = 5;
  private:
  const ::apollo::canbus::Brake_control_a4& _internal_brake_control_a4() const;
  public:
  const ::apollo::canbus::Brake_control_a4& brake_control_a4() const;
  ::apollo::canbus::Brake_control_a4* release_brake_control_a4();
  ::apollo::canbus::Brake_control_a4* mutable_brake_control_a4();
  void set_allocated_brake_control_a4(::apollo::canbus::Brake_control_a4* brake_control_a4);

  // optional .apollo.canbus.Enable_state_feedback_c3 enable_state_feedback_c3 = 6;
  bool has_enable_state_feedback_c3() const;
  void clear_enable_state_feedback_c3();
  static const int kEnableStateFeedbackC3FieldNumber = 6;
  private:
  const ::apollo::canbus::Enable_state_feedback_c3& _internal_enable_state_feedback_c3() const;
  public:
  const ::apollo::canbus::Enable_state_feedback_c3& enable_state_feedback_c3() const;
  ::apollo::canbus::Enable_state_feedback_c3* release_enable_state_feedback_c3();
  ::apollo::canbus::Enable_state_feedback_c3* mutable_enable_state_feedback_c3();
  void set_allocated_enable_state_feedback_c3(::apollo::canbus::Enable_state_feedback_c3* enable_state_feedback_c3);

  // optional .apollo.canbus.Vehicle_state_feedback_c1 vehicle_state_feedback_c1 = 7;
  bool has_vehicle_state_feedback_c1() const;
  void clear_vehicle_state_feedback_c1();
  static const int kVehicleStateFeedbackC1FieldNumber = 7;
  private:
  const ::apollo::canbus::Vehicle_state_feedback_c1& _internal_vehicle_state_feedback_c1() const;
  public:
  const ::apollo::canbus::Vehicle_state_feedback_c1& vehicle_state_feedback_c1() const;
  ::apollo::canbus::Vehicle_state_feedback_c1* release_vehicle_state_feedback_c1();
  ::apollo::canbus::Vehicle_state_feedback_c1* mutable_vehicle_state_feedback_c1();
  void set_allocated_vehicle_state_feedback_c1(::apollo::canbus::Vehicle_state_feedback_c1* vehicle_state_feedback_c1);

  // optional .apollo.canbus.Error_state_e1 error_state_e1 = 8;
  bool has_error_state_e1() const;
  void clear_error_state_e1();
  static const int kErrorStateE1FieldNumber = 8;
  private:
  const ::apollo::canbus::Error_state_e1& _internal_error_state_e1() const;
  public:
  const ::apollo::canbus::Error_state_e1& error_state_e1() const;
  ::apollo::canbus::Error_state_e1* release_error_state_e1();
  ::apollo::canbus::Error_state_e1* mutable_error_state_e1();
  void set_allocated_error_state_e1(::apollo::canbus::Error_state_e1* error_state_e1);

  // optional .apollo.canbus.Vehicle_state_feedback_2_c4 vehicle_state_feedback_2_c4 = 9;
  bool has_vehicle_state_feedback_2_c4() const;
  void clear_vehicle_state_feedback_2_c4();
  static const int kVehicleStateFeedback2C4FieldNumber = 9;
  private:
  const ::apollo::canbus::Vehicle_state_feedback_2_c4& _internal_vehicle_state_feedback_2_c4() const;
  public:
  const ::apollo::canbus::Vehicle_state_feedback_2_c4& vehicle_state_feedback_2_c4() const;
  ::apollo::canbus::Vehicle_state_feedback_2_c4* release_vehicle_state_feedback_2_c4();
  ::apollo::canbus::Vehicle_state_feedback_2_c4* mutable_vehicle_state_feedback_2_c4();
  void set_allocated_vehicle_state_feedback_2_c4(::apollo::canbus::Vehicle_state_feedback_2_c4* vehicle_state_feedback_2_c4);

  // @@protoc_insertion_point(class_scope:apollo.canbus.Zhongyun)
 private:
  void set_has_gear_control_a1();
  void clear_has_gear_control_a1();
  void set_has_torque_control_a3();
  void clear_has_torque_control_a3();
  void set_has_steering_control_a2();
  void clear_has_steering_control_a2();
  void set_has_parking_control_a5();
  void clear_has_parking_control_a5();
  void set_has_brake_control_a4();
  void clear_has_brake_control_a4();
  void set_has_enable_state_feedback_c3();
  void clear_has_enable_state_feedback_c3();
  void set_has_vehicle_state_feedback_c1();
  void clear_has_vehicle_state_feedback_c1();
  void set_has_error_state_e1();
  void clear_has_error_state_e1();
  void set_has_vehicle_state_feedback_2_c4();
  void clear_has_vehicle_state_feedback_2_c4();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::canbus::Gear_control_a1* gear_control_a1_;
  ::apollo::canbus::Torque_control_a3* torque_control_a3_;
  ::apollo::canbus::Steering_control_a2* steering_control_a2_;
  ::apollo::canbus::Parking_control_a5* parking_control_a5_;
  ::apollo::canbus::Brake_control_a4* brake_control_a4_;
  ::apollo::canbus::Enable_state_feedback_c3* enable_state_feedback_c3_;
  ::apollo::canbus::Vehicle_state_feedback_c1* vehicle_state_feedback_c1_;
  ::apollo::canbus::Error_state_e1* error_state_e1_;
  ::apollo::canbus::Vehicle_state_feedback_2_c4* vehicle_state_feedback_2_c4_;
  friend struct ::protobuf_modules_2fcanbus_2fproto_2fzhongyun_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gear_control_a1

// optional .apollo.canbus.Gear_control_a1.Gear_state_targetType gear_state_target = 1;
inline bool Gear_control_a1::has_gear_state_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gear_control_a1::set_has_gear_state_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gear_control_a1::clear_has_gear_state_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gear_control_a1::clear_gear_state_target() {
  gear_state_target_ = 1;
  clear_has_gear_state_target();
}
inline ::apollo::canbus::Gear_control_a1_Gear_state_targetType Gear_control_a1::gear_state_target() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear_control_a1.gear_state_target)
  return static_cast< ::apollo::canbus::Gear_control_a1_Gear_state_targetType >(gear_state_target_);
}
inline void Gear_control_a1::set_gear_state_target(::apollo::canbus::Gear_control_a1_Gear_state_targetType value) {
  assert(::apollo::canbus::Gear_control_a1_Gear_state_targetType_IsValid(value));
  set_has_gear_state_target();
  gear_state_target_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear_control_a1.gear_state_target)
}

// optional .apollo.canbus.Gear_control_a1.Gear_enable_controlType gear_enable_control = 2;
inline bool Gear_control_a1::has_gear_enable_control() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gear_control_a1::set_has_gear_enable_control() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gear_control_a1::clear_has_gear_enable_control() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gear_control_a1::clear_gear_enable_control() {
  gear_enable_control_ = 0;
  clear_has_gear_enable_control();
}
inline ::apollo::canbus::Gear_control_a1_Gear_enable_controlType Gear_control_a1::gear_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Gear_control_a1.gear_enable_control)
  return static_cast< ::apollo::canbus::Gear_control_a1_Gear_enable_controlType >(gear_enable_control_);
}
inline void Gear_control_a1::set_gear_enable_control(::apollo::canbus::Gear_control_a1_Gear_enable_controlType value) {
  assert(::apollo::canbus::Gear_control_a1_Gear_enable_controlType_IsValid(value));
  set_has_gear_enable_control();
  gear_enable_control_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Gear_control_a1.gear_enable_control)
}

// -------------------------------------------------------------------

// Torque_control_a3

// optional double driven_torque = 1;
inline bool Torque_control_a3::has_driven_torque() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Torque_control_a3::set_has_driven_torque() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Torque_control_a3::clear_has_driven_torque() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Torque_control_a3::clear_driven_torque() {
  driven_torque_ = 0;
  clear_has_driven_torque();
}
inline double Torque_control_a3::driven_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Torque_control_a3.driven_torque)
  return driven_torque_;
}
inline void Torque_control_a3::set_driven_torque(double value) {
  set_has_driven_torque();
  driven_torque_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Torque_control_a3.driven_torque)
}

// optional .apollo.canbus.Torque_control_a3.Driven_enable_controlType driven_enable_control = 2;
inline bool Torque_control_a3::has_driven_enable_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Torque_control_a3::set_has_driven_enable_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Torque_control_a3::clear_has_driven_enable_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Torque_control_a3::clear_driven_enable_control() {
  driven_enable_control_ = 0;
  clear_has_driven_enable_control();
}
inline ::apollo::canbus::Torque_control_a3_Driven_enable_controlType Torque_control_a3::driven_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Torque_control_a3.driven_enable_control)
  return static_cast< ::apollo::canbus::Torque_control_a3_Driven_enable_controlType >(driven_enable_control_);
}
inline void Torque_control_a3::set_driven_enable_control(::apollo::canbus::Torque_control_a3_Driven_enable_controlType value) {
  assert(::apollo::canbus::Torque_control_a3_Driven_enable_controlType_IsValid(value));
  set_has_driven_enable_control();
  driven_enable_control_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Torque_control_a3.driven_enable_control)
}

// -------------------------------------------------------------------

// Steering_control_a2

// optional double steering_target = 1;
inline bool Steering_control_a2::has_steering_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Steering_control_a2::set_has_steering_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Steering_control_a2::clear_has_steering_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Steering_control_a2::clear_steering_target() {
  steering_target_ = 0;
  clear_has_steering_target();
}
inline double Steering_control_a2::steering_target() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_control_a2.steering_target)
  return steering_target_;
}
inline void Steering_control_a2::set_steering_target(double value) {
  set_has_steering_target();
  steering_target_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_control_a2.steering_target)
}

// optional .apollo.canbus.Steering_control_a2.Steering_enable_controlType steering_enable_control = 2;
inline bool Steering_control_a2::has_steering_enable_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Steering_control_a2::set_has_steering_enable_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Steering_control_a2::clear_has_steering_enable_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Steering_control_a2::clear_steering_enable_control() {
  steering_enable_control_ = 0;
  clear_has_steering_enable_control();
}
inline ::apollo::canbus::Steering_control_a2_Steering_enable_controlType Steering_control_a2::steering_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Steering_control_a2.steering_enable_control)
  return static_cast< ::apollo::canbus::Steering_control_a2_Steering_enable_controlType >(steering_enable_control_);
}
inline void Steering_control_a2::set_steering_enable_control(::apollo::canbus::Steering_control_a2_Steering_enable_controlType value) {
  assert(::apollo::canbus::Steering_control_a2_Steering_enable_controlType_IsValid(value));
  set_has_steering_enable_control();
  steering_enable_control_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Steering_control_a2.steering_enable_control)
}

// -------------------------------------------------------------------

// Parking_control_a5

// optional .apollo.canbus.Parking_control_a5.Parking_targetType parking_target = 1;
inline bool Parking_control_a5::has_parking_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parking_control_a5::set_has_parking_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parking_control_a5::clear_has_parking_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parking_control_a5::clear_parking_target() {
  parking_target_ = 0;
  clear_has_parking_target();
}
inline ::apollo::canbus::Parking_control_a5_Parking_targetType Parking_control_a5::parking_target() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Parking_control_a5.parking_target)
  return static_cast< ::apollo::canbus::Parking_control_a5_Parking_targetType >(parking_target_);
}
inline void Parking_control_a5::set_parking_target(::apollo::canbus::Parking_control_a5_Parking_targetType value) {
  assert(::apollo::canbus::Parking_control_a5_Parking_targetType_IsValid(value));
  set_has_parking_target();
  parking_target_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Parking_control_a5.parking_target)
}

// optional .apollo.canbus.Parking_control_a5.Parking_enable_controlType parking_enable_control = 2;
inline bool Parking_control_a5::has_parking_enable_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parking_control_a5::set_has_parking_enable_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parking_control_a5::clear_has_parking_enable_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parking_control_a5::clear_parking_enable_control() {
  parking_enable_control_ = 0;
  clear_has_parking_enable_control();
}
inline ::apollo::canbus::Parking_control_a5_Parking_enable_controlType Parking_control_a5::parking_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Parking_control_a5.parking_enable_control)
  return static_cast< ::apollo::canbus::Parking_control_a5_Parking_enable_controlType >(parking_enable_control_);
}
inline void Parking_control_a5::set_parking_enable_control(::apollo::canbus::Parking_control_a5_Parking_enable_controlType value) {
  assert(::apollo::canbus::Parking_control_a5_Parking_enable_controlType_IsValid(value));
  set_has_parking_enable_control();
  parking_enable_control_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Parking_control_a5.parking_enable_control)
}

// -------------------------------------------------------------------

// Brake_control_a4

// optional double brake_torque = 1;
inline bool Brake_control_a4::has_brake_torque() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Brake_control_a4::set_has_brake_torque() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Brake_control_a4::clear_has_brake_torque() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Brake_control_a4::clear_brake_torque() {
  brake_torque_ = 0;
  clear_has_brake_torque();
}
inline double Brake_control_a4::brake_torque() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_control_a4.brake_torque)
  return brake_torque_;
}
inline void Brake_control_a4::set_brake_torque(double value) {
  set_has_brake_torque();
  brake_torque_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_control_a4.brake_torque)
}

// optional .apollo.canbus.Brake_control_a4.Brake_enable_controlType brake_enable_control = 2;
inline bool Brake_control_a4::has_brake_enable_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Brake_control_a4::set_has_brake_enable_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Brake_control_a4::clear_has_brake_enable_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Brake_control_a4::clear_brake_enable_control() {
  brake_enable_control_ = 0;
  clear_has_brake_enable_control();
}
inline ::apollo::canbus::Brake_control_a4_Brake_enable_controlType Brake_control_a4::brake_enable_control() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Brake_control_a4.brake_enable_control)
  return static_cast< ::apollo::canbus::Brake_control_a4_Brake_enable_controlType >(brake_enable_control_);
}
inline void Brake_control_a4::set_brake_enable_control(::apollo::canbus::Brake_control_a4_Brake_enable_controlType value) {
  assert(::apollo::canbus::Brake_control_a4_Brake_enable_controlType_IsValid(value));
  set_has_brake_enable_control();
  brake_enable_control_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Brake_control_a4.brake_enable_control)
}

// -------------------------------------------------------------------

// Enable_state_feedback_c3

// optional .apollo.canbus.Enable_state_feedback_c3.Parking_enable_stateType parking_enable_state = 1;
inline bool Enable_state_feedback_c3::has_parking_enable_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Enable_state_feedback_c3::set_has_parking_enable_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Enable_state_feedback_c3::clear_has_parking_enable_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Enable_state_feedback_c3::clear_parking_enable_state() {
  parking_enable_state_ = 0;
  clear_has_parking_enable_state();
}
inline ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType Enable_state_feedback_c3::parking_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.parking_enable_state)
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType >(parking_enable_state_);
}
inline void Enable_state_feedback_c3::set_parking_enable_state(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType_IsValid(value));
  set_has_parking_enable_state();
  parking_enable_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.parking_enable_state)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Steering_enable_stateType steering_enable_state = 2;
inline bool Enable_state_feedback_c3::has_steering_enable_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Enable_state_feedback_c3::set_has_steering_enable_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Enable_state_feedback_c3::clear_has_steering_enable_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Enable_state_feedback_c3::clear_steering_enable_state() {
  steering_enable_state_ = 0;
  clear_has_steering_enable_state();
}
inline ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType Enable_state_feedback_c3::steering_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.steering_enable_state)
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType >(steering_enable_state_);
}
inline void Enable_state_feedback_c3::set_steering_enable_state(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType_IsValid(value));
  set_has_steering_enable_state();
  steering_enable_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.steering_enable_state)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Gear_enable_actualType gear_enable_actual = 3;
inline bool Enable_state_feedback_c3::has_gear_enable_actual() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Enable_state_feedback_c3::set_has_gear_enable_actual() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Enable_state_feedback_c3::clear_has_gear_enable_actual() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Enable_state_feedback_c3::clear_gear_enable_actual() {
  gear_enable_actual_ = 0;
  clear_has_gear_enable_actual();
}
inline ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType Enable_state_feedback_c3::gear_enable_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.gear_enable_actual)
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType >(gear_enable_actual_);
}
inline void Enable_state_feedback_c3::set_gear_enable_actual(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType_IsValid(value));
  set_has_gear_enable_actual();
  gear_enable_actual_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.gear_enable_actual)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Driven_enable_stateType driven_enable_state = 4;
inline bool Enable_state_feedback_c3::has_driven_enable_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Enable_state_feedback_c3::set_has_driven_enable_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Enable_state_feedback_c3::clear_has_driven_enable_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Enable_state_feedback_c3::clear_driven_enable_state() {
  driven_enable_state_ = 0;
  clear_has_driven_enable_state();
}
inline ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType Enable_state_feedback_c3::driven_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.driven_enable_state)
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType >(driven_enable_state_);
}
inline void Enable_state_feedback_c3::set_driven_enable_state(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType_IsValid(value));
  set_has_driven_enable_state();
  driven_enable_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.driven_enable_state)
}

// optional .apollo.canbus.Enable_state_feedback_c3.Brake_enable_stateType brake_enable_state = 5;
inline bool Enable_state_feedback_c3::has_brake_enable_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Enable_state_feedback_c3::set_has_brake_enable_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Enable_state_feedback_c3::clear_has_brake_enable_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Enable_state_feedback_c3::clear_brake_enable_state() {
  brake_enable_state_ = 0;
  clear_has_brake_enable_state();
}
inline ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType Enable_state_feedback_c3::brake_enable_state() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Enable_state_feedback_c3.brake_enable_state)
  return static_cast< ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType >(brake_enable_state_);
}
inline void Enable_state_feedback_c3::set_brake_enable_state(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType value) {
  assert(::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType_IsValid(value));
  set_has_brake_enable_state();
  brake_enable_state_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Enable_state_feedback_c3.brake_enable_state)
}

// -------------------------------------------------------------------

// Vehicle_state_feedback_c1

// optional .apollo.canbus.Vehicle_state_feedback_c1.Parking_actualType parking_actual = 1;
inline bool Vehicle_state_feedback_c1::has_parking_actual() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vehicle_state_feedback_c1::set_has_parking_actual() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vehicle_state_feedback_c1::clear_has_parking_actual() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vehicle_state_feedback_c1::clear_parking_actual() {
  parking_actual_ = 0;
  clear_has_parking_actual();
}
inline ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType Vehicle_state_feedback_c1::parking_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.parking_actual)
  return static_cast< ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType >(parking_actual_);
}
inline void Vehicle_state_feedback_c1::set_parking_actual(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType value) {
  assert(::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType_IsValid(value));
  set_has_parking_actual();
  parking_actual_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.parking_actual)
}

// optional double brake_torque_feedback = 2;
inline bool Vehicle_state_feedback_c1::has_brake_torque_feedback() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_state_feedback_c1::set_has_brake_torque_feedback() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_state_feedback_c1::clear_has_brake_torque_feedback() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_state_feedback_c1::clear_brake_torque_feedback() {
  brake_torque_feedback_ = 0;
  clear_has_brake_torque_feedback();
}
inline double Vehicle_state_feedback_c1::brake_torque_feedback() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.brake_torque_feedback)
  return brake_torque_feedback_;
}
inline void Vehicle_state_feedback_c1::set_brake_torque_feedback(double value) {
  set_has_brake_torque_feedback();
  brake_torque_feedback_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.brake_torque_feedback)
}

// optional .apollo.canbus.Vehicle_state_feedback_c1.Gear_state_actualType gear_state_actual = 3;
inline bool Vehicle_state_feedback_c1::has_gear_state_actual() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vehicle_state_feedback_c1::set_has_gear_state_actual() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vehicle_state_feedback_c1::clear_has_gear_state_actual() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vehicle_state_feedback_c1::clear_gear_state_actual() {
  gear_state_actual_ = 1;
  clear_has_gear_state_actual();
}
inline ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType Vehicle_state_feedback_c1::gear_state_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.gear_state_actual)
  return static_cast< ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType >(gear_state_actual_);
}
inline void Vehicle_state_feedback_c1::set_gear_state_actual(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType value) {
  assert(::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType_IsValid(value));
  set_has_gear_state_actual();
  gear_state_actual_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.gear_state_actual)
}

// optional double steering_actual = 4;
inline bool Vehicle_state_feedback_c1::has_steering_actual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_state_feedback_c1::set_has_steering_actual() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_state_feedback_c1::clear_has_steering_actual() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_state_feedback_c1::clear_steering_actual() {
  steering_actual_ = 0;
  clear_has_steering_actual();
}
inline double Vehicle_state_feedback_c1::steering_actual() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.steering_actual)
  return steering_actual_;
}
inline void Vehicle_state_feedback_c1::set_steering_actual(double value) {
  set_has_steering_actual();
  steering_actual_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.steering_actual)
}

// optional double speed = 5;
inline bool Vehicle_state_feedback_c1::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vehicle_state_feedback_c1::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vehicle_state_feedback_c1::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vehicle_state_feedback_c1::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Vehicle_state_feedback_c1::speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_c1.speed)
  return speed_;
}
inline void Vehicle_state_feedback_c1::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_c1.speed)
}

// -------------------------------------------------------------------

// Error_state_e1

// optional .apollo.canbus.Error_state_e1.Brake_error_codeType brake_error_code = 1;
inline bool Error_state_e1::has_brake_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error_state_e1::set_has_brake_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error_state_e1::clear_has_brake_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error_state_e1::clear_brake_error_code() {
  brake_error_code_ = 0;
  clear_has_brake_error_code();
}
inline ::apollo::canbus::Error_state_e1_Brake_error_codeType Error_state_e1::brake_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.brake_error_code)
  return static_cast< ::apollo::canbus::Error_state_e1_Brake_error_codeType >(brake_error_code_);
}
inline void Error_state_e1::set_brake_error_code(::apollo::canbus::Error_state_e1_Brake_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Brake_error_codeType_IsValid(value));
  set_has_brake_error_code();
  brake_error_code_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.brake_error_code)
}

// optional .apollo.canbus.Error_state_e1.Driven_error_codeType driven_error_code = 2;
inline bool Error_state_e1::has_driven_error_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error_state_e1::set_has_driven_error_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error_state_e1::clear_has_driven_error_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error_state_e1::clear_driven_error_code() {
  driven_error_code_ = 0;
  clear_has_driven_error_code();
}
inline ::apollo::canbus::Error_state_e1_Driven_error_codeType Error_state_e1::driven_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.driven_error_code)
  return static_cast< ::apollo::canbus::Error_state_e1_Driven_error_codeType >(driven_error_code_);
}
inline void Error_state_e1::set_driven_error_code(::apollo::canbus::Error_state_e1_Driven_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Driven_error_codeType_IsValid(value));
  set_has_driven_error_code();
  driven_error_code_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.driven_error_code)
}

// optional .apollo.canbus.Error_state_e1.Steering_error_codeType steering_error_code = 3;
inline bool Error_state_e1::has_steering_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Error_state_e1::set_has_steering_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Error_state_e1::clear_has_steering_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Error_state_e1::clear_steering_error_code() {
  steering_error_code_ = 0;
  clear_has_steering_error_code();
}
inline ::apollo::canbus::Error_state_e1_Steering_error_codeType Error_state_e1::steering_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.steering_error_code)
  return static_cast< ::apollo::canbus::Error_state_e1_Steering_error_codeType >(steering_error_code_);
}
inline void Error_state_e1::set_steering_error_code(::apollo::canbus::Error_state_e1_Steering_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Steering_error_codeType_IsValid(value));
  set_has_steering_error_code();
  steering_error_code_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.steering_error_code)
}

// optional .apollo.canbus.Error_state_e1.Parking_error_codeType parking_error_code = 4;
inline bool Error_state_e1::has_parking_error_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Error_state_e1::set_has_parking_error_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Error_state_e1::clear_has_parking_error_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Error_state_e1::clear_parking_error_code() {
  parking_error_code_ = 0;
  clear_has_parking_error_code();
}
inline ::apollo::canbus::Error_state_e1_Parking_error_codeType Error_state_e1::parking_error_code() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.parking_error_code)
  return static_cast< ::apollo::canbus::Error_state_e1_Parking_error_codeType >(parking_error_code_);
}
inline void Error_state_e1::set_parking_error_code(::apollo::canbus::Error_state_e1_Parking_error_codeType value) {
  assert(::apollo::canbus::Error_state_e1_Parking_error_codeType_IsValid(value));
  set_has_parking_error_code();
  parking_error_code_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.parking_error_code)
}

// optional .apollo.canbus.Error_state_e1.Gear_error_msgType gear_error_msg = 5;
inline bool Error_state_e1::has_gear_error_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Error_state_e1::set_has_gear_error_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Error_state_e1::clear_has_gear_error_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Error_state_e1::clear_gear_error_msg() {
  gear_error_msg_ = 0;
  clear_has_gear_error_msg();
}
inline ::apollo::canbus::Error_state_e1_Gear_error_msgType Error_state_e1::gear_error_msg() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Error_state_e1.gear_error_msg)
  return static_cast< ::apollo::canbus::Error_state_e1_Gear_error_msgType >(gear_error_msg_);
}
inline void Error_state_e1::set_gear_error_msg(::apollo::canbus::Error_state_e1_Gear_error_msgType value) {
  assert(::apollo::canbus::Error_state_e1_Gear_error_msgType_IsValid(value));
  set_has_gear_error_msg();
  gear_error_msg_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Error_state_e1.gear_error_msg)
}

// -------------------------------------------------------------------

// Vehicle_state_feedback_2_c4

// optional int32 motor_speed = 1;
inline bool Vehicle_state_feedback_2_c4::has_motor_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_state_feedback_2_c4::set_has_motor_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_state_feedback_2_c4::clear_has_motor_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_state_feedback_2_c4::clear_motor_speed() {
  motor_speed_ = 0;
  clear_has_motor_speed();
}
inline ::google::protobuf::int32 Vehicle_state_feedback_2_c4::motor_speed() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_2_c4.motor_speed)
  return motor_speed_;
}
inline void Vehicle_state_feedback_2_c4::set_motor_speed(::google::protobuf::int32 value) {
  set_has_motor_speed();
  motor_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_2_c4.motor_speed)
}

// optional double driven_torque_feedback = 2;
inline bool Vehicle_state_feedback_2_c4::has_driven_torque_feedback() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_state_feedback_2_c4::set_has_driven_torque_feedback() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_state_feedback_2_c4::clear_has_driven_torque_feedback() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_state_feedback_2_c4::clear_driven_torque_feedback() {
  driven_torque_feedback_ = 0;
  clear_has_driven_torque_feedback();
}
inline double Vehicle_state_feedback_2_c4::driven_torque_feedback() const {
  // @@protoc_insertion_point(field_get:apollo.canbus.Vehicle_state_feedback_2_c4.driven_torque_feedback)
  return driven_torque_feedback_;
}
inline void Vehicle_state_feedback_2_c4::set_driven_torque_feedback(double value) {
  set_has_driven_torque_feedback();
  driven_torque_feedback_ = value;
  // @@protoc_insertion_point(field_set:apollo.canbus.Vehicle_state_feedback_2_c4.driven_torque_feedback)
}

// -------------------------------------------------------------------

// Zhongyun

// optional .apollo.canbus.Gear_control_a1 gear_control_a1 = 1;
inline bool Zhongyun::has_gear_control_a1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Zhongyun::set_has_gear_control_a1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Zhongyun::clear_has_gear_control_a1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Zhongyun::clear_gear_control_a1() {
  if (gear_control_a1_ != NULL) gear_control_a1_->Clear();
  clear_has_gear_control_a1();
}
inline const ::apollo::canbus::Gear_control_a1& Zhongyun::_internal_gear_control_a1() const {
  return *gear_control_a1_;
}
inline const ::apollo::canbus::Gear_control_a1& Zhongyun::gear_control_a1() const {
  const ::apollo::canbus::Gear_control_a1* p = gear_control_a1_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.gear_control_a1)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Gear_control_a1*>(
      &::apollo::canbus::_Gear_control_a1_default_instance_);
}
inline ::apollo::canbus::Gear_control_a1* Zhongyun::release_gear_control_a1() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.gear_control_a1)
  clear_has_gear_control_a1();
  ::apollo::canbus::Gear_control_a1* temp = gear_control_a1_;
  gear_control_a1_ = NULL;
  return temp;
}
inline ::apollo::canbus::Gear_control_a1* Zhongyun::mutable_gear_control_a1() {
  set_has_gear_control_a1();
  if (gear_control_a1_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Gear_control_a1>(GetArenaNoVirtual());
    gear_control_a1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.gear_control_a1)
  return gear_control_a1_;
}
inline void Zhongyun::set_allocated_gear_control_a1(::apollo::canbus::Gear_control_a1* gear_control_a1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gear_control_a1_;
  }
  if (gear_control_a1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gear_control_a1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gear_control_a1, submessage_arena);
    }
    set_has_gear_control_a1();
  } else {
    clear_has_gear_control_a1();
  }
  gear_control_a1_ = gear_control_a1;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.gear_control_a1)
}

// optional .apollo.canbus.Torque_control_a3 torque_control_a3 = 2;
inline bool Zhongyun::has_torque_control_a3() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Zhongyun::set_has_torque_control_a3() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Zhongyun::clear_has_torque_control_a3() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Zhongyun::clear_torque_control_a3() {
  if (torque_control_a3_ != NULL) torque_control_a3_->Clear();
  clear_has_torque_control_a3();
}
inline const ::apollo::canbus::Torque_control_a3& Zhongyun::_internal_torque_control_a3() const {
  return *torque_control_a3_;
}
inline const ::apollo::canbus::Torque_control_a3& Zhongyun::torque_control_a3() const {
  const ::apollo::canbus::Torque_control_a3* p = torque_control_a3_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.torque_control_a3)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Torque_control_a3*>(
      &::apollo::canbus::_Torque_control_a3_default_instance_);
}
inline ::apollo::canbus::Torque_control_a3* Zhongyun::release_torque_control_a3() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.torque_control_a3)
  clear_has_torque_control_a3();
  ::apollo::canbus::Torque_control_a3* temp = torque_control_a3_;
  torque_control_a3_ = NULL;
  return temp;
}
inline ::apollo::canbus::Torque_control_a3* Zhongyun::mutable_torque_control_a3() {
  set_has_torque_control_a3();
  if (torque_control_a3_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Torque_control_a3>(GetArenaNoVirtual());
    torque_control_a3_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.torque_control_a3)
  return torque_control_a3_;
}
inline void Zhongyun::set_allocated_torque_control_a3(::apollo::canbus::Torque_control_a3* torque_control_a3) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete torque_control_a3_;
  }
  if (torque_control_a3) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      torque_control_a3 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, torque_control_a3, submessage_arena);
    }
    set_has_torque_control_a3();
  } else {
    clear_has_torque_control_a3();
  }
  torque_control_a3_ = torque_control_a3;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.torque_control_a3)
}

// optional .apollo.canbus.Steering_control_a2 steering_control_a2 = 3;
inline bool Zhongyun::has_steering_control_a2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Zhongyun::set_has_steering_control_a2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Zhongyun::clear_has_steering_control_a2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Zhongyun::clear_steering_control_a2() {
  if (steering_control_a2_ != NULL) steering_control_a2_->Clear();
  clear_has_steering_control_a2();
}
inline const ::apollo::canbus::Steering_control_a2& Zhongyun::_internal_steering_control_a2() const {
  return *steering_control_a2_;
}
inline const ::apollo::canbus::Steering_control_a2& Zhongyun::steering_control_a2() const {
  const ::apollo::canbus::Steering_control_a2* p = steering_control_a2_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.steering_control_a2)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Steering_control_a2*>(
      &::apollo::canbus::_Steering_control_a2_default_instance_);
}
inline ::apollo::canbus::Steering_control_a2* Zhongyun::release_steering_control_a2() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.steering_control_a2)
  clear_has_steering_control_a2();
  ::apollo::canbus::Steering_control_a2* temp = steering_control_a2_;
  steering_control_a2_ = NULL;
  return temp;
}
inline ::apollo::canbus::Steering_control_a2* Zhongyun::mutable_steering_control_a2() {
  set_has_steering_control_a2();
  if (steering_control_a2_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Steering_control_a2>(GetArenaNoVirtual());
    steering_control_a2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.steering_control_a2)
  return steering_control_a2_;
}
inline void Zhongyun::set_allocated_steering_control_a2(::apollo::canbus::Steering_control_a2* steering_control_a2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete steering_control_a2_;
  }
  if (steering_control_a2) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      steering_control_a2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, steering_control_a2, submessage_arena);
    }
    set_has_steering_control_a2();
  } else {
    clear_has_steering_control_a2();
  }
  steering_control_a2_ = steering_control_a2;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.steering_control_a2)
}

// optional .apollo.canbus.Parking_control_a5 parking_control_a5 = 4;
inline bool Zhongyun::has_parking_control_a5() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Zhongyun::set_has_parking_control_a5() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Zhongyun::clear_has_parking_control_a5() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Zhongyun::clear_parking_control_a5() {
  if (parking_control_a5_ != NULL) parking_control_a5_->Clear();
  clear_has_parking_control_a5();
}
inline const ::apollo::canbus::Parking_control_a5& Zhongyun::_internal_parking_control_a5() const {
  return *parking_control_a5_;
}
inline const ::apollo::canbus::Parking_control_a5& Zhongyun::parking_control_a5() const {
  const ::apollo::canbus::Parking_control_a5* p = parking_control_a5_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.parking_control_a5)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Parking_control_a5*>(
      &::apollo::canbus::_Parking_control_a5_default_instance_);
}
inline ::apollo::canbus::Parking_control_a5* Zhongyun::release_parking_control_a5() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.parking_control_a5)
  clear_has_parking_control_a5();
  ::apollo::canbus::Parking_control_a5* temp = parking_control_a5_;
  parking_control_a5_ = NULL;
  return temp;
}
inline ::apollo::canbus::Parking_control_a5* Zhongyun::mutable_parking_control_a5() {
  set_has_parking_control_a5();
  if (parking_control_a5_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Parking_control_a5>(GetArenaNoVirtual());
    parking_control_a5_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.parking_control_a5)
  return parking_control_a5_;
}
inline void Zhongyun::set_allocated_parking_control_a5(::apollo::canbus::Parking_control_a5* parking_control_a5) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parking_control_a5_;
  }
  if (parking_control_a5) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking_control_a5 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking_control_a5, submessage_arena);
    }
    set_has_parking_control_a5();
  } else {
    clear_has_parking_control_a5();
  }
  parking_control_a5_ = parking_control_a5;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.parking_control_a5)
}

// optional .apollo.canbus.Brake_control_a4 brake_control_a4 = 5;
inline bool Zhongyun::has_brake_control_a4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Zhongyun::set_has_brake_control_a4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Zhongyun::clear_has_brake_control_a4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Zhongyun::clear_brake_control_a4() {
  if (brake_control_a4_ != NULL) brake_control_a4_->Clear();
  clear_has_brake_control_a4();
}
inline const ::apollo::canbus::Brake_control_a4& Zhongyun::_internal_brake_control_a4() const {
  return *brake_control_a4_;
}
inline const ::apollo::canbus::Brake_control_a4& Zhongyun::brake_control_a4() const {
  const ::apollo::canbus::Brake_control_a4* p = brake_control_a4_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.brake_control_a4)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Brake_control_a4*>(
      &::apollo::canbus::_Brake_control_a4_default_instance_);
}
inline ::apollo::canbus::Brake_control_a4* Zhongyun::release_brake_control_a4() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.brake_control_a4)
  clear_has_brake_control_a4();
  ::apollo::canbus::Brake_control_a4* temp = brake_control_a4_;
  brake_control_a4_ = NULL;
  return temp;
}
inline ::apollo::canbus::Brake_control_a4* Zhongyun::mutable_brake_control_a4() {
  set_has_brake_control_a4();
  if (brake_control_a4_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Brake_control_a4>(GetArenaNoVirtual());
    brake_control_a4_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.brake_control_a4)
  return brake_control_a4_;
}
inline void Zhongyun::set_allocated_brake_control_a4(::apollo::canbus::Brake_control_a4* brake_control_a4) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete brake_control_a4_;
  }
  if (brake_control_a4) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      brake_control_a4 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, brake_control_a4, submessage_arena);
    }
    set_has_brake_control_a4();
  } else {
    clear_has_brake_control_a4();
  }
  brake_control_a4_ = brake_control_a4;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.brake_control_a4)
}

// optional .apollo.canbus.Enable_state_feedback_c3 enable_state_feedback_c3 = 6;
inline bool Zhongyun::has_enable_state_feedback_c3() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Zhongyun::set_has_enable_state_feedback_c3() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Zhongyun::clear_has_enable_state_feedback_c3() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Zhongyun::clear_enable_state_feedback_c3() {
  if (enable_state_feedback_c3_ != NULL) enable_state_feedback_c3_->Clear();
  clear_has_enable_state_feedback_c3();
}
inline const ::apollo::canbus::Enable_state_feedback_c3& Zhongyun::_internal_enable_state_feedback_c3() const {
  return *enable_state_feedback_c3_;
}
inline const ::apollo::canbus::Enable_state_feedback_c3& Zhongyun::enable_state_feedback_c3() const {
  const ::apollo::canbus::Enable_state_feedback_c3* p = enable_state_feedback_c3_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.enable_state_feedback_c3)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Enable_state_feedback_c3*>(
      &::apollo::canbus::_Enable_state_feedback_c3_default_instance_);
}
inline ::apollo::canbus::Enable_state_feedback_c3* Zhongyun::release_enable_state_feedback_c3() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.enable_state_feedback_c3)
  clear_has_enable_state_feedback_c3();
  ::apollo::canbus::Enable_state_feedback_c3* temp = enable_state_feedback_c3_;
  enable_state_feedback_c3_ = NULL;
  return temp;
}
inline ::apollo::canbus::Enable_state_feedback_c3* Zhongyun::mutable_enable_state_feedback_c3() {
  set_has_enable_state_feedback_c3();
  if (enable_state_feedback_c3_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Enable_state_feedback_c3>(GetArenaNoVirtual());
    enable_state_feedback_c3_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.enable_state_feedback_c3)
  return enable_state_feedback_c3_;
}
inline void Zhongyun::set_allocated_enable_state_feedback_c3(::apollo::canbus::Enable_state_feedback_c3* enable_state_feedback_c3) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete enable_state_feedback_c3_;
  }
  if (enable_state_feedback_c3) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      enable_state_feedback_c3 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, enable_state_feedback_c3, submessage_arena);
    }
    set_has_enable_state_feedback_c3();
  } else {
    clear_has_enable_state_feedback_c3();
  }
  enable_state_feedback_c3_ = enable_state_feedback_c3;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.enable_state_feedback_c3)
}

// optional .apollo.canbus.Vehicle_state_feedback_c1 vehicle_state_feedback_c1 = 7;
inline bool Zhongyun::has_vehicle_state_feedback_c1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Zhongyun::set_has_vehicle_state_feedback_c1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Zhongyun::clear_has_vehicle_state_feedback_c1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Zhongyun::clear_vehicle_state_feedback_c1() {
  if (vehicle_state_feedback_c1_ != NULL) vehicle_state_feedback_c1_->Clear();
  clear_has_vehicle_state_feedback_c1();
}
inline const ::apollo::canbus::Vehicle_state_feedback_c1& Zhongyun::_internal_vehicle_state_feedback_c1() const {
  return *vehicle_state_feedback_c1_;
}
inline const ::apollo::canbus::Vehicle_state_feedback_c1& Zhongyun::vehicle_state_feedback_c1() const {
  const ::apollo::canbus::Vehicle_state_feedback_c1* p = vehicle_state_feedback_c1_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Vehicle_state_feedback_c1*>(
      &::apollo::canbus::_Vehicle_state_feedback_c1_default_instance_);
}
inline ::apollo::canbus::Vehicle_state_feedback_c1* Zhongyun::release_vehicle_state_feedback_c1() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
  clear_has_vehicle_state_feedback_c1();
  ::apollo::canbus::Vehicle_state_feedback_c1* temp = vehicle_state_feedback_c1_;
  vehicle_state_feedback_c1_ = NULL;
  return temp;
}
inline ::apollo::canbus::Vehicle_state_feedback_c1* Zhongyun::mutable_vehicle_state_feedback_c1() {
  set_has_vehicle_state_feedback_c1();
  if (vehicle_state_feedback_c1_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_c1>(GetArenaNoVirtual());
    vehicle_state_feedback_c1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
  return vehicle_state_feedback_c1_;
}
inline void Zhongyun::set_allocated_vehicle_state_feedback_c1(::apollo::canbus::Vehicle_state_feedback_c1* vehicle_state_feedback_c1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_state_feedback_c1_;
  }
  if (vehicle_state_feedback_c1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_state_feedback_c1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_state_feedback_c1, submessage_arena);
    }
    set_has_vehicle_state_feedback_c1();
  } else {
    clear_has_vehicle_state_feedback_c1();
  }
  vehicle_state_feedback_c1_ = vehicle_state_feedback_c1;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.vehicle_state_feedback_c1)
}

// optional .apollo.canbus.Error_state_e1 error_state_e1 = 8;
inline bool Zhongyun::has_error_state_e1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Zhongyun::set_has_error_state_e1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Zhongyun::clear_has_error_state_e1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Zhongyun::clear_error_state_e1() {
  if (error_state_e1_ != NULL) error_state_e1_->Clear();
  clear_has_error_state_e1();
}
inline const ::apollo::canbus::Error_state_e1& Zhongyun::_internal_error_state_e1() const {
  return *error_state_e1_;
}
inline const ::apollo::canbus::Error_state_e1& Zhongyun::error_state_e1() const {
  const ::apollo::canbus::Error_state_e1* p = error_state_e1_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.error_state_e1)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Error_state_e1*>(
      &::apollo::canbus::_Error_state_e1_default_instance_);
}
inline ::apollo::canbus::Error_state_e1* Zhongyun::release_error_state_e1() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.error_state_e1)
  clear_has_error_state_e1();
  ::apollo::canbus::Error_state_e1* temp = error_state_e1_;
  error_state_e1_ = NULL;
  return temp;
}
inline ::apollo::canbus::Error_state_e1* Zhongyun::mutable_error_state_e1() {
  set_has_error_state_e1();
  if (error_state_e1_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Error_state_e1>(GetArenaNoVirtual());
    error_state_e1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.error_state_e1)
  return error_state_e1_;
}
inline void Zhongyun::set_allocated_error_state_e1(::apollo::canbus::Error_state_e1* error_state_e1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_state_e1_;
  }
  if (error_state_e1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error_state_e1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error_state_e1, submessage_arena);
    }
    set_has_error_state_e1();
  } else {
    clear_has_error_state_e1();
  }
  error_state_e1_ = error_state_e1;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.error_state_e1)
}

// optional .apollo.canbus.Vehicle_state_feedback_2_c4 vehicle_state_feedback_2_c4 = 9;
inline bool Zhongyun::has_vehicle_state_feedback_2_c4() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Zhongyun::set_has_vehicle_state_feedback_2_c4() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Zhongyun::clear_has_vehicle_state_feedback_2_c4() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Zhongyun::clear_vehicle_state_feedback_2_c4() {
  if (vehicle_state_feedback_2_c4_ != NULL) vehicle_state_feedback_2_c4_->Clear();
  clear_has_vehicle_state_feedback_2_c4();
}
inline const ::apollo::canbus::Vehicle_state_feedback_2_c4& Zhongyun::_internal_vehicle_state_feedback_2_c4() const {
  return *vehicle_state_feedback_2_c4_;
}
inline const ::apollo::canbus::Vehicle_state_feedback_2_c4& Zhongyun::vehicle_state_feedback_2_c4() const {
  const ::apollo::canbus::Vehicle_state_feedback_2_c4* p = vehicle_state_feedback_2_c4_;
  // @@protoc_insertion_point(field_get:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::canbus::Vehicle_state_feedback_2_c4*>(
      &::apollo::canbus::_Vehicle_state_feedback_2_c4_default_instance_);
}
inline ::apollo::canbus::Vehicle_state_feedback_2_c4* Zhongyun::release_vehicle_state_feedback_2_c4() {
  // @@protoc_insertion_point(field_release:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
  clear_has_vehicle_state_feedback_2_c4();
  ::apollo::canbus::Vehicle_state_feedback_2_c4* temp = vehicle_state_feedback_2_c4_;
  vehicle_state_feedback_2_c4_ = NULL;
  return temp;
}
inline ::apollo::canbus::Vehicle_state_feedback_2_c4* Zhongyun::mutable_vehicle_state_feedback_2_c4() {
  set_has_vehicle_state_feedback_2_c4();
  if (vehicle_state_feedback_2_c4_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::canbus::Vehicle_state_feedback_2_c4>(GetArenaNoVirtual());
    vehicle_state_feedback_2_c4_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
  return vehicle_state_feedback_2_c4_;
}
inline void Zhongyun::set_allocated_vehicle_state_feedback_2_c4(::apollo::canbus::Vehicle_state_feedback_2_c4* vehicle_state_feedback_2_c4) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_state_feedback_2_c4_;
  }
  if (vehicle_state_feedback_2_c4) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_state_feedback_2_c4 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_state_feedback_2_c4, submessage_arena);
    }
    set_has_vehicle_state_feedback_2_c4();
  } else {
    clear_has_vehicle_state_feedback_2_c4();
  }
  vehicle_state_feedback_2_c4_ = vehicle_state_feedback_2_c4;
  // @@protoc_insertion_point(field_set_allocated:apollo.canbus.Zhongyun.vehicle_state_feedback_2_c4)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace canbus
}  // namespace apollo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::canbus::Gear_control_a1_Gear_state_targetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Gear_control_a1_Gear_state_targetType>() {
  return ::apollo::canbus::Gear_control_a1_Gear_state_targetType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Gear_control_a1_Gear_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Gear_control_a1_Gear_enable_controlType>() {
  return ::apollo::canbus::Gear_control_a1_Gear_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Torque_control_a3_Driven_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Torque_control_a3_Driven_enable_controlType>() {
  return ::apollo::canbus::Torque_control_a3_Driven_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Steering_control_a2_Steering_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Steering_control_a2_Steering_enable_controlType>() {
  return ::apollo::canbus::Steering_control_a2_Steering_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Parking_control_a5_Parking_targetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Parking_control_a5_Parking_targetType>() {
  return ::apollo::canbus::Parking_control_a5_Parking_targetType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Parking_control_a5_Parking_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Parking_control_a5_Parking_enable_controlType>() {
  return ::apollo::canbus::Parking_control_a5_Parking_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Brake_control_a4_Brake_enable_controlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Brake_control_a4_Brake_enable_controlType>() {
  return ::apollo::canbus::Brake_control_a4_Brake_enable_controlType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Parking_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Steering_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Gear_enable_actualType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Driven_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType>() {
  return ::apollo::canbus::Enable_state_feedback_c3_Brake_enable_stateType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType>() {
  return ::apollo::canbus::Vehicle_state_feedback_c1_Parking_actualType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType>() {
  return ::apollo::canbus::Vehicle_state_feedback_c1_Gear_state_actualType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Brake_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Brake_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Brake_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Driven_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Driven_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Driven_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Steering_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Steering_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Steering_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Parking_error_codeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Parking_error_codeType>() {
  return ::apollo::canbus::Error_state_e1_Parking_error_codeType_descriptor();
}
template <> struct is_proto_enum< ::apollo::canbus::Error_state_e1_Gear_error_msgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::canbus::Error_state_e1_Gear_error_msgType>() {
  return ::apollo::canbus::Error_state_e1_Gear_error_msgType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_modules_2fcanbus_2fproto_2fzhongyun_2eproto
