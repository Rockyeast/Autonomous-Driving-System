// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/learning_data.proto

#ifndef PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2flearning_5fdata_2eproto
#define PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2flearning_5fdata_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "modules/canbus/proto/chassis.pb.h"
#include "modules/common/proto/geometry.pb.h"
#include "modules/common/proto/header.pb.h"
#include "modules/common/proto/pnc_point.pb.h"
#include "modules/map/proto/map_lane.pb.h"
#include "modules/perception/proto/perception_obstacle.pb.h"
#include "modules/prediction/proto/feature.pb.h"
#include "modules/prediction/proto/prediction_obstacle.pb.h"
#include "modules/perception/proto/traffic_light_detection.pb.h"
#include "modules/routing/proto/routing.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto 

namespace protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto
namespace apollo {
namespace planning {
class ADCTrajectoryPoint;
class ADCTrajectoryPointDefaultTypeInternal;
extern ADCTrajectoryPointDefaultTypeInternal _ADCTrajectoryPoint_default_instance_;
class ChassisFeature;
class ChassisFeatureDefaultTypeInternal;
extern ChassisFeatureDefaultTypeInternal _ChassisFeature_default_instance_;
class CommonPathPointFeature;
class CommonPathPointFeatureDefaultTypeInternal;
extern CommonPathPointFeatureDefaultTypeInternal _CommonPathPointFeature_default_instance_;
class CommonTrajectoryPointFeature;
class CommonTrajectoryPointFeatureDefaultTypeInternal;
extern CommonTrajectoryPointFeatureDefaultTypeInternal _CommonTrajectoryPointFeature_default_instance_;
class LearningData;
class LearningDataDefaultTypeInternal;
extern LearningDataDefaultTypeInternal _LearningData_default_instance_;
class LearningDataFrame;
class LearningDataFrameDefaultTypeInternal;
extern LearningDataFrameDefaultTypeInternal _LearningDataFrame_default_instance_;
class LearningOutput;
class LearningOutputDefaultTypeInternal;
extern LearningOutputDefaultTypeInternal _LearningOutput_default_instance_;
class LocalizationFeature;
class LocalizationFeatureDefaultTypeInternal;
extern LocalizationFeatureDefaultTypeInternal _LocalizationFeature_default_instance_;
class ObstacleFeature;
class ObstacleFeatureDefaultTypeInternal;
extern ObstacleFeatureDefaultTypeInternal _ObstacleFeature_default_instance_;
class ObstacleTrajectoryFeature;
class ObstacleTrajectoryFeatureDefaultTypeInternal;
extern ObstacleTrajectoryFeatureDefaultTypeInternal _ObstacleTrajectoryFeature_default_instance_;
class OverlapFeature;
class OverlapFeatureDefaultTypeInternal;
extern OverlapFeatureDefaultTypeInternal _OverlapFeature_default_instance_;
class PerceptionObstacleFeature;
class PerceptionObstacleFeatureDefaultTypeInternal;
extern PerceptionObstacleFeatureDefaultTypeInternal _PerceptionObstacleFeature_default_instance_;
class PlanningLearningData;
class PlanningLearningDataDefaultTypeInternal;
extern PlanningLearningDataDefaultTypeInternal _PlanningLearningData_default_instance_;
class PlanningTag;
class PlanningTagDefaultTypeInternal;
extern PlanningTagDefaultTypeInternal _PlanningTag_default_instance_;
class PredictionObstacleFeature;
class PredictionObstacleFeatureDefaultTypeInternal;
extern PredictionObstacleFeatureDefaultTypeInternal _PredictionObstacleFeature_default_instance_;
class PredictionTrajectoryFeature;
class PredictionTrajectoryFeatureDefaultTypeInternal;
extern PredictionTrajectoryFeatureDefaultTypeInternal _PredictionTrajectoryFeature_default_instance_;
class RoutingFeature;
class RoutingFeatureDefaultTypeInternal;
extern RoutingFeatureDefaultTypeInternal _RoutingFeature_default_instance_;
class RoutingResponseFeature;
class RoutingResponseFeatureDefaultTypeInternal;
extern RoutingResponseFeatureDefaultTypeInternal _RoutingResponseFeature_default_instance_;
class TrafficLightDetectionFeature;
class TrafficLightDetectionFeatureDefaultTypeInternal;
extern TrafficLightDetectionFeatureDefaultTypeInternal _TrafficLightDetectionFeature_default_instance_;
class TrafficLightFeature;
class TrafficLightFeatureDefaultTypeInternal;
extern TrafficLightFeatureDefaultTypeInternal _TrafficLightFeature_default_instance_;
class TrajectoryPointFeature;
class TrajectoryPointFeatureDefaultTypeInternal;
extern TrajectoryPointFeatureDefaultTypeInternal _TrajectoryPointFeature_default_instance_;
}  // namespace planning
}  // namespace apollo
namespace google {
namespace protobuf {
template<> ::apollo::planning::ADCTrajectoryPoint* Arena::CreateMaybeMessage<::apollo::planning::ADCTrajectoryPoint>(Arena*);
template<> ::apollo::planning::ChassisFeature* Arena::CreateMaybeMessage<::apollo::planning::ChassisFeature>(Arena*);
template<> ::apollo::planning::CommonPathPointFeature* Arena::CreateMaybeMessage<::apollo::planning::CommonPathPointFeature>(Arena*);
template<> ::apollo::planning::CommonTrajectoryPointFeature* Arena::CreateMaybeMessage<::apollo::planning::CommonTrajectoryPointFeature>(Arena*);
template<> ::apollo::planning::LearningData* Arena::CreateMaybeMessage<::apollo::planning::LearningData>(Arena*);
template<> ::apollo::planning::LearningDataFrame* Arena::CreateMaybeMessage<::apollo::planning::LearningDataFrame>(Arena*);
template<> ::apollo::planning::LearningOutput* Arena::CreateMaybeMessage<::apollo::planning::LearningOutput>(Arena*);
template<> ::apollo::planning::LocalizationFeature* Arena::CreateMaybeMessage<::apollo::planning::LocalizationFeature>(Arena*);
template<> ::apollo::planning::ObstacleFeature* Arena::CreateMaybeMessage<::apollo::planning::ObstacleFeature>(Arena*);
template<> ::apollo::planning::ObstacleTrajectoryFeature* Arena::CreateMaybeMessage<::apollo::planning::ObstacleTrajectoryFeature>(Arena*);
template<> ::apollo::planning::OverlapFeature* Arena::CreateMaybeMessage<::apollo::planning::OverlapFeature>(Arena*);
template<> ::apollo::planning::PerceptionObstacleFeature* Arena::CreateMaybeMessage<::apollo::planning::PerceptionObstacleFeature>(Arena*);
template<> ::apollo::planning::PlanningLearningData* Arena::CreateMaybeMessage<::apollo::planning::PlanningLearningData>(Arena*);
template<> ::apollo::planning::PlanningTag* Arena::CreateMaybeMessage<::apollo::planning::PlanningTag>(Arena*);
template<> ::apollo::planning::PredictionObstacleFeature* Arena::CreateMaybeMessage<::apollo::planning::PredictionObstacleFeature>(Arena*);
template<> ::apollo::planning::PredictionTrajectoryFeature* Arena::CreateMaybeMessage<::apollo::planning::PredictionTrajectoryFeature>(Arena*);
template<> ::apollo::planning::RoutingFeature* Arena::CreateMaybeMessage<::apollo::planning::RoutingFeature>(Arena*);
template<> ::apollo::planning::RoutingResponseFeature* Arena::CreateMaybeMessage<::apollo::planning::RoutingResponseFeature>(Arena*);
template<> ::apollo::planning::TrafficLightDetectionFeature* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightDetectionFeature>(Arena*);
template<> ::apollo::planning::TrafficLightFeature* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightFeature>(Arena*);
template<> ::apollo::planning::TrajectoryPointFeature* Arena::CreateMaybeMessage<::apollo::planning::TrajectoryPointFeature>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace apollo {
namespace planning {

// ===================================================================

class OverlapFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.OverlapFeature) */ {
 public:
  OverlapFeature();
  virtual ~OverlapFeature();

  OverlapFeature(const OverlapFeature& from);

  inline OverlapFeature& operator=(const OverlapFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverlapFeature(OverlapFeature&& from) noexcept
    : OverlapFeature() {
    *this = ::std::move(from);
  }

  inline OverlapFeature& operator=(OverlapFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OverlapFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverlapFeature* internal_default_instance() {
    return reinterpret_cast<const OverlapFeature*>(
               &_OverlapFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(OverlapFeature* other);
  friend void swap(OverlapFeature& a, OverlapFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverlapFeature* New() const final {
    return CreateMaybeMessage<OverlapFeature>(NULL);
  }

  OverlapFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OverlapFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OverlapFeature& from);
  void MergeFrom(const OverlapFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverlapFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional double distance = 2;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.OverlapFeature)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_distance();
  void clear_has_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  double distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningTag) */ {
 public:
  PlanningTag();
  virtual ~PlanningTag();

  PlanningTag(const PlanningTag& from);

  inline PlanningTag& operator=(const PlanningTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningTag(PlanningTag&& from) noexcept
    : PlanningTag() {
    *this = ::std::move(from);
  }

  inline PlanningTag& operator=(PlanningTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningTag* internal_default_instance() {
    return reinterpret_cast<const PlanningTag*>(
               &_PlanningTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PlanningTag* other);
  friend void swap(PlanningTag& a, PlanningTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningTag* New() const final {
    return CreateMaybeMessage<PlanningTag>(NULL);
  }

  PlanningTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanningTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanningTag& from);
  void MergeFrom(const PlanningTag& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.OverlapFeature clear_area = 2;
  bool has_clear_area() const;
  void clear_clear_area();
  static const int kClearAreaFieldNumber = 2;
  private:
  const ::apollo::planning::OverlapFeature& _internal_clear_area() const;
  public:
  const ::apollo::planning::OverlapFeature& clear_area() const;
  ::apollo::planning::OverlapFeature* release_clear_area();
  ::apollo::planning::OverlapFeature* mutable_clear_area();
  void set_allocated_clear_area(::apollo::planning::OverlapFeature* clear_area);

  // optional .apollo.planning.OverlapFeature crosswalk = 3;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 3;
  private:
  const ::apollo::planning::OverlapFeature& _internal_crosswalk() const;
  public:
  const ::apollo::planning::OverlapFeature& crosswalk() const;
  ::apollo::planning::OverlapFeature* release_crosswalk();
  ::apollo::planning::OverlapFeature* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::OverlapFeature* crosswalk);

  // optional .apollo.planning.OverlapFeature pnc_junction = 4;
  bool has_pnc_junction() const;
  void clear_pnc_junction();
  static const int kPncJunctionFieldNumber = 4;
  private:
  const ::apollo::planning::OverlapFeature& _internal_pnc_junction() const;
  public:
  const ::apollo::planning::OverlapFeature& pnc_junction() const;
  ::apollo::planning::OverlapFeature* release_pnc_junction();
  ::apollo::planning::OverlapFeature* mutable_pnc_junction();
  void set_allocated_pnc_junction(::apollo::planning::OverlapFeature* pnc_junction);

  // optional .apollo.planning.OverlapFeature signal = 5;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 5;
  private:
  const ::apollo::planning::OverlapFeature& _internal_signal() const;
  public:
  const ::apollo::planning::OverlapFeature& signal() const;
  ::apollo::planning::OverlapFeature* release_signal();
  ::apollo::planning::OverlapFeature* mutable_signal();
  void set_allocated_signal(::apollo::planning::OverlapFeature* signal);

  // optional .apollo.planning.OverlapFeature stop_sign = 6;
  bool has_stop_sign() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 6;
  private:
  const ::apollo::planning::OverlapFeature& _internal_stop_sign() const;
  public:
  const ::apollo::planning::OverlapFeature& stop_sign() const;
  ::apollo::planning::OverlapFeature* release_stop_sign();
  ::apollo::planning::OverlapFeature* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::OverlapFeature* stop_sign);

  // optional .apollo.planning.OverlapFeature yield_sign = 7;
  bool has_yield_sign() const;
  void clear_yield_sign();
  static const int kYieldSignFieldNumber = 7;
  private:
  const ::apollo::planning::OverlapFeature& _internal_yield_sign() const;
  public:
  const ::apollo::planning::OverlapFeature& yield_sign() const;
  ::apollo::planning::OverlapFeature* release_yield_sign();
  ::apollo::planning::OverlapFeature* mutable_yield_sign();
  void set_allocated_yield_sign(::apollo::planning::OverlapFeature* yield_sign);

  // optional .apollo.hdmap.Lane.LaneTurn lane_turn = 1;
  bool has_lane_turn() const;
  void clear_lane_turn();
  static const int kLaneTurnFieldNumber = 1;
  ::apollo::hdmap::Lane_LaneTurn lane_turn() const;
  void set_lane_turn(::apollo::hdmap::Lane_LaneTurn value);

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningTag)
 private:
  void set_has_lane_turn();
  void clear_has_lane_turn();
  void set_has_clear_area();
  void clear_has_clear_area();
  void set_has_crosswalk();
  void clear_has_crosswalk();
  void set_has_pnc_junction();
  void clear_has_pnc_junction();
  void set_has_signal();
  void clear_has_signal();
  void set_has_stop_sign();
  void clear_has_stop_sign();
  void set_has_yield_sign();
  void clear_has_yield_sign();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::planning::OverlapFeature* clear_area_;
  ::apollo::planning::OverlapFeature* crosswalk_;
  ::apollo::planning::OverlapFeature* pnc_junction_;
  ::apollo::planning::OverlapFeature* signal_;
  ::apollo::planning::OverlapFeature* stop_sign_;
  ::apollo::planning::OverlapFeature* yield_sign_;
  int lane_turn_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChassisFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChassisFeature) */ {
 public:
  ChassisFeature();
  virtual ~ChassisFeature();

  ChassisFeature(const ChassisFeature& from);

  inline ChassisFeature& operator=(const ChassisFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChassisFeature(ChassisFeature&& from) noexcept
    : ChassisFeature() {
    *this = ::std::move(from);
  }

  inline ChassisFeature& operator=(ChassisFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChassisFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChassisFeature* internal_default_instance() {
    return reinterpret_cast<const ChassisFeature*>(
               &_ChassisFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ChassisFeature* other);
  friend void swap(ChassisFeature& a, ChassisFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChassisFeature* New() const final {
    return CreateMaybeMessage<ChassisFeature>(NULL);
  }

  ChassisFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChassisFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChassisFeature& from);
  void MergeFrom(const ChassisFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChassisFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // optional float speed_mps = 2;
  bool has_speed_mps() const;
  void clear_speed_mps();
  static const int kSpeedMpsFieldNumber = 2;
  float speed_mps() const;
  void set_speed_mps(float value);

  // optional float throttle_percentage = 3;
  bool has_throttle_percentage() const;
  void clear_throttle_percentage();
  static const int kThrottlePercentageFieldNumber = 3;
  float throttle_percentage() const;
  void set_throttle_percentage(float value);

  // optional float brake_percentage = 4;
  bool has_brake_percentage() const;
  void clear_brake_percentage();
  static const int kBrakePercentageFieldNumber = 4;
  float brake_percentage() const;
  void set_brake_percentage(float value);

  // optional float steering_percentage = 5;
  bool has_steering_percentage() const;
  void clear_steering_percentage();
  static const int kSteeringPercentageFieldNumber = 5;
  float steering_percentage() const;
  void set_steering_percentage(float value);

  // optional .apollo.canbus.Chassis.GearPosition gear_location = 6;
  bool has_gear_location() const;
  void clear_gear_location();
  static const int kGearLocationFieldNumber = 6;
  ::apollo::canbus::Chassis_GearPosition gear_location() const;
  void set_gear_location(::apollo::canbus::Chassis_GearPosition value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ChassisFeature)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();
  void set_has_speed_mps();
  void clear_has_speed_mps();
  void set_has_throttle_percentage();
  void clear_has_throttle_percentage();
  void set_has_brake_percentage();
  void clear_has_brake_percentage();
  void set_has_steering_percentage();
  void clear_has_steering_percentage();
  void set_has_gear_location();
  void clear_has_gear_location();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double message_timestamp_sec_;
  float speed_mps_;
  float throttle_percentage_;
  float brake_percentage_;
  float steering_percentage_;
  int gear_location_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalizationFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LocalizationFeature) */ {
 public:
  LocalizationFeature();
  virtual ~LocalizationFeature();

  LocalizationFeature(const LocalizationFeature& from);

  inline LocalizationFeature& operator=(const LocalizationFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalizationFeature(LocalizationFeature&& from) noexcept
    : LocalizationFeature() {
    *this = ::std::move(from);
  }

  inline LocalizationFeature& operator=(LocalizationFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalizationFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalizationFeature* internal_default_instance() {
    return reinterpret_cast<const LocalizationFeature*>(
               &_LocalizationFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LocalizationFeature* other);
  friend void swap(LocalizationFeature& a, LocalizationFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalizationFeature* New() const final {
    return CreateMaybeMessage<LocalizationFeature>(NULL);
  }

  LocalizationFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalizationFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocalizationFeature& from);
  void MergeFrom(const LocalizationFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalizationFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.common.PointENU position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  private:
  const ::apollo::common::PointENU& _internal_position() const;
  public:
  const ::apollo::common::PointENU& position() const;
  ::apollo::common::PointENU* release_position();
  ::apollo::common::PointENU* mutable_position();
  void set_allocated_position(::apollo::common::PointENU* position);

  // optional .apollo.common.Point3D linear_velocity = 4;
  bool has_linear_velocity() const;
  void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 4;
  private:
  const ::apollo::common::Point3D& _internal_linear_velocity() const;
  public:
  const ::apollo::common::Point3D& linear_velocity() const;
  ::apollo::common::Point3D* release_linear_velocity();
  ::apollo::common::Point3D* mutable_linear_velocity();
  void set_allocated_linear_velocity(::apollo::common::Point3D* linear_velocity);

  // optional .apollo.common.Point3D linear_acceleration = 5;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 5;
  private:
  const ::apollo::common::Point3D& _internal_linear_acceleration() const;
  public:
  const ::apollo::common::Point3D& linear_acceleration() const;
  ::apollo::common::Point3D* release_linear_acceleration();
  ::apollo::common::Point3D* mutable_linear_acceleration();
  void set_allocated_linear_acceleration(::apollo::common::Point3D* linear_acceleration);

  // optional .apollo.common.Point3D angular_velocity = 6;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 6;
  private:
  const ::apollo::common::Point3D& _internal_angular_velocity() const;
  public:
  const ::apollo::common::Point3D& angular_velocity() const;
  ::apollo::common::Point3D* release_angular_velocity();
  ::apollo::common::Point3D* mutable_angular_velocity();
  void set_allocated_angular_velocity(::apollo::common::Point3D* angular_velocity);

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // optional double heading = 3;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  double heading() const;
  void set_heading(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.LocalizationFeature)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();
  void set_has_position();
  void clear_has_position();
  void set_has_heading();
  void clear_has_heading();
  void set_has_linear_velocity();
  void clear_has_linear_velocity();
  void set_has_linear_acceleration();
  void clear_has_linear_acceleration();
  void set_has_angular_velocity();
  void clear_has_angular_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::common::PointENU* position_;
  ::apollo::common::Point3D* linear_velocity_;
  ::apollo::common::Point3D* linear_acceleration_;
  ::apollo::common::Point3D* angular_velocity_;
  double message_timestamp_sec_;
  double heading_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommonPathPointFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CommonPathPointFeature) */ {
 public:
  CommonPathPointFeature();
  virtual ~CommonPathPointFeature();

  CommonPathPointFeature(const CommonPathPointFeature& from);

  inline CommonPathPointFeature& operator=(const CommonPathPointFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommonPathPointFeature(CommonPathPointFeature&& from) noexcept
    : CommonPathPointFeature() {
    *this = ::std::move(from);
  }

  inline CommonPathPointFeature& operator=(CommonPathPointFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonPathPointFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonPathPointFeature* internal_default_instance() {
    return reinterpret_cast<const CommonPathPointFeature*>(
               &_CommonPathPointFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CommonPathPointFeature* other);
  friend void swap(CommonPathPointFeature& a, CommonPathPointFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonPathPointFeature* New() const final {
    return CreateMaybeMessage<CommonPathPointFeature>(NULL);
  }

  CommonPathPointFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommonPathPointFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommonPathPointFeature& from);
  void MergeFrom(const CommonPathPointFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonPathPointFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lane_id = 6;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 6;
  const ::std::string& lane_id() const;
  void set_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void set_lane_id(::std::string&& value);
  #endif
  void set_lane_id(const char* value);
  void set_lane_id(const char* value, size_t size);
  ::std::string* mutable_lane_id();
  ::std::string* release_lane_id();
  void set_allocated_lane_id(::std::string* lane_id);

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // optional double theta = 4;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 4;
  double theta() const;
  void set_theta(double value);

  // optional double s = 5;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 5;
  double s() const;
  void set_s(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.CommonPathPointFeature)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_theta();
  void clear_has_theta();
  void set_has_s();
  void clear_has_s();
  void set_has_lane_id();
  void clear_has_lane_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lane_id_;
  double x_;
  double y_;
  double z_;
  double theta_;
  double s_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommonTrajectoryPointFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CommonTrajectoryPointFeature) */ {
 public:
  CommonTrajectoryPointFeature();
  virtual ~CommonTrajectoryPointFeature();

  CommonTrajectoryPointFeature(const CommonTrajectoryPointFeature& from);

  inline CommonTrajectoryPointFeature& operator=(const CommonTrajectoryPointFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommonTrajectoryPointFeature(CommonTrajectoryPointFeature&& from) noexcept
    : CommonTrajectoryPointFeature() {
    *this = ::std::move(from);
  }

  inline CommonTrajectoryPointFeature& operator=(CommonTrajectoryPointFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonTrajectoryPointFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonTrajectoryPointFeature* internal_default_instance() {
    return reinterpret_cast<const CommonTrajectoryPointFeature*>(
               &_CommonTrajectoryPointFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CommonTrajectoryPointFeature* other);
  friend void swap(CommonTrajectoryPointFeature& a, CommonTrajectoryPointFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonTrajectoryPointFeature* New() const final {
    return CreateMaybeMessage<CommonTrajectoryPointFeature>(NULL);
  }

  CommonTrajectoryPointFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommonTrajectoryPointFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommonTrajectoryPointFeature& from);
  void MergeFrom(const CommonTrajectoryPointFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonTrajectoryPointFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.CommonPathPointFeature path_point = 1;
  bool has_path_point() const;
  void clear_path_point();
  static const int kPathPointFieldNumber = 1;
  private:
  const ::apollo::planning::CommonPathPointFeature& _internal_path_point() const;
  public:
  const ::apollo::planning::CommonPathPointFeature& path_point() const;
  ::apollo::planning::CommonPathPointFeature* release_path_point();
  ::apollo::planning::CommonPathPointFeature* mutable_path_point();
  void set_allocated_path_point(::apollo::planning::CommonPathPointFeature* path_point);

  // optional .apollo.common.GaussianInfo gaussian_info = 5;
  bool has_gaussian_info() const;
  void clear_gaussian_info();
  static const int kGaussianInfoFieldNumber = 5;
  private:
  const ::apollo::common::GaussianInfo& _internal_gaussian_info() const;
  public:
  const ::apollo::common::GaussianInfo& gaussian_info() const;
  ::apollo::common::GaussianInfo* release_gaussian_info();
  ::apollo::common::GaussianInfo* mutable_gaussian_info();
  void set_allocated_gaussian_info(::apollo::common::GaussianInfo* gaussian_info);

  // optional double v = 2;
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 2;
  double v() const;
  void set_v(double value);

  // optional double a = 3;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 3;
  double a() const;
  void set_a(double value);

  // optional double relative_time = 4;
  bool has_relative_time() const;
  void clear_relative_time();
  static const int kRelativeTimeFieldNumber = 4;
  double relative_time() const;
  void set_relative_time(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.CommonTrajectoryPointFeature)
 private:
  void set_has_path_point();
  void clear_has_path_point();
  void set_has_v();
  void clear_has_v();
  void set_has_a();
  void clear_has_a();
  void set_has_relative_time();
  void clear_has_relative_time();
  void set_has_gaussian_info();
  void clear_has_gaussian_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::planning::CommonPathPointFeature* path_point_;
  ::apollo::common::GaussianInfo* gaussian_info_;
  double v_;
  double a_;
  double relative_time_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrajectoryPointFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrajectoryPointFeature) */ {
 public:
  TrajectoryPointFeature();
  virtual ~TrajectoryPointFeature();

  TrajectoryPointFeature(const TrajectoryPointFeature& from);

  inline TrajectoryPointFeature& operator=(const TrajectoryPointFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryPointFeature(TrajectoryPointFeature&& from) noexcept
    : TrajectoryPointFeature() {
    *this = ::std::move(from);
  }

  inline TrajectoryPointFeature& operator=(TrajectoryPointFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryPointFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPointFeature* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPointFeature*>(
               &_TrajectoryPointFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TrajectoryPointFeature* other);
  friend void swap(TrajectoryPointFeature& a, TrajectoryPointFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPointFeature* New() const final {
    return CreateMaybeMessage<TrajectoryPointFeature>(NULL);
  }

  TrajectoryPointFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryPointFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrajectoryPointFeature& from);
  void MergeFrom(const TrajectoryPointFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryPointFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 2;
  bool has_trajectory_point() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 2;
  private:
  const ::apollo::planning::CommonTrajectoryPointFeature& _internal_trajectory_point() const;
  public:
  const ::apollo::planning::CommonTrajectoryPointFeature& trajectory_point() const;
  ::apollo::planning::CommonTrajectoryPointFeature* release_trajectory_point();
  ::apollo::planning::CommonTrajectoryPointFeature* mutable_trajectory_point();
  void set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.TrajectoryPointFeature)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_trajectory_point();
  void clear_has_trajectory_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point_;
  double timestamp_sec_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PerceptionObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PerceptionObstacleFeature) */ {
 public:
  PerceptionObstacleFeature();
  virtual ~PerceptionObstacleFeature();

  PerceptionObstacleFeature(const PerceptionObstacleFeature& from);

  inline PerceptionObstacleFeature& operator=(const PerceptionObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionObstacleFeature(PerceptionObstacleFeature&& from) noexcept
    : PerceptionObstacleFeature() {
    *this = ::std::move(from);
  }

  inline PerceptionObstacleFeature& operator=(PerceptionObstacleFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionObstacleFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const PerceptionObstacleFeature*>(
               &_PerceptionObstacleFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PerceptionObstacleFeature* other);
  friend void swap(PerceptionObstacleFeature& a, PerceptionObstacleFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionObstacleFeature* New() const final {
    return CreateMaybeMessage<PerceptionObstacleFeature>(NULL);
  }

  PerceptionObstacleFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PerceptionObstacleFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PerceptionObstacleFeature& from);
  void MergeFrom(const PerceptionObstacleFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerceptionObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.common.Point3D polygon_point = 6;
  int polygon_point_size() const;
  void clear_polygon_point();
  static const int kPolygonPointFieldNumber = 6;
  ::apollo::common::Point3D* mutable_polygon_point(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::common::Point3D >*
      mutable_polygon_point();
  const ::apollo::common::Point3D& polygon_point(int index) const;
  ::apollo::common::Point3D* add_polygon_point();
  const ::google::protobuf::RepeatedPtrField< ::apollo::common::Point3D >&
      polygon_point() const;

  // optional .apollo.common.Point3D position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  private:
  const ::apollo::common::Point3D& _internal_position() const;
  public:
  const ::apollo::common::Point3D& position() const;
  ::apollo::common::Point3D* release_position();
  ::apollo::common::Point3D* mutable_position();
  void set_allocated_position(::apollo::common::Point3D* position);

  // optional .apollo.common.Point3D velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  private:
  const ::apollo::common::Point3D& _internal_velocity() const;
  public:
  const ::apollo::common::Point3D& velocity() const;
  ::apollo::common::Point3D* release_velocity();
  ::apollo::common::Point3D* mutable_velocity();
  void set_allocated_velocity(::apollo::common::Point3D* velocity);

  // optional .apollo.common.Point3D acceleration = 5;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  private:
  const ::apollo::common::Point3D& _internal_acceleration() const;
  public:
  const ::apollo::common::Point3D& acceleration() const;
  ::apollo::common::Point3D* release_acceleration();
  ::apollo::common::Point3D* mutable_acceleration();
  void set_allocated_acceleration(::apollo::common::Point3D* acceleration);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional double theta = 3;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 3;
  double theta() const;
  void set_theta(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.PerceptionObstacleFeature)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_position();
  void clear_has_position();
  void set_has_theta();
  void clear_has_theta();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_acceleration();
  void clear_has_acceleration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::common::Point3D > polygon_point_;
  ::apollo::common::Point3D* position_;
  ::apollo::common::Point3D* velocity_;
  ::apollo::common::Point3D* acceleration_;
  double timestamp_sec_;
  double theta_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleTrajectoryFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ObstacleTrajectoryFeature) */ {
 public:
  ObstacleTrajectoryFeature();
  virtual ~ObstacleTrajectoryFeature();

  ObstacleTrajectoryFeature(const ObstacleTrajectoryFeature& from);

  inline ObstacleTrajectoryFeature& operator=(const ObstacleTrajectoryFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleTrajectoryFeature(ObstacleTrajectoryFeature&& from) noexcept
    : ObstacleTrajectoryFeature() {
    *this = ::std::move(from);
  }

  inline ObstacleTrajectoryFeature& operator=(ObstacleTrajectoryFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleTrajectoryFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleTrajectoryFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleTrajectoryFeature*>(
               &_ObstacleTrajectoryFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ObstacleTrajectoryFeature* other);
  friend void swap(ObstacleTrajectoryFeature& a, ObstacleTrajectoryFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleTrajectoryFeature* New() const final {
    return CreateMaybeMessage<ObstacleTrajectoryFeature>(NULL);
  }

  ObstacleTrajectoryFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleTrajectoryFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObstacleTrajectoryFeature& from);
  void MergeFrom(const ObstacleTrajectoryFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleTrajectoryFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.PerceptionObstacleFeature perception_obstacle_history = 1;
  int perception_obstacle_history_size() const;
  void clear_perception_obstacle_history();
  static const int kPerceptionObstacleHistoryFieldNumber = 1;
  ::apollo::planning::PerceptionObstacleFeature* mutable_perception_obstacle_history(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >*
      mutable_perception_obstacle_history();
  const ::apollo::planning::PerceptionObstacleFeature& perception_obstacle_history(int index) const;
  ::apollo::planning::PerceptionObstacleFeature* add_perception_obstacle_history();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >&
      perception_obstacle_history() const;

  // repeated .apollo.planning.TrajectoryPointFeature evaluated_trajectory_point = 2;
  int evaluated_trajectory_point_size() const;
  void clear_evaluated_trajectory_point();
  static const int kEvaluatedTrajectoryPointFieldNumber = 2;
  ::apollo::planning::TrajectoryPointFeature* mutable_evaluated_trajectory_point(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
      mutable_evaluated_trajectory_point();
  const ::apollo::planning::TrajectoryPointFeature& evaluated_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* add_evaluated_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
      evaluated_trajectory_point() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.ObstacleTrajectoryFeature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature > perception_obstacle_history_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature > evaluated_trajectory_point_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictionTrajectoryFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PredictionTrajectoryFeature) */ {
 public:
  PredictionTrajectoryFeature();
  virtual ~PredictionTrajectoryFeature();

  PredictionTrajectoryFeature(const PredictionTrajectoryFeature& from);

  inline PredictionTrajectoryFeature& operator=(const PredictionTrajectoryFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictionTrajectoryFeature(PredictionTrajectoryFeature&& from) noexcept
    : PredictionTrajectoryFeature() {
    *this = ::std::move(from);
  }

  inline PredictionTrajectoryFeature& operator=(PredictionTrajectoryFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionTrajectoryFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionTrajectoryFeature* internal_default_instance() {
    return reinterpret_cast<const PredictionTrajectoryFeature*>(
               &_PredictionTrajectoryFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PredictionTrajectoryFeature* other);
  friend void swap(PredictionTrajectoryFeature& a, PredictionTrajectoryFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictionTrajectoryFeature* New() const final {
    return CreateMaybeMessage<PredictionTrajectoryFeature>(NULL);
  }

  PredictionTrajectoryFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PredictionTrajectoryFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PredictionTrajectoryFeature& from);
  void MergeFrom(const PredictionTrajectoryFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictionTrajectoryFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TrajectoryPointFeature trajectory_point = 2;
  int trajectory_point_size() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 2;
  ::apollo::planning::TrajectoryPointFeature* mutable_trajectory_point(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
      mutable_trajectory_point();
  const ::apollo::planning::TrajectoryPointFeature& trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* add_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
      trajectory_point() const;

  // optional double probability = 1;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 1;
  double probability() const;
  void set_probability(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.PredictionTrajectoryFeature)
 private:
  void set_has_probability();
  void clear_has_probability();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature > trajectory_point_;
  double probability_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PredictionObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PredictionObstacleFeature) */ {
 public:
  PredictionObstacleFeature();
  virtual ~PredictionObstacleFeature();

  PredictionObstacleFeature(const PredictionObstacleFeature& from);

  inline PredictionObstacleFeature& operator=(const PredictionObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictionObstacleFeature(PredictionObstacleFeature&& from) noexcept
    : PredictionObstacleFeature() {
    *this = ::std::move(from);
  }

  inline PredictionObstacleFeature& operator=(PredictionObstacleFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionObstacleFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const PredictionObstacleFeature*>(
               &_PredictionObstacleFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(PredictionObstacleFeature* other);
  friend void swap(PredictionObstacleFeature& a, PredictionObstacleFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictionObstacleFeature* New() const final {
    return CreateMaybeMessage<PredictionObstacleFeature>(NULL);
  }

  PredictionObstacleFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PredictionObstacleFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PredictionObstacleFeature& from);
  void MergeFrom(const PredictionObstacleFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PredictionObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.PredictionTrajectoryFeature trajectory = 6;
  int trajectory_size() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 6;
  ::apollo::planning::PredictionTrajectoryFeature* mutable_trajectory(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >*
      mutable_trajectory();
  const ::apollo::planning::PredictionTrajectoryFeature& trajectory(int index) const;
  ::apollo::planning::PredictionTrajectoryFeature* add_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >&
      trajectory() const;

  // optional .apollo.prediction.ObstacleIntent intent = 3;
  bool has_intent() const;
  void clear_intent();
  static const int kIntentFieldNumber = 3;
  private:
  const ::apollo::prediction::ObstacleIntent& _internal_intent() const;
  public:
  const ::apollo::prediction::ObstacleIntent& intent() const;
  ::apollo::prediction::ObstacleIntent* release_intent();
  ::apollo::prediction::ObstacleIntent* mutable_intent();
  void set_allocated_intent(::apollo::prediction::ObstacleIntent* intent);

  // optional .apollo.prediction.ObstaclePriority priority = 4;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 4;
  private:
  const ::apollo::prediction::ObstaclePriority& _internal_priority() const;
  public:
  const ::apollo::prediction::ObstaclePriority& priority() const;
  ::apollo::prediction::ObstaclePriority* release_priority();
  ::apollo::prediction::ObstaclePriority* mutable_priority();
  void set_allocated_priority(::apollo::prediction::ObstaclePriority* priority);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // optional double predicted_period = 2;
  bool has_predicted_period() const;
  void clear_predicted_period();
  static const int kPredictedPeriodFieldNumber = 2;
  double predicted_period() const;
  void set_predicted_period(double value);

  // optional bool is_static = 5 [default = false];
  bool has_is_static() const;
  void clear_is_static();
  static const int kIsStaticFieldNumber = 5;
  bool is_static() const;
  void set_is_static(bool value);

  // @@protoc_insertion_point(class_scope:apollo.planning.PredictionObstacleFeature)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_predicted_period();
  void clear_has_predicted_period();
  void set_has_intent();
  void clear_has_intent();
  void set_has_priority();
  void clear_has_priority();
  void set_has_is_static();
  void clear_has_is_static();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature > trajectory_;
  ::apollo::prediction::ObstacleIntent* intent_;
  ::apollo::prediction::ObstaclePriority* priority_;
  double timestamp_sec_;
  double predicted_period_;
  bool is_static_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ObstacleFeature) */ {
 public:
  ObstacleFeature();
  virtual ~ObstacleFeature();

  ObstacleFeature(const ObstacleFeature& from);

  inline ObstacleFeature& operator=(const ObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleFeature(ObstacleFeature&& from) noexcept
    : ObstacleFeature() {
    *this = ::std::move(from);
  }

  inline ObstacleFeature& operator=(ObstacleFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleFeature*>(
               &_ObstacleFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ObstacleFeature* other);
  friend void swap(ObstacleFeature& a, ObstacleFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleFeature* New() const final {
    return CreateMaybeMessage<ObstacleFeature>(NULL);
  }

  ObstacleFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObstacleFeature& from);
  void MergeFrom(const ObstacleFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.ObstacleTrajectoryFeature obstacle_trajectory = 6;
  bool has_obstacle_trajectory() const;
  void clear_obstacle_trajectory();
  static const int kObstacleTrajectoryFieldNumber = 6;
  private:
  const ::apollo::planning::ObstacleTrajectoryFeature& _internal_obstacle_trajectory() const;
  public:
  const ::apollo::planning::ObstacleTrajectoryFeature& obstacle_trajectory() const;
  ::apollo::planning::ObstacleTrajectoryFeature* release_obstacle_trajectory();
  ::apollo::planning::ObstacleTrajectoryFeature* mutable_obstacle_trajectory();
  void set_allocated_obstacle_trajectory(::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory);

  // optional .apollo.planning.PredictionObstacleFeature obstacle_prediction = 7;
  bool has_obstacle_prediction() const;
  void clear_obstacle_prediction();
  static const int kObstaclePredictionFieldNumber = 7;
  private:
  const ::apollo::planning::PredictionObstacleFeature& _internal_obstacle_prediction() const;
  public:
  const ::apollo::planning::PredictionObstacleFeature& obstacle_prediction() const;
  ::apollo::planning::PredictionObstacleFeature* release_obstacle_prediction();
  ::apollo::planning::PredictionObstacleFeature* mutable_obstacle_prediction();
  void set_allocated_obstacle_prediction(::apollo::planning::PredictionObstacleFeature* obstacle_prediction);

  // optional double length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  double length() const;
  void set_length(double value);

  // optional double width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  double width() const;
  void set_width(double value);

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .apollo.perception.PerceptionObstacle.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::apollo::perception::PerceptionObstacle_Type type() const;
  void set_type(::apollo::perception::PerceptionObstacle_Type value);

  // optional double height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  double height() const;
  void set_height(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ObstacleFeature)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_type();
  void clear_has_type();
  void set_has_obstacle_trajectory();
  void clear_has_obstacle_trajectory();
  void set_has_obstacle_prediction();
  void clear_has_obstacle_prediction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory_;
  ::apollo::planning::PredictionObstacleFeature* obstacle_prediction_;
  double length_;
  double width_;
  ::google::protobuf::int32 id_;
  int type_;
  double height_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoutingResponseFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RoutingResponseFeature) */ {
 public:
  RoutingResponseFeature();
  virtual ~RoutingResponseFeature();

  RoutingResponseFeature(const RoutingResponseFeature& from);

  inline RoutingResponseFeature& operator=(const RoutingResponseFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingResponseFeature(RoutingResponseFeature&& from) noexcept
    : RoutingResponseFeature() {
    *this = ::std::move(from);
  }

  inline RoutingResponseFeature& operator=(RoutingResponseFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingResponseFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingResponseFeature* internal_default_instance() {
    return reinterpret_cast<const RoutingResponseFeature*>(
               &_RoutingResponseFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RoutingResponseFeature* other);
  friend void swap(RoutingResponseFeature& a, RoutingResponseFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingResponseFeature* New() const final {
    return CreateMaybeMessage<RoutingResponseFeature>(NULL);
  }

  RoutingResponseFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoutingResponseFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoutingResponseFeature& from);
  void MergeFrom(const RoutingResponseFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingResponseFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.routing.RoadSegment road = 1;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 1;
  ::apollo::routing::RoadSegment* mutable_road(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::routing::RoadSegment >*
      mutable_road();
  const ::apollo::routing::RoadSegment& road(int index) const;
  ::apollo::routing::RoadSegment* add_road();
  const ::google::protobuf::RepeatedPtrField< ::apollo::routing::RoadSegment >&
      road() const;

  // optional .apollo.routing.Measurement measurement = 2;
  bool has_measurement() const;
  void clear_measurement();
  static const int kMeasurementFieldNumber = 2;
  private:
  const ::apollo::routing::Measurement& _internal_measurement() const;
  public:
  const ::apollo::routing::Measurement& measurement() const;
  ::apollo::routing::Measurement* release_measurement();
  ::apollo::routing::Measurement* mutable_measurement();
  void set_allocated_measurement(::apollo::routing::Measurement* measurement);

  // @@protoc_insertion_point(class_scope:apollo.planning.RoutingResponseFeature)
 private:
  void set_has_measurement();
  void clear_has_measurement();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::routing::RoadSegment > road_;
  ::apollo::routing::Measurement* measurement_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoutingFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RoutingFeature) */ {
 public:
  RoutingFeature();
  virtual ~RoutingFeature();

  RoutingFeature(const RoutingFeature& from);

  inline RoutingFeature& operator=(const RoutingFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingFeature(RoutingFeature&& from) noexcept
    : RoutingFeature() {
    *this = ::std::move(from);
  }

  inline RoutingFeature& operator=(RoutingFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingFeature* internal_default_instance() {
    return reinterpret_cast<const RoutingFeature*>(
               &_RoutingFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RoutingFeature* other);
  friend void swap(RoutingFeature& a, RoutingFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingFeature* New() const final {
    return CreateMaybeMessage<RoutingFeature>(NULL);
  }

  RoutingFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoutingFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoutingFeature& from);
  void MergeFrom(const RoutingFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string local_routing_lane_id = 2;
  int local_routing_lane_id_size() const;
  void clear_local_routing_lane_id();
  static const int kLocalRoutingLaneIdFieldNumber = 2;
  const ::std::string& local_routing_lane_id(int index) const;
  ::std::string* mutable_local_routing_lane_id(int index);
  void set_local_routing_lane_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_local_routing_lane_id(int index, ::std::string&& value);
  #endif
  void set_local_routing_lane_id(int index, const char* value);
  void set_local_routing_lane_id(int index, const char* value, size_t size);
  ::std::string* add_local_routing_lane_id();
  void add_local_routing_lane_id(const ::std::string& value);
  #if LANG_CXX11
  void add_local_routing_lane_id(::std::string&& value);
  #endif
  void add_local_routing_lane_id(const char* value);
  void add_local_routing_lane_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& local_routing_lane_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_local_routing_lane_id();

  // optional .apollo.planning.RoutingResponseFeature routing_response = 1;
  bool has_routing_response() const;
  void clear_routing_response();
  static const int kRoutingResponseFieldNumber = 1;
  private:
  const ::apollo::planning::RoutingResponseFeature& _internal_routing_response() const;
  public:
  const ::apollo::planning::RoutingResponseFeature& routing_response() const;
  ::apollo::planning::RoutingResponseFeature* release_routing_response();
  ::apollo::planning::RoutingResponseFeature* mutable_routing_response();
  void set_allocated_routing_response(::apollo::planning::RoutingResponseFeature* routing_response);

  // optional .apollo.planning.RoutingResponseFeature local_routing = 3;
  bool has_local_routing() const;
  void clear_local_routing();
  static const int kLocalRoutingFieldNumber = 3;
  private:
  const ::apollo::planning::RoutingResponseFeature& _internal_local_routing() const;
  public:
  const ::apollo::planning::RoutingResponseFeature& local_routing() const;
  ::apollo::planning::RoutingResponseFeature* release_local_routing();
  ::apollo::planning::RoutingResponseFeature* mutable_local_routing();
  void set_allocated_local_routing(::apollo::planning::RoutingResponseFeature* local_routing);

  // @@protoc_insertion_point(class_scope:apollo.planning.RoutingFeature)
 private:
  void set_has_routing_response();
  void clear_has_routing_response();
  void set_has_local_routing();
  void clear_has_local_routing();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> local_routing_lane_id_;
  ::apollo::planning::RoutingResponseFeature* routing_response_;
  ::apollo::planning::RoutingResponseFeature* local_routing_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightFeature) */ {
 public:
  TrafficLightFeature();
  virtual ~TrafficLightFeature();

  TrafficLightFeature(const TrafficLightFeature& from);

  inline TrafficLightFeature& operator=(const TrafficLightFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightFeature(TrafficLightFeature&& from) noexcept
    : TrafficLightFeature() {
    *this = ::std::move(from);
  }

  inline TrafficLightFeature& operator=(TrafficLightFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightFeature* internal_default_instance() {
    return reinterpret_cast<const TrafficLightFeature*>(
               &_TrafficLightFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TrafficLightFeature* other);
  friend void swap(TrafficLightFeature& a, TrafficLightFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightFeature* New() const final {
    return CreateMaybeMessage<TrafficLightFeature>(NULL);
  }

  TrafficLightFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLightFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficLightFeature& from);
  void MergeFrom(const TrafficLightFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .apollo.perception.TrafficLight.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  ::apollo::perception::TrafficLight_Color color() const;
  void set_color(::apollo::perception::TrafficLight_Color value);

  // optional bool blink = 5;
  bool has_blink() const;
  void clear_blink();
  static const int kBlinkFieldNumber = 5;
  bool blink() const;
  void set_blink(bool value);

  // optional double tracking_time = 4;
  bool has_tracking_time() const;
  void clear_tracking_time();
  static const int kTrackingTimeFieldNumber = 4;
  double tracking_time() const;
  void set_tracking_time(double value);

  // optional double remaining_time = 6;
  bool has_remaining_time() const;
  void clear_remaining_time();
  static const int kRemainingTimeFieldNumber = 6;
  double remaining_time() const;
  void set_remaining_time(double value);

  // optional double confidence = 3 [default = 1];
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 3;
  double confidence() const;
  void set_confidence(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightFeature)
 private:
  void set_has_color();
  void clear_has_color();
  void set_has_id();
  void clear_has_id();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_tracking_time();
  void clear_has_tracking_time();
  void set_has_blink();
  void clear_has_blink();
  void set_has_remaining_time();
  void clear_has_remaining_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int color_;
  bool blink_;
  double tracking_time_;
  double remaining_time_;
  double confidence_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightDetectionFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightDetectionFeature) */ {
 public:
  TrafficLightDetectionFeature();
  virtual ~TrafficLightDetectionFeature();

  TrafficLightDetectionFeature(const TrafficLightDetectionFeature& from);

  inline TrafficLightDetectionFeature& operator=(const TrafficLightDetectionFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightDetectionFeature(TrafficLightDetectionFeature&& from) noexcept
    : TrafficLightDetectionFeature() {
    *this = ::std::move(from);
  }

  inline TrafficLightDetectionFeature& operator=(TrafficLightDetectionFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightDetectionFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightDetectionFeature* internal_default_instance() {
    return reinterpret_cast<const TrafficLightDetectionFeature*>(
               &_TrafficLightDetectionFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TrafficLightDetectionFeature* other);
  friend void swap(TrafficLightDetectionFeature& a, TrafficLightDetectionFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightDetectionFeature* New() const final {
    return CreateMaybeMessage<TrafficLightDetectionFeature>(NULL);
  }

  TrafficLightDetectionFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLightDetectionFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficLightDetectionFeature& from);
  void MergeFrom(const TrafficLightDetectionFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightDetectionFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TrafficLightFeature traffic_light = 2;
  int traffic_light_size() const;
  void clear_traffic_light();
  static const int kTrafficLightFieldNumber = 2;
  ::apollo::planning::TrafficLightFeature* mutable_traffic_light(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >*
      mutable_traffic_light();
  const ::apollo::planning::TrafficLightFeature& traffic_light(int index) const;
  ::apollo::planning::TrafficLightFeature* add_traffic_light();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >&
      traffic_light() const;

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightDetectionFeature)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficLightFeature > traffic_light_;
  double message_timestamp_sec_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ADCTrajectoryPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ADCTrajectoryPoint) */ {
 public:
  ADCTrajectoryPoint();
  virtual ~ADCTrajectoryPoint();

  ADCTrajectoryPoint(const ADCTrajectoryPoint& from);

  inline ADCTrajectoryPoint& operator=(const ADCTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ADCTrajectoryPoint(ADCTrajectoryPoint&& from) noexcept
    : ADCTrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline ADCTrajectoryPoint& operator=(ADCTrajectoryPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ADCTrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ADCTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const ADCTrajectoryPoint*>(
               &_ADCTrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ADCTrajectoryPoint* other);
  friend void swap(ADCTrajectoryPoint& a, ADCTrajectoryPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ADCTrajectoryPoint* New() const final {
    return CreateMaybeMessage<ADCTrajectoryPoint>(NULL);
  }

  ADCTrajectoryPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ADCTrajectoryPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ADCTrajectoryPoint& from);
  void MergeFrom(const ADCTrajectoryPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ADCTrajectoryPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.PlanningTag planning_tag = 2;
  bool has_planning_tag() const;
  void clear_planning_tag();
  static const int kPlanningTagFieldNumber = 2;
  private:
  const ::apollo::planning::PlanningTag& _internal_planning_tag() const;
  public:
  const ::apollo::planning::PlanningTag& planning_tag() const;
  ::apollo::planning::PlanningTag* release_planning_tag();
  ::apollo::planning::PlanningTag* mutable_planning_tag();
  void set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag);

  // optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 3;
  bool has_trajectory_point() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 3;
  private:
  const ::apollo::planning::CommonTrajectoryPointFeature& _internal_trajectory_point() const;
  public:
  const ::apollo::planning::CommonTrajectoryPointFeature& trajectory_point() const;
  ::apollo::planning::CommonTrajectoryPointFeature* release_trajectory_point();
  ::apollo::planning::CommonTrajectoryPointFeature* mutable_trajectory_point();
  void set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point);

  // optional double timestamp_sec = 1;
  bool has_timestamp_sec() const;
  void clear_timestamp_sec();
  static const int kTimestampSecFieldNumber = 1;
  double timestamp_sec() const;
  void set_timestamp_sec(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ADCTrajectoryPoint)
 private:
  void set_has_timestamp_sec();
  void clear_has_timestamp_sec();
  void set_has_planning_tag();
  void clear_has_planning_tag();
  void set_has_trajectory_point();
  void clear_has_trajectory_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::planning::PlanningTag* planning_tag_;
  ::apollo::planning::CommonTrajectoryPointFeature* trajectory_point_;
  double timestamp_sec_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LearningOutput) */ {
 public:
  LearningOutput();
  virtual ~LearningOutput();

  LearningOutput(const LearningOutput& from);

  inline LearningOutput& operator=(const LearningOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningOutput(LearningOutput&& from) noexcept
    : LearningOutput() {
    *this = ::std::move(from);
  }

  inline LearningOutput& operator=(LearningOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningOutput* internal_default_instance() {
    return reinterpret_cast<const LearningOutput*>(
               &_LearningOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(LearningOutput* other);
  friend void swap(LearningOutput& a, LearningOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningOutput* New() const final {
    return CreateMaybeMessage<LearningOutput>(NULL);
  }

  LearningOutput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningOutput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningOutput& from);
  void MergeFrom(const LearningOutput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TrajectoryPointFeature adc_future_trajectory_point = 1;
  int adc_future_trajectory_point_size() const;
  void clear_adc_future_trajectory_point();
  static const int kAdcFutureTrajectoryPointFieldNumber = 1;
  ::apollo::planning::TrajectoryPointFeature* mutable_adc_future_trajectory_point(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
      mutable_adc_future_trajectory_point();
  const ::apollo::planning::TrajectoryPointFeature& adc_future_trajectory_point(int index) const;
  ::apollo::planning::TrajectoryPointFeature* add_adc_future_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
      adc_future_trajectory_point() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.LearningOutput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature > adc_future_trajectory_point_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningDataFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LearningDataFrame) */ {
 public:
  LearningDataFrame();
  virtual ~LearningDataFrame();

  LearningDataFrame(const LearningDataFrame& from);

  inline LearningDataFrame& operator=(const LearningDataFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningDataFrame(LearningDataFrame&& from) noexcept
    : LearningDataFrame() {
    *this = ::std::move(from);
  }

  inline LearningDataFrame& operator=(LearningDataFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningDataFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningDataFrame* internal_default_instance() {
    return reinterpret_cast<const LearningDataFrame*>(
               &_LearningDataFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(LearningDataFrame* other);
  friend void swap(LearningDataFrame& a, LearningDataFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningDataFrame* New() const final {
    return CreateMaybeMessage<LearningDataFrame>(NULL);
  }

  LearningDataFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningDataFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningDataFrame& from);
  void MergeFrom(const LearningDataFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningDataFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.ObstacleFeature obstacle = 7;
  int obstacle_size() const;
  void clear_obstacle();
  static const int kObstacleFieldNumber = 7;
  ::apollo::planning::ObstacleFeature* mutable_obstacle(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::ObstacleFeature >*
      mutable_obstacle();
  const ::apollo::planning::ObstacleFeature& obstacle(int index) const;
  ::apollo::planning::ObstacleFeature* add_obstacle();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::ObstacleFeature >&
      obstacle() const;

  // repeated .apollo.planning.ADCTrajectoryPoint adc_trajectory_point = 10;
  int adc_trajectory_point_size() const;
  void clear_adc_trajectory_point();
  static const int kAdcTrajectoryPointFieldNumber = 10;
  ::apollo::planning::ADCTrajectoryPoint* mutable_adc_trajectory_point(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >*
      mutable_adc_trajectory_point();
  const ::apollo::planning::ADCTrajectoryPoint& adc_trajectory_point(int index) const;
  ::apollo::planning::ADCTrajectoryPoint* add_adc_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >&
      adc_trajectory_point() const;

  // optional string map_name = 3;
  bool has_map_name() const;
  void clear_map_name();
  static const int kMapNameFieldNumber = 3;
  const ::std::string& map_name() const;
  void set_map_name(const ::std::string& value);
  #if LANG_CXX11
  void set_map_name(::std::string&& value);
  #endif
  void set_map_name(const char* value);
  void set_map_name(const char* value, size_t size);
  ::std::string* mutable_map_name();
  ::std::string* release_map_name();
  void set_allocated_map_name(::std::string* map_name);

  // optional .apollo.planning.PlanningTag planning_tag = 4;
  bool has_planning_tag() const;
  void clear_planning_tag();
  static const int kPlanningTagFieldNumber = 4;
  private:
  const ::apollo::planning::PlanningTag& _internal_planning_tag() const;
  public:
  const ::apollo::planning::PlanningTag& planning_tag() const;
  ::apollo::planning::PlanningTag* release_planning_tag();
  ::apollo::planning::PlanningTag* mutable_planning_tag();
  void set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag);

  // optional .apollo.planning.ChassisFeature chassis = 5;
  bool has_chassis() const;
  void clear_chassis();
  static const int kChassisFieldNumber = 5;
  private:
  const ::apollo::planning::ChassisFeature& _internal_chassis() const;
  public:
  const ::apollo::planning::ChassisFeature& chassis() const;
  ::apollo::planning::ChassisFeature* release_chassis();
  ::apollo::planning::ChassisFeature* mutable_chassis();
  void set_allocated_chassis(::apollo::planning::ChassisFeature* chassis);

  // optional .apollo.planning.LocalizationFeature localization = 6;
  bool has_localization() const;
  void clear_localization();
  static const int kLocalizationFieldNumber = 6;
  private:
  const ::apollo::planning::LocalizationFeature& _internal_localization() const;
  public:
  const ::apollo::planning::LocalizationFeature& localization() const;
  ::apollo::planning::LocalizationFeature* release_localization();
  ::apollo::planning::LocalizationFeature* mutable_localization();
  void set_allocated_localization(::apollo::planning::LocalizationFeature* localization);

  // optional .apollo.planning.RoutingFeature routing = 8;
  bool has_routing() const;
  void clear_routing();
  static const int kRoutingFieldNumber = 8;
  private:
  const ::apollo::planning::RoutingFeature& _internal_routing() const;
  public:
  const ::apollo::planning::RoutingFeature& routing() const;
  ::apollo::planning::RoutingFeature* release_routing();
  ::apollo::planning::RoutingFeature* mutable_routing();
  void set_allocated_routing(::apollo::planning::RoutingFeature* routing);

  // optional .apollo.planning.TrafficLightDetectionFeature traffic_light_detection = 9;
  bool has_traffic_light_detection() const;
  void clear_traffic_light_detection();
  static const int kTrafficLightDetectionFieldNumber = 9;
  private:
  const ::apollo::planning::TrafficLightDetectionFeature& _internal_traffic_light_detection() const;
  public:
  const ::apollo::planning::TrafficLightDetectionFeature& traffic_light_detection() const;
  ::apollo::planning::TrafficLightDetectionFeature* release_traffic_light_detection();
  ::apollo::planning::TrafficLightDetectionFeature* mutable_traffic_light_detection();
  void set_allocated_traffic_light_detection(::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection);

  // optional .apollo.planning.LearningOutput output = 11;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 11;
  private:
  const ::apollo::planning::LearningOutput& _internal_output() const;
  public:
  const ::apollo::planning::LearningOutput& output() const;
  ::apollo::planning::LearningOutput* release_output();
  ::apollo::planning::LearningOutput* mutable_output();
  void set_allocated_output(::apollo::planning::LearningOutput* output);

  // optional double message_timestamp_sec = 1;
  bool has_message_timestamp_sec() const;
  void clear_message_timestamp_sec();
  static const int kMessageTimestampSecFieldNumber = 1;
  double message_timestamp_sec() const;
  void set_message_timestamp_sec(double value);

  // optional uint32 frame_num = 2;
  bool has_frame_num() const;
  void clear_frame_num();
  static const int kFrameNumFieldNumber = 2;
  ::google::protobuf::uint32 frame_num() const;
  void set_frame_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:apollo.planning.LearningDataFrame)
 private:
  void set_has_message_timestamp_sec();
  void clear_has_message_timestamp_sec();
  void set_has_frame_num();
  void clear_has_frame_num();
  void set_has_map_name();
  void clear_has_map_name();
  void set_has_planning_tag();
  void clear_has_planning_tag();
  void set_has_chassis();
  void clear_has_chassis();
  void set_has_localization();
  void clear_has_localization();
  void set_has_routing();
  void clear_has_routing();
  void set_has_traffic_light_detection();
  void clear_has_traffic_light_detection();
  void set_has_output();
  void clear_has_output();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::ObstacleFeature > obstacle_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint > adc_trajectory_point_;
  ::google::protobuf::internal::ArenaStringPtr map_name_;
  ::apollo::planning::PlanningTag* planning_tag_;
  ::apollo::planning::ChassisFeature* chassis_;
  ::apollo::planning::LocalizationFeature* localization_;
  ::apollo::planning::RoutingFeature* routing_;
  ::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection_;
  ::apollo::planning::LearningOutput* output_;
  double message_timestamp_sec_;
  ::google::protobuf::uint32 frame_num_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LearningData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LearningData) */ {
 public:
  LearningData();
  virtual ~LearningData();

  LearningData(const LearningData& from);

  inline LearningData& operator=(const LearningData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LearningData(LearningData&& from) noexcept
    : LearningData() {
    *this = ::std::move(from);
  }

  inline LearningData& operator=(LearningData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LearningData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LearningData* internal_default_instance() {
    return reinterpret_cast<const LearningData*>(
               &_LearningData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(LearningData* other);
  friend void swap(LearningData& a, LearningData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LearningData* New() const final {
    return CreateMaybeMessage<LearningData>(NULL);
  }

  LearningData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LearningData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LearningData& from);
  void MergeFrom(const LearningData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.LearningDataFrame learning_data_frame = 1;
  int learning_data_frame_size() const;
  void clear_learning_data_frame();
  static const int kLearningDataFrameFieldNumber = 1;
  ::apollo::planning::LearningDataFrame* mutable_learning_data_frame(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::LearningDataFrame >*
      mutable_learning_data_frame();
  const ::apollo::planning::LearningDataFrame& learning_data_frame(int index) const;
  ::apollo::planning::LearningDataFrame* add_learning_data_frame();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::LearningDataFrame >&
      learning_data_frame() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.LearningData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::LearningDataFrame > learning_data_frame_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningLearningData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningLearningData) */ {
 public:
  PlanningLearningData();
  virtual ~PlanningLearningData();

  PlanningLearningData(const PlanningLearningData& from);

  inline PlanningLearningData& operator=(const PlanningLearningData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningLearningData(PlanningLearningData&& from) noexcept
    : PlanningLearningData() {
    *this = ::std::move(from);
  }

  inline PlanningLearningData& operator=(PlanningLearningData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningLearningData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningLearningData* internal_default_instance() {
    return reinterpret_cast<const PlanningLearningData*>(
               &_PlanningLearningData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(PlanningLearningData* other);
  friend void swap(PlanningLearningData& a, PlanningLearningData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningLearningData* New() const final {
    return CreateMaybeMessage<PlanningLearningData>(NULL);
  }

  PlanningLearningData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanningLearningData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanningLearningData& from);
  void MergeFrom(const PlanningLearningData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningLearningData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::apollo::common::Header& _internal_header() const;
  public:
  const ::apollo::common::Header& header() const;
  ::apollo::common::Header* release_header();
  ::apollo::common::Header* mutable_header();
  void set_allocated_header(::apollo::common::Header* header);

  // optional .apollo.planning.LearningDataFrame learning_data_frame = 2;
  bool has_learning_data_frame() const;
  void clear_learning_data_frame();
  static const int kLearningDataFrameFieldNumber = 2;
  private:
  const ::apollo::planning::LearningDataFrame& _internal_learning_data_frame() const;
  public:
  const ::apollo::planning::LearningDataFrame& learning_data_frame() const;
  ::apollo::planning::LearningDataFrame* release_learning_data_frame();
  ::apollo::planning::LearningDataFrame* mutable_learning_data_frame();
  void set_allocated_learning_data_frame(::apollo::planning::LearningDataFrame* learning_data_frame);

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningLearningData)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_learning_data_frame();
  void clear_has_learning_data_frame();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::apollo::common::Header* header_;
  ::apollo::planning::LearningDataFrame* learning_data_frame_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2flearning_5fdata_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OverlapFeature

// optional string id = 1;
inline bool OverlapFeature::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OverlapFeature::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OverlapFeature::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OverlapFeature::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& OverlapFeature::id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.OverlapFeature.id)
  return id_.GetNoArena();
}
inline void OverlapFeature::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.OverlapFeature.id)
}
#if LANG_CXX11
inline void OverlapFeature::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.OverlapFeature.id)
}
#endif
inline void OverlapFeature::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.OverlapFeature.id)
}
inline void OverlapFeature::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.OverlapFeature.id)
}
inline ::std::string* OverlapFeature::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.OverlapFeature.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OverlapFeature::release_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.OverlapFeature.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OverlapFeature::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.OverlapFeature.id)
}

// optional double distance = 2;
inline bool OverlapFeature::has_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OverlapFeature::set_has_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OverlapFeature::clear_has_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OverlapFeature::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline double OverlapFeature::distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.OverlapFeature.distance)
  return distance_;
}
inline void OverlapFeature::set_distance(double value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.OverlapFeature.distance)
}

// -------------------------------------------------------------------

// PlanningTag

// optional .apollo.hdmap.Lane.LaneTurn lane_turn = 1;
inline bool PlanningTag::has_lane_turn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlanningTag::set_has_lane_turn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlanningTag::clear_has_lane_turn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlanningTag::clear_lane_turn() {
  lane_turn_ = 1;
  clear_has_lane_turn();
}
inline ::apollo::hdmap::Lane_LaneTurn PlanningTag::lane_turn() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.lane_turn)
  return static_cast< ::apollo::hdmap::Lane_LaneTurn >(lane_turn_);
}
inline void PlanningTag::set_lane_turn(::apollo::hdmap::Lane_LaneTurn value) {
  assert(::apollo::hdmap::Lane_LaneTurn_IsValid(value));
  set_has_lane_turn();
  lane_turn_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PlanningTag.lane_turn)
}

// optional .apollo.planning.OverlapFeature clear_area = 2;
inline bool PlanningTag::has_clear_area() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningTag::set_has_clear_area() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningTag::clear_has_clear_area() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningTag::clear_clear_area() {
  if (clear_area_ != NULL) clear_area_->Clear();
  clear_has_clear_area();
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_clear_area() const {
  return *clear_area_;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::clear_area() const {
  const ::apollo::planning::OverlapFeature* p = clear_area_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.clear_area)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::OverlapFeature*>(
      &::apollo::planning::_OverlapFeature_default_instance_);
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_clear_area() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.clear_area)
  clear_has_clear_area();
  ::apollo::planning::OverlapFeature* temp = clear_area_;
  clear_area_ = NULL;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_clear_area() {
  set_has_clear_area();
  if (clear_area_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaNoVirtual());
    clear_area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.clear_area)
  return clear_area_;
}
inline void PlanningTag::set_allocated_clear_area(::apollo::planning::OverlapFeature* clear_area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete clear_area_;
  }
  if (clear_area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      clear_area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clear_area, submessage_arena);
    }
    set_has_clear_area();
  } else {
    clear_has_clear_area();
  }
  clear_area_ = clear_area;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.clear_area)
}

// optional .apollo.planning.OverlapFeature crosswalk = 3;
inline bool PlanningTag::has_crosswalk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningTag::set_has_crosswalk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningTag::clear_has_crosswalk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningTag::clear_crosswalk() {
  if (crosswalk_ != NULL) crosswalk_->Clear();
  clear_has_crosswalk();
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_crosswalk() const {
  return *crosswalk_;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::crosswalk() const {
  const ::apollo::planning::OverlapFeature* p = crosswalk_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.crosswalk)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::OverlapFeature*>(
      &::apollo::planning::_OverlapFeature_default_instance_);
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.crosswalk)
  clear_has_crosswalk();
  ::apollo::planning::OverlapFeature* temp = crosswalk_;
  crosswalk_ = NULL;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_crosswalk() {
  set_has_crosswalk();
  if (crosswalk_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaNoVirtual());
    crosswalk_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.crosswalk)
  return crosswalk_;
}
inline void PlanningTag::set_allocated_crosswalk(::apollo::planning::OverlapFeature* crosswalk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete crosswalk_;
  }
  if (crosswalk) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      crosswalk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, crosswalk, submessage_arena);
    }
    set_has_crosswalk();
  } else {
    clear_has_crosswalk();
  }
  crosswalk_ = crosswalk;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.crosswalk)
}

// optional .apollo.planning.OverlapFeature pnc_junction = 4;
inline bool PlanningTag::has_pnc_junction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanningTag::set_has_pnc_junction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanningTag::clear_has_pnc_junction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanningTag::clear_pnc_junction() {
  if (pnc_junction_ != NULL) pnc_junction_->Clear();
  clear_has_pnc_junction();
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_pnc_junction() const {
  return *pnc_junction_;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::pnc_junction() const {
  const ::apollo::planning::OverlapFeature* p = pnc_junction_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.pnc_junction)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::OverlapFeature*>(
      &::apollo::planning::_OverlapFeature_default_instance_);
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_pnc_junction() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.pnc_junction)
  clear_has_pnc_junction();
  ::apollo::planning::OverlapFeature* temp = pnc_junction_;
  pnc_junction_ = NULL;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_pnc_junction() {
  set_has_pnc_junction();
  if (pnc_junction_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaNoVirtual());
    pnc_junction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.pnc_junction)
  return pnc_junction_;
}
inline void PlanningTag::set_allocated_pnc_junction(::apollo::planning::OverlapFeature* pnc_junction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pnc_junction_;
  }
  if (pnc_junction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pnc_junction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pnc_junction, submessage_arena);
    }
    set_has_pnc_junction();
  } else {
    clear_has_pnc_junction();
  }
  pnc_junction_ = pnc_junction;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.pnc_junction)
}

// optional .apollo.planning.OverlapFeature signal = 5;
inline bool PlanningTag::has_signal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanningTag::set_has_signal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanningTag::clear_has_signal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanningTag::clear_signal() {
  if (signal_ != NULL) signal_->Clear();
  clear_has_signal();
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_signal() const {
  return *signal_;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::signal() const {
  const ::apollo::planning::OverlapFeature* p = signal_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.signal)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::OverlapFeature*>(
      &::apollo::planning::_OverlapFeature_default_instance_);
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_signal() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.signal)
  clear_has_signal();
  ::apollo::planning::OverlapFeature* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaNoVirtual());
    signal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.signal)
  return signal_;
}
inline void PlanningTag::set_allocated_signal(::apollo::planning::OverlapFeature* signal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signal_;
  }
  if (signal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signal, submessage_arena);
    }
    set_has_signal();
  } else {
    clear_has_signal();
  }
  signal_ = signal;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.signal)
}

// optional .apollo.planning.OverlapFeature stop_sign = 6;
inline bool PlanningTag::has_stop_sign() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlanningTag::set_has_stop_sign() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlanningTag::clear_has_stop_sign() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlanningTag::clear_stop_sign() {
  if (stop_sign_ != NULL) stop_sign_->Clear();
  clear_has_stop_sign();
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_stop_sign() const {
  return *stop_sign_;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::stop_sign() const {
  const ::apollo::planning::OverlapFeature* p = stop_sign_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.stop_sign)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::OverlapFeature*>(
      &::apollo::planning::_OverlapFeature_default_instance_);
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.stop_sign)
  clear_has_stop_sign();
  ::apollo::planning::OverlapFeature* temp = stop_sign_;
  stop_sign_ = NULL;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_stop_sign() {
  set_has_stop_sign();
  if (stop_sign_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaNoVirtual());
    stop_sign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.stop_sign)
  return stop_sign_;
}
inline void PlanningTag::set_allocated_stop_sign(::apollo::planning::OverlapFeature* stop_sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stop_sign_;
  }
  if (stop_sign) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stop_sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stop_sign, submessage_arena);
    }
    set_has_stop_sign();
  } else {
    clear_has_stop_sign();
  }
  stop_sign_ = stop_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.stop_sign)
}

// optional .apollo.planning.OverlapFeature yield_sign = 7;
inline bool PlanningTag::has_yield_sign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlanningTag::set_has_yield_sign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlanningTag::clear_has_yield_sign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlanningTag::clear_yield_sign() {
  if (yield_sign_ != NULL) yield_sign_->Clear();
  clear_has_yield_sign();
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::_internal_yield_sign() const {
  return *yield_sign_;
}
inline const ::apollo::planning::OverlapFeature& PlanningTag::yield_sign() const {
  const ::apollo::planning::OverlapFeature* p = yield_sign_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningTag.yield_sign)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::OverlapFeature*>(
      &::apollo::planning::_OverlapFeature_default_instance_);
}
inline ::apollo::planning::OverlapFeature* PlanningTag::release_yield_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningTag.yield_sign)
  clear_has_yield_sign();
  ::apollo::planning::OverlapFeature* temp = yield_sign_;
  yield_sign_ = NULL;
  return temp;
}
inline ::apollo::planning::OverlapFeature* PlanningTag::mutable_yield_sign() {
  set_has_yield_sign();
  if (yield_sign_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::OverlapFeature>(GetArenaNoVirtual());
    yield_sign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningTag.yield_sign)
  return yield_sign_;
}
inline void PlanningTag::set_allocated_yield_sign(::apollo::planning::OverlapFeature* yield_sign) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yield_sign_;
  }
  if (yield_sign) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yield_sign = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yield_sign, submessage_arena);
    }
    set_has_yield_sign();
  } else {
    clear_has_yield_sign();
  }
  yield_sign_ = yield_sign;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningTag.yield_sign)
}

// -------------------------------------------------------------------

// ChassisFeature

// optional double message_timestamp_sec = 1;
inline bool ChassisFeature::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChassisFeature::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChassisFeature::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChassisFeature::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double ChassisFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void ChassisFeature::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.message_timestamp_sec)
}

// optional float speed_mps = 2;
inline bool ChassisFeature::has_speed_mps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChassisFeature::set_has_speed_mps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChassisFeature::clear_has_speed_mps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChassisFeature::clear_speed_mps() {
  speed_mps_ = 0;
  clear_has_speed_mps();
}
inline float ChassisFeature::speed_mps() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.speed_mps)
  return speed_mps_;
}
inline void ChassisFeature::set_speed_mps(float value) {
  set_has_speed_mps();
  speed_mps_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.speed_mps)
}

// optional float throttle_percentage = 3;
inline bool ChassisFeature::has_throttle_percentage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChassisFeature::set_has_throttle_percentage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChassisFeature::clear_has_throttle_percentage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChassisFeature::clear_throttle_percentage() {
  throttle_percentage_ = 0;
  clear_has_throttle_percentage();
}
inline float ChassisFeature::throttle_percentage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.throttle_percentage)
  return throttle_percentage_;
}
inline void ChassisFeature::set_throttle_percentage(float value) {
  set_has_throttle_percentage();
  throttle_percentage_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.throttle_percentage)
}

// optional float brake_percentage = 4;
inline bool ChassisFeature::has_brake_percentage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChassisFeature::set_has_brake_percentage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChassisFeature::clear_has_brake_percentage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChassisFeature::clear_brake_percentage() {
  brake_percentage_ = 0;
  clear_has_brake_percentage();
}
inline float ChassisFeature::brake_percentage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.brake_percentage)
  return brake_percentage_;
}
inline void ChassisFeature::set_brake_percentage(float value) {
  set_has_brake_percentage();
  brake_percentage_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.brake_percentage)
}

// optional float steering_percentage = 5;
inline bool ChassisFeature::has_steering_percentage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChassisFeature::set_has_steering_percentage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChassisFeature::clear_has_steering_percentage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChassisFeature::clear_steering_percentage() {
  steering_percentage_ = 0;
  clear_has_steering_percentage();
}
inline float ChassisFeature::steering_percentage() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.steering_percentage)
  return steering_percentage_;
}
inline void ChassisFeature::set_steering_percentage(float value) {
  set_has_steering_percentage();
  steering_percentage_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.steering_percentage)
}

// optional .apollo.canbus.Chassis.GearPosition gear_location = 6;
inline bool ChassisFeature::has_gear_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChassisFeature::set_has_gear_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChassisFeature::clear_has_gear_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChassisFeature::clear_gear_location() {
  gear_location_ = 0;
  clear_has_gear_location();
}
inline ::apollo::canbus::Chassis_GearPosition ChassisFeature::gear_location() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChassisFeature.gear_location)
  return static_cast< ::apollo::canbus::Chassis_GearPosition >(gear_location_);
}
inline void ChassisFeature::set_gear_location(::apollo::canbus::Chassis_GearPosition value) {
  assert(::apollo::canbus::Chassis_GearPosition_IsValid(value));
  set_has_gear_location();
  gear_location_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChassisFeature.gear_location)
}

// -------------------------------------------------------------------

// LocalizationFeature

// optional double message_timestamp_sec = 1;
inline bool LocalizationFeature::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalizationFeature::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalizationFeature::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalizationFeature::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double LocalizationFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void LocalizationFeature::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LocalizationFeature.message_timestamp_sec)
}

// optional .apollo.common.PointENU position = 2;
inline bool LocalizationFeature::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalizationFeature::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalizationFeature::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::common::PointENU& LocalizationFeature::_internal_position() const {
  return *position_;
}
inline const ::apollo::common::PointENU& LocalizationFeature::position() const {
  const ::apollo::common::PointENU* p = position_;
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.position)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::PointENU*>(
      &::apollo::common::_PointENU_default_instance_);
}
inline ::apollo::common::PointENU* LocalizationFeature::release_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.position)
  clear_has_position();
  ::apollo::common::PointENU* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::apollo::common::PointENU* LocalizationFeature::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::PointENU>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.position)
  return position_;
}
inline void LocalizationFeature::set_allocated_position(::apollo::common::PointENU* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.position)
}

// optional double heading = 3;
inline bool LocalizationFeature::has_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalizationFeature::set_has_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalizationFeature::clear_has_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalizationFeature::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double LocalizationFeature::heading() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.heading)
  return heading_;
}
inline void LocalizationFeature::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LocalizationFeature.heading)
}

// optional .apollo.common.Point3D linear_velocity = 4;
inline bool LocalizationFeature::has_linear_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalizationFeature::set_has_linear_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalizationFeature::clear_has_linear_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::common::Point3D& LocalizationFeature::_internal_linear_velocity() const {
  return *linear_velocity_;
}
inline const ::apollo::common::Point3D& LocalizationFeature::linear_velocity() const {
  const ::apollo::common::Point3D* p = linear_velocity_;
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.linear_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Point3D*>(
      &::apollo::common::_Point3D_default_instance_);
}
inline ::apollo::common::Point3D* LocalizationFeature::release_linear_velocity() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.linear_velocity)
  clear_has_linear_velocity();
  ::apollo::common::Point3D* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::mutable_linear_velocity() {
  set_has_linear_velocity();
  if (linear_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaNoVirtual());
    linear_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.linear_velocity)
  return linear_velocity_;
}
inline void LocalizationFeature::set_allocated_linear_velocity(::apollo::common::Point3D* linear_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(linear_velocity_);
  }
  if (linear_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_velocity, submessage_arena);
    }
    set_has_linear_velocity();
  } else {
    clear_has_linear_velocity();
  }
  linear_velocity_ = linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.linear_velocity)
}

// optional .apollo.common.Point3D linear_acceleration = 5;
inline bool LocalizationFeature::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalizationFeature::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalizationFeature::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::common::Point3D& LocalizationFeature::_internal_linear_acceleration() const {
  return *linear_acceleration_;
}
inline const ::apollo::common::Point3D& LocalizationFeature::linear_acceleration() const {
  const ::apollo::common::Point3D* p = linear_acceleration_;
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.linear_acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Point3D*>(
      &::apollo::common::_Point3D_default_instance_);
}
inline ::apollo::common::Point3D* LocalizationFeature::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.linear_acceleration)
  clear_has_linear_acceleration();
  ::apollo::common::Point3D* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaNoVirtual());
    linear_acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.linear_acceleration)
  return linear_acceleration_;
}
inline void LocalizationFeature::set_allocated_linear_acceleration(::apollo::common::Point3D* linear_acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(linear_acceleration_);
  }
  if (linear_acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_acceleration, submessage_arena);
    }
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  linear_acceleration_ = linear_acceleration;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.linear_acceleration)
}

// optional .apollo.common.Point3D angular_velocity = 6;
inline bool LocalizationFeature::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalizationFeature::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalizationFeature::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::apollo::common::Point3D& LocalizationFeature::_internal_angular_velocity() const {
  return *angular_velocity_;
}
inline const ::apollo::common::Point3D& LocalizationFeature::angular_velocity() const {
  const ::apollo::common::Point3D* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:apollo.planning.LocalizationFeature.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Point3D*>(
      &::apollo::common::_Point3D_default_instance_);
}
inline ::apollo::common::Point3D* LocalizationFeature::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:apollo.planning.LocalizationFeature.angular_velocity)
  clear_has_angular_velocity();
  ::apollo::common::Point3D* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::apollo::common::Point3D* LocalizationFeature::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaNoVirtual());
    angular_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LocalizationFeature.angular_velocity)
  return angular_velocity_;
}
inline void LocalizationFeature::set_allocated_angular_velocity(::apollo::common::Point3D* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(angular_velocity_);
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LocalizationFeature.angular_velocity)
}

// -------------------------------------------------------------------

// CommonPathPointFeature

// optional double x = 1;
inline bool CommonPathPointFeature::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonPathPointFeature::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonPathPointFeature::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonPathPointFeature::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double CommonPathPointFeature::x() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.x)
  return x_;
}
inline void CommonPathPointFeature::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.x)
}

// optional double y = 2;
inline bool CommonPathPointFeature::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonPathPointFeature::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonPathPointFeature::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonPathPointFeature::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double CommonPathPointFeature::y() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.y)
  return y_;
}
inline void CommonPathPointFeature::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.y)
}

// optional double z = 3;
inline bool CommonPathPointFeature::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonPathPointFeature::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonPathPointFeature::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonPathPointFeature::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double CommonPathPointFeature::z() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.z)
  return z_;
}
inline void CommonPathPointFeature::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.z)
}

// optional double theta = 4;
inline bool CommonPathPointFeature::has_theta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonPathPointFeature::set_has_theta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonPathPointFeature::clear_has_theta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonPathPointFeature::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double CommonPathPointFeature::theta() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.theta)
  return theta_;
}
inline void CommonPathPointFeature::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.theta)
}

// optional double s = 5;
inline bool CommonPathPointFeature::has_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonPathPointFeature::set_has_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonPathPointFeature::clear_has_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonPathPointFeature::clear_s() {
  s_ = 0;
  clear_has_s();
}
inline double CommonPathPointFeature::s() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.s)
  return s_;
}
inline void CommonPathPointFeature::set_s(double value) {
  set_has_s();
  s_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.s)
}

// optional string lane_id = 6;
inline bool CommonPathPointFeature::has_lane_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonPathPointFeature::set_has_lane_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonPathPointFeature::clear_has_lane_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonPathPointFeature::clear_lane_id() {
  lane_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lane_id();
}
inline const ::std::string& CommonPathPointFeature::lane_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonPathPointFeature.lane_id)
  return lane_id_.GetNoArena();
}
inline void CommonPathPointFeature::set_lane_id(const ::std::string& value) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.CommonPathPointFeature.lane_id)
}
#if LANG_CXX11
inline void CommonPathPointFeature::set_lane_id(::std::string&& value) {
  set_has_lane_id();
  lane_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.CommonPathPointFeature.lane_id)
}
#endif
inline void CommonPathPointFeature::set_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.CommonPathPointFeature.lane_id)
}
inline void CommonPathPointFeature::set_lane_id(const char* value, size_t size) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.CommonPathPointFeature.lane_id)
}
inline ::std::string* CommonPathPointFeature::mutable_lane_id() {
  set_has_lane_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CommonPathPointFeature.lane_id)
  return lane_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommonPathPointFeature::release_lane_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.CommonPathPointFeature.lane_id)
  if (!has_lane_id()) {
    return NULL;
  }
  clear_has_lane_id();
  return lane_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommonPathPointFeature::set_allocated_lane_id(::std::string* lane_id) {
  if (lane_id != NULL) {
    set_has_lane_id();
  } else {
    clear_has_lane_id();
  }
  lane_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lane_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CommonPathPointFeature.lane_id)
}

// -------------------------------------------------------------------

// CommonTrajectoryPointFeature

// optional .apollo.planning.CommonPathPointFeature path_point = 1;
inline bool CommonTrajectoryPointFeature::has_path_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonTrajectoryPointFeature::set_has_path_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonTrajectoryPointFeature::clear_has_path_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonTrajectoryPointFeature::clear_path_point() {
  if (path_point_ != NULL) path_point_->Clear();
  clear_has_path_point();
}
inline const ::apollo::planning::CommonPathPointFeature& CommonTrajectoryPointFeature::_internal_path_point() const {
  return *path_point_;
}
inline const ::apollo::planning::CommonPathPointFeature& CommonTrajectoryPointFeature::path_point() const {
  const ::apollo::planning::CommonPathPointFeature* p = path_point_;
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.path_point)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::CommonPathPointFeature*>(
      &::apollo::planning::_CommonPathPointFeature_default_instance_);
}
inline ::apollo::planning::CommonPathPointFeature* CommonTrajectoryPointFeature::release_path_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.CommonTrajectoryPointFeature.path_point)
  clear_has_path_point();
  ::apollo::planning::CommonPathPointFeature* temp = path_point_;
  path_point_ = NULL;
  return temp;
}
inline ::apollo::planning::CommonPathPointFeature* CommonTrajectoryPointFeature::mutable_path_point() {
  set_has_path_point();
  if (path_point_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::CommonPathPointFeature>(GetArenaNoVirtual());
    path_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.CommonTrajectoryPointFeature.path_point)
  return path_point_;
}
inline void CommonTrajectoryPointFeature::set_allocated_path_point(::apollo::planning::CommonPathPointFeature* path_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_point_;
  }
  if (path_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path_point, submessage_arena);
    }
    set_has_path_point();
  } else {
    clear_has_path_point();
  }
  path_point_ = path_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CommonTrajectoryPointFeature.path_point)
}

// optional double v = 2;
inline bool CommonTrajectoryPointFeature::has_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonTrajectoryPointFeature::set_has_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonTrajectoryPointFeature::clear_has_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonTrajectoryPointFeature::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double CommonTrajectoryPointFeature::v() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.v)
  return v_;
}
inline void CommonTrajectoryPointFeature::set_v(double value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonTrajectoryPointFeature.v)
}

// optional double a = 3;
inline bool CommonTrajectoryPointFeature::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonTrajectoryPointFeature::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonTrajectoryPointFeature::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonTrajectoryPointFeature::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline double CommonTrajectoryPointFeature::a() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.a)
  return a_;
}
inline void CommonTrajectoryPointFeature::set_a(double value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonTrajectoryPointFeature.a)
}

// optional double relative_time = 4;
inline bool CommonTrajectoryPointFeature::has_relative_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonTrajectoryPointFeature::set_has_relative_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonTrajectoryPointFeature::clear_has_relative_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonTrajectoryPointFeature::clear_relative_time() {
  relative_time_ = 0;
  clear_has_relative_time();
}
inline double CommonTrajectoryPointFeature::relative_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.relative_time)
  return relative_time_;
}
inline void CommonTrajectoryPointFeature::set_relative_time(double value) {
  set_has_relative_time();
  relative_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CommonTrajectoryPointFeature.relative_time)
}

// optional .apollo.common.GaussianInfo gaussian_info = 5;
inline bool CommonTrajectoryPointFeature::has_gaussian_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonTrajectoryPointFeature::set_has_gaussian_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonTrajectoryPointFeature::clear_has_gaussian_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::common::GaussianInfo& CommonTrajectoryPointFeature::_internal_gaussian_info() const {
  return *gaussian_info_;
}
inline const ::apollo::common::GaussianInfo& CommonTrajectoryPointFeature::gaussian_info() const {
  const ::apollo::common::GaussianInfo* p = gaussian_info_;
  // @@protoc_insertion_point(field_get:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::GaussianInfo*>(
      &::apollo::common::_GaussianInfo_default_instance_);
}
inline ::apollo::common::GaussianInfo* CommonTrajectoryPointFeature::release_gaussian_info() {
  // @@protoc_insertion_point(field_release:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
  clear_has_gaussian_info();
  ::apollo::common::GaussianInfo* temp = gaussian_info_;
  gaussian_info_ = NULL;
  return temp;
}
inline ::apollo::common::GaussianInfo* CommonTrajectoryPointFeature::mutable_gaussian_info() {
  set_has_gaussian_info();
  if (gaussian_info_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::GaussianInfo>(GetArenaNoVirtual());
    gaussian_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
  return gaussian_info_;
}
inline void CommonTrajectoryPointFeature::set_allocated_gaussian_info(::apollo::common::GaussianInfo* gaussian_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(gaussian_info_);
  }
  if (gaussian_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gaussian_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gaussian_info, submessage_arena);
    }
    set_has_gaussian_info();
  } else {
    clear_has_gaussian_info();
  }
  gaussian_info_ = gaussian_info;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CommonTrajectoryPointFeature.gaussian_info)
}

// -------------------------------------------------------------------

// TrajectoryPointFeature

// optional double timestamp_sec = 1;
inline bool TrajectoryPointFeature::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrajectoryPointFeature::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrajectoryPointFeature::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrajectoryPointFeature::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double TrajectoryPointFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrajectoryPointFeature.timestamp_sec)
  return timestamp_sec_;
}
inline void TrajectoryPointFeature::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrajectoryPointFeature.timestamp_sec)
}

// optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 2;
inline bool TrajectoryPointFeature::has_trajectory_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrajectoryPointFeature::set_has_trajectory_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrajectoryPointFeature::clear_has_trajectory_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrajectoryPointFeature::clear_trajectory_point() {
  if (trajectory_point_ != NULL) trajectory_point_->Clear();
  clear_has_trajectory_point();
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& TrajectoryPointFeature::_internal_trajectory_point() const {
  return *trajectory_point_;
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& TrajectoryPointFeature::trajectory_point() const {
  const ::apollo::planning::CommonTrajectoryPointFeature* p = trajectory_point_;
  // @@protoc_insertion_point(field_get:apollo.planning.TrajectoryPointFeature.trajectory_point)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::CommonTrajectoryPointFeature*>(
      &::apollo::planning::_CommonTrajectoryPointFeature_default_instance_);
}
inline ::apollo::planning::CommonTrajectoryPointFeature* TrajectoryPointFeature::release_trajectory_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrajectoryPointFeature.trajectory_point)
  clear_has_trajectory_point();
  ::apollo::planning::CommonTrajectoryPointFeature* temp = trajectory_point_;
  trajectory_point_ = NULL;
  return temp;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* TrajectoryPointFeature::mutable_trajectory_point() {
  set_has_trajectory_point();
  if (trajectory_point_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::CommonTrajectoryPointFeature>(GetArenaNoVirtual());
    trajectory_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrajectoryPointFeature.trajectory_point)
  return trajectory_point_;
}
inline void TrajectoryPointFeature::set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_point_;
  }
  if (trajectory_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_point, submessage_arena);
    }
    set_has_trajectory_point();
  } else {
    clear_has_trajectory_point();
  }
  trajectory_point_ = trajectory_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrajectoryPointFeature.trajectory_point)
}

// -------------------------------------------------------------------

// PerceptionObstacleFeature

// optional double timestamp_sec = 1;
inline bool PerceptionObstacleFeature::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerceptionObstacleFeature::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerceptionObstacleFeature::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerceptionObstacleFeature::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double PerceptionObstacleFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.timestamp_sec)
  return timestamp_sec_;
}
inline void PerceptionObstacleFeature::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PerceptionObstacleFeature.timestamp_sec)
}

// optional .apollo.common.Point3D position = 2;
inline bool PerceptionObstacleFeature::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerceptionObstacleFeature::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerceptionObstacleFeature::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_position() const {
  return *position_;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::position() const {
  const ::apollo::common::Point3D* p = position_;
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.position)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Point3D*>(
      &::apollo::common::_Point3D_default_instance_);
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::release_position() {
  // @@protoc_insertion_point(field_release:apollo.planning.PerceptionObstacleFeature.position)
  clear_has_position();
  ::apollo::common::Point3D* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.position)
  return position_;
}
inline void PerceptionObstacleFeature::set_allocated_position(::apollo::common::Point3D* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PerceptionObstacleFeature.position)
}

// optional double theta = 3;
inline bool PerceptionObstacleFeature::has_theta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PerceptionObstacleFeature::set_has_theta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PerceptionObstacleFeature::clear_has_theta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PerceptionObstacleFeature::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double PerceptionObstacleFeature::theta() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.theta)
  return theta_;
}
inline void PerceptionObstacleFeature::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PerceptionObstacleFeature.theta)
}

// optional .apollo.common.Point3D velocity = 4;
inline bool PerceptionObstacleFeature::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerceptionObstacleFeature::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerceptionObstacleFeature::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_velocity() const {
  return *velocity_;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::velocity() const {
  const ::apollo::common::Point3D* p = velocity_;
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Point3D*>(
      &::apollo::common::_Point3D_default_instance_);
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::release_velocity() {
  // @@protoc_insertion_point(field_release:apollo.planning.PerceptionObstacleFeature.velocity)
  clear_has_velocity();
  ::apollo::common::Point3D* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.velocity)
  return velocity_;
}
inline void PerceptionObstacleFeature::set_allocated_velocity(::apollo::common::Point3D* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(velocity_);
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PerceptionObstacleFeature.velocity)
}

// optional .apollo.common.Point3D acceleration = 5;
inline bool PerceptionObstacleFeature::has_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerceptionObstacleFeature::set_has_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerceptionObstacleFeature::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::_internal_acceleration() const {
  return *acceleration_;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::acceleration() const {
  const ::apollo::common::Point3D* p = acceleration_;
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Point3D*>(
      &::apollo::common::_Point3D_default_instance_);
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::release_acceleration() {
  // @@protoc_insertion_point(field_release:apollo.planning.PerceptionObstacleFeature.acceleration)
  clear_has_acceleration();
  ::apollo::common::Point3D* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Point3D>(GetArenaNoVirtual());
    acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.acceleration)
  return acceleration_;
}
inline void PerceptionObstacleFeature::set_allocated_acceleration(::apollo::common::Point3D* acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(acceleration_);
  }
  if (acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PerceptionObstacleFeature.acceleration)
}

// repeated .apollo.common.Point3D polygon_point = 6;
inline int PerceptionObstacleFeature::polygon_point_size() const {
  return polygon_point_.size();
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::mutable_polygon_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::common::Point3D >*
PerceptionObstacleFeature::mutable_polygon_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return &polygon_point_;
}
inline const ::apollo::common::Point3D& PerceptionObstacleFeature::polygon_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_.Get(index);
}
inline ::apollo::common::Point3D* PerceptionObstacleFeature::add_polygon_point() {
  // @@protoc_insertion_point(field_add:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::common::Point3D >&
PerceptionObstacleFeature::polygon_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PerceptionObstacleFeature.polygon_point)
  return polygon_point_;
}

// -------------------------------------------------------------------

// ObstacleTrajectoryFeature

// repeated .apollo.planning.PerceptionObstacleFeature perception_obstacle_history = 1;
inline int ObstacleTrajectoryFeature::perception_obstacle_history_size() const {
  return perception_obstacle_history_.size();
}
inline void ObstacleTrajectoryFeature::clear_perception_obstacle_history() {
  perception_obstacle_history_.Clear();
}
inline ::apollo::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::mutable_perception_obstacle_history(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >*
ObstacleTrajectoryFeature::mutable_perception_obstacle_history() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return &perception_obstacle_history_;
}
inline const ::apollo::planning::PerceptionObstacleFeature& ObstacleTrajectoryFeature::perception_obstacle_history(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_.Get(index);
}
inline ::apollo::planning::PerceptionObstacleFeature* ObstacleTrajectoryFeature::add_perception_obstacle_history() {
  // @@protoc_insertion_point(field_add:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::PerceptionObstacleFeature >&
ObstacleTrajectoryFeature::perception_obstacle_history() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ObstacleTrajectoryFeature.perception_obstacle_history)
  return perception_obstacle_history_;
}

// repeated .apollo.planning.TrajectoryPointFeature evaluated_trajectory_point = 2;
inline int ObstacleTrajectoryFeature::evaluated_trajectory_point_size() const {
  return evaluated_trajectory_point_.size();
}
inline void ObstacleTrajectoryFeature::clear_evaluated_trajectory_point() {
  evaluated_trajectory_point_.Clear();
}
inline ::apollo::planning::TrajectoryPointFeature* ObstacleTrajectoryFeature::mutable_evaluated_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
ObstacleTrajectoryFeature::mutable_evaluated_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return &evaluated_trajectory_point_;
}
inline const ::apollo::planning::TrajectoryPointFeature& ObstacleTrajectoryFeature::evaluated_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_.Get(index);
}
inline ::apollo::planning::TrajectoryPointFeature* ObstacleTrajectoryFeature::add_evaluated_trajectory_point() {
  // @@protoc_insertion_point(field_add:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
ObstacleTrajectoryFeature::evaluated_trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ObstacleTrajectoryFeature.evaluated_trajectory_point)
  return evaluated_trajectory_point_;
}

// -------------------------------------------------------------------

// PredictionTrajectoryFeature

// optional double probability = 1;
inline bool PredictionTrajectoryFeature::has_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredictionTrajectoryFeature::set_has_probability() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredictionTrajectoryFeature::clear_has_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PredictionTrajectoryFeature::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline double PredictionTrajectoryFeature::probability() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionTrajectoryFeature.probability)
  return probability_;
}
inline void PredictionTrajectoryFeature::set_probability(double value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionTrajectoryFeature.probability)
}

// repeated .apollo.planning.TrajectoryPointFeature trajectory_point = 2;
inline int PredictionTrajectoryFeature::trajectory_point_size() const {
  return trajectory_point_.size();
}
inline void PredictionTrajectoryFeature::clear_trajectory_point() {
  trajectory_point_.Clear();
}
inline ::apollo::planning::TrajectoryPointFeature* PredictionTrajectoryFeature::mutable_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
PredictionTrajectoryFeature::mutable_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return &trajectory_point_;
}
inline const ::apollo::planning::TrajectoryPointFeature& PredictionTrajectoryFeature::trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_.Get(index);
}
inline ::apollo::planning::TrajectoryPointFeature* PredictionTrajectoryFeature::add_trajectory_point() {
  // @@protoc_insertion_point(field_add:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
PredictionTrajectoryFeature::trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PredictionTrajectoryFeature.trajectory_point)
  return trajectory_point_;
}

// -------------------------------------------------------------------

// PredictionObstacleFeature

// optional double timestamp_sec = 1;
inline bool PredictionObstacleFeature::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PredictionObstacleFeature::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PredictionObstacleFeature::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PredictionObstacleFeature::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double PredictionObstacleFeature::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.timestamp_sec)
  return timestamp_sec_;
}
inline void PredictionObstacleFeature::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionObstacleFeature.timestamp_sec)
}

// optional double predicted_period = 2;
inline bool PredictionObstacleFeature::has_predicted_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PredictionObstacleFeature::set_has_predicted_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PredictionObstacleFeature::clear_has_predicted_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PredictionObstacleFeature::clear_predicted_period() {
  predicted_period_ = 0;
  clear_has_predicted_period();
}
inline double PredictionObstacleFeature::predicted_period() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.predicted_period)
  return predicted_period_;
}
inline void PredictionObstacleFeature::set_predicted_period(double value) {
  set_has_predicted_period();
  predicted_period_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionObstacleFeature.predicted_period)
}

// optional .apollo.prediction.ObstacleIntent intent = 3;
inline bool PredictionObstacleFeature::has_intent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PredictionObstacleFeature::set_has_intent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PredictionObstacleFeature::clear_has_intent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::prediction::ObstacleIntent& PredictionObstacleFeature::_internal_intent() const {
  return *intent_;
}
inline const ::apollo::prediction::ObstacleIntent& PredictionObstacleFeature::intent() const {
  const ::apollo::prediction::ObstacleIntent* p = intent_;
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.intent)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::prediction::ObstacleIntent*>(
      &::apollo::prediction::_ObstacleIntent_default_instance_);
}
inline ::apollo::prediction::ObstacleIntent* PredictionObstacleFeature::release_intent() {
  // @@protoc_insertion_point(field_release:apollo.planning.PredictionObstacleFeature.intent)
  clear_has_intent();
  ::apollo::prediction::ObstacleIntent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline ::apollo::prediction::ObstacleIntent* PredictionObstacleFeature::mutable_intent() {
  set_has_intent();
  if (intent_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::prediction::ObstacleIntent>(GetArenaNoVirtual());
    intent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionObstacleFeature.intent)
  return intent_;
}
inline void PredictionObstacleFeature::set_allocated_intent(::apollo::prediction::ObstacleIntent* intent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(intent_);
  }
  if (intent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intent, submessage_arena);
    }
    set_has_intent();
  } else {
    clear_has_intent();
  }
  intent_ = intent;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PredictionObstacleFeature.intent)
}

// optional .apollo.prediction.ObstaclePriority priority = 4;
inline bool PredictionObstacleFeature::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PredictionObstacleFeature::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PredictionObstacleFeature::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::prediction::ObstaclePriority& PredictionObstacleFeature::_internal_priority() const {
  return *priority_;
}
inline const ::apollo::prediction::ObstaclePriority& PredictionObstacleFeature::priority() const {
  const ::apollo::prediction::ObstaclePriority* p = priority_;
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.priority)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::prediction::ObstaclePriority*>(
      &::apollo::prediction::_ObstaclePriority_default_instance_);
}
inline ::apollo::prediction::ObstaclePriority* PredictionObstacleFeature::release_priority() {
  // @@protoc_insertion_point(field_release:apollo.planning.PredictionObstacleFeature.priority)
  clear_has_priority();
  ::apollo::prediction::ObstaclePriority* temp = priority_;
  priority_ = NULL;
  return temp;
}
inline ::apollo::prediction::ObstaclePriority* PredictionObstacleFeature::mutable_priority() {
  set_has_priority();
  if (priority_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::prediction::ObstaclePriority>(GetArenaNoVirtual());
    priority_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionObstacleFeature.priority)
  return priority_;
}
inline void PredictionObstacleFeature::set_allocated_priority(::apollo::prediction::ObstaclePriority* priority) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(priority_);
  }
  if (priority) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      priority = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    set_has_priority();
  } else {
    clear_has_priority();
  }
  priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PredictionObstacleFeature.priority)
}

// optional bool is_static = 5 [default = false];
inline bool PredictionObstacleFeature::has_is_static() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PredictionObstacleFeature::set_has_is_static() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PredictionObstacleFeature::clear_has_is_static() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PredictionObstacleFeature::clear_is_static() {
  is_static_ = false;
  clear_has_is_static();
}
inline bool PredictionObstacleFeature::is_static() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.is_static)
  return is_static_;
}
inline void PredictionObstacleFeature::set_is_static(bool value) {
  set_has_is_static();
  is_static_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PredictionObstacleFeature.is_static)
}

// repeated .apollo.planning.PredictionTrajectoryFeature trajectory = 6;
inline int PredictionObstacleFeature::trajectory_size() const {
  return trajectory_.size();
}
inline void PredictionObstacleFeature::clear_trajectory() {
  trajectory_.Clear();
}
inline ::apollo::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PredictionObstacleFeature.trajectory)
  return trajectory_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >*
PredictionObstacleFeature::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PredictionObstacleFeature.trajectory)
  return &trajectory_;
}
inline const ::apollo::planning::PredictionTrajectoryFeature& PredictionObstacleFeature::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PredictionObstacleFeature.trajectory)
  return trajectory_.Get(index);
}
inline ::apollo::planning::PredictionTrajectoryFeature* PredictionObstacleFeature::add_trajectory() {
  // @@protoc_insertion_point(field_add:apollo.planning.PredictionObstacleFeature.trajectory)
  return trajectory_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::PredictionTrajectoryFeature >&
PredictionObstacleFeature::trajectory() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PredictionObstacleFeature.trajectory)
  return trajectory_;
}

// -------------------------------------------------------------------

// ObstacleFeature

// optional int32 id = 1;
inline bool ObstacleFeature::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObstacleFeature::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObstacleFeature::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObstacleFeature::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ObstacleFeature::id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.id)
  return id_;
}
inline void ObstacleFeature::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.id)
}

// optional double length = 2;
inline bool ObstacleFeature::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleFeature::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleFeature::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleFeature::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double ObstacleFeature::length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.length)
  return length_;
}
inline void ObstacleFeature::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.length)
}

// optional double width = 3;
inline bool ObstacleFeature::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObstacleFeature::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObstacleFeature::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObstacleFeature::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double ObstacleFeature::width() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.width)
  return width_;
}
inline void ObstacleFeature::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.width)
}

// optional double height = 4;
inline bool ObstacleFeature::has_height() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObstacleFeature::set_has_height() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObstacleFeature::clear_has_height() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObstacleFeature::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double ObstacleFeature::height() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.height)
  return height_;
}
inline void ObstacleFeature::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.height)
}

// optional .apollo.perception.PerceptionObstacle.Type type = 5;
inline bool ObstacleFeature::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObstacleFeature::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObstacleFeature::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObstacleFeature::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::apollo::perception::PerceptionObstacle_Type ObstacleFeature::type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.type)
  return static_cast< ::apollo::perception::PerceptionObstacle_Type >(type_);
}
inline void ObstacleFeature::set_type(::apollo::perception::PerceptionObstacle_Type value) {
  assert(::apollo::perception::PerceptionObstacle_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ObstacleFeature.type)
}

// optional .apollo.planning.ObstacleTrajectoryFeature obstacle_trajectory = 6;
inline bool ObstacleFeature::has_obstacle_trajectory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleFeature::set_has_obstacle_trajectory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleFeature::clear_has_obstacle_trajectory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleFeature::clear_obstacle_trajectory() {
  if (obstacle_trajectory_ != NULL) obstacle_trajectory_->Clear();
  clear_has_obstacle_trajectory();
}
inline const ::apollo::planning::ObstacleTrajectoryFeature& ObstacleFeature::_internal_obstacle_trajectory() const {
  return *obstacle_trajectory_;
}
inline const ::apollo::planning::ObstacleTrajectoryFeature& ObstacleFeature::obstacle_trajectory() const {
  const ::apollo::planning::ObstacleTrajectoryFeature* p = obstacle_trajectory_;
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.obstacle_trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::ObstacleTrajectoryFeature*>(
      &::apollo::planning::_ObstacleTrajectoryFeature_default_instance_);
}
inline ::apollo::planning::ObstacleTrajectoryFeature* ObstacleFeature::release_obstacle_trajectory() {
  // @@protoc_insertion_point(field_release:apollo.planning.ObstacleFeature.obstacle_trajectory)
  clear_has_obstacle_trajectory();
  ::apollo::planning::ObstacleTrajectoryFeature* temp = obstacle_trajectory_;
  obstacle_trajectory_ = NULL;
  return temp;
}
inline ::apollo::planning::ObstacleTrajectoryFeature* ObstacleFeature::mutable_obstacle_trajectory() {
  set_has_obstacle_trajectory();
  if (obstacle_trajectory_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::ObstacleTrajectoryFeature>(GetArenaNoVirtual());
    obstacle_trajectory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleFeature.obstacle_trajectory)
  return obstacle_trajectory_;
}
inline void ObstacleFeature::set_allocated_obstacle_trajectory(::apollo::planning::ObstacleTrajectoryFeature* obstacle_trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obstacle_trajectory_;
  }
  if (obstacle_trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obstacle_trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obstacle_trajectory, submessage_arena);
    }
    set_has_obstacle_trajectory();
  } else {
    clear_has_obstacle_trajectory();
  }
  obstacle_trajectory_ = obstacle_trajectory;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ObstacleFeature.obstacle_trajectory)
}

// optional .apollo.planning.PredictionObstacleFeature obstacle_prediction = 7;
inline bool ObstacleFeature::has_obstacle_prediction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObstacleFeature::set_has_obstacle_prediction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObstacleFeature::clear_has_obstacle_prediction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObstacleFeature::clear_obstacle_prediction() {
  if (obstacle_prediction_ != NULL) obstacle_prediction_->Clear();
  clear_has_obstacle_prediction();
}
inline const ::apollo::planning::PredictionObstacleFeature& ObstacleFeature::_internal_obstacle_prediction() const {
  return *obstacle_prediction_;
}
inline const ::apollo::planning::PredictionObstacleFeature& ObstacleFeature::obstacle_prediction() const {
  const ::apollo::planning::PredictionObstacleFeature* p = obstacle_prediction_;
  // @@protoc_insertion_point(field_get:apollo.planning.ObstacleFeature.obstacle_prediction)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::PredictionObstacleFeature*>(
      &::apollo::planning::_PredictionObstacleFeature_default_instance_);
}
inline ::apollo::planning::PredictionObstacleFeature* ObstacleFeature::release_obstacle_prediction() {
  // @@protoc_insertion_point(field_release:apollo.planning.ObstacleFeature.obstacle_prediction)
  clear_has_obstacle_prediction();
  ::apollo::planning::PredictionObstacleFeature* temp = obstacle_prediction_;
  obstacle_prediction_ = NULL;
  return temp;
}
inline ::apollo::planning::PredictionObstacleFeature* ObstacleFeature::mutable_obstacle_prediction() {
  set_has_obstacle_prediction();
  if (obstacle_prediction_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::PredictionObstacleFeature>(GetArenaNoVirtual());
    obstacle_prediction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ObstacleFeature.obstacle_prediction)
  return obstacle_prediction_;
}
inline void ObstacleFeature::set_allocated_obstacle_prediction(::apollo::planning::PredictionObstacleFeature* obstacle_prediction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obstacle_prediction_;
  }
  if (obstacle_prediction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obstacle_prediction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obstacle_prediction, submessage_arena);
    }
    set_has_obstacle_prediction();
  } else {
    clear_has_obstacle_prediction();
  }
  obstacle_prediction_ = obstacle_prediction;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ObstacleFeature.obstacle_prediction)
}

// -------------------------------------------------------------------

// RoutingResponseFeature

// repeated .apollo.routing.RoadSegment road = 1;
inline int RoutingResponseFeature::road_size() const {
  return road_.size();
}
inline ::apollo::routing::RoadSegment* RoutingResponseFeature::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingResponseFeature.road)
  return road_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::routing::RoadSegment >*
RoutingResponseFeature::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.RoutingResponseFeature.road)
  return &road_;
}
inline const ::apollo::routing::RoadSegment& RoutingResponseFeature::road(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingResponseFeature.road)
  return road_.Get(index);
}
inline ::apollo::routing::RoadSegment* RoutingResponseFeature::add_road() {
  // @@protoc_insertion_point(field_add:apollo.planning.RoutingResponseFeature.road)
  return road_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::routing::RoadSegment >&
RoutingResponseFeature::road() const {
  // @@protoc_insertion_point(field_list:apollo.planning.RoutingResponseFeature.road)
  return road_;
}

// optional .apollo.routing.Measurement measurement = 2;
inline bool RoutingResponseFeature::has_measurement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingResponseFeature::set_has_measurement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingResponseFeature::clear_has_measurement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::routing::Measurement& RoutingResponseFeature::_internal_measurement() const {
  return *measurement_;
}
inline const ::apollo::routing::Measurement& RoutingResponseFeature::measurement() const {
  const ::apollo::routing::Measurement* p = measurement_;
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingResponseFeature.measurement)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::routing::Measurement*>(
      &::apollo::routing::_Measurement_default_instance_);
}
inline ::apollo::routing::Measurement* RoutingResponseFeature::release_measurement() {
  // @@protoc_insertion_point(field_release:apollo.planning.RoutingResponseFeature.measurement)
  clear_has_measurement();
  ::apollo::routing::Measurement* temp = measurement_;
  measurement_ = NULL;
  return temp;
}
inline ::apollo::routing::Measurement* RoutingResponseFeature::mutable_measurement() {
  set_has_measurement();
  if (measurement_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::routing::Measurement>(GetArenaNoVirtual());
    measurement_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingResponseFeature.measurement)
  return measurement_;
}
inline void RoutingResponseFeature::set_allocated_measurement(::apollo::routing::Measurement* measurement) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(measurement_);
  }
  if (measurement) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      measurement = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, measurement, submessage_arena);
    }
    set_has_measurement();
  } else {
    clear_has_measurement();
  }
  measurement_ = measurement;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.RoutingResponseFeature.measurement)
}

// -------------------------------------------------------------------

// RoutingFeature

// optional .apollo.planning.RoutingResponseFeature routing_response = 1;
inline bool RoutingFeature::has_routing_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingFeature::set_has_routing_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingFeature::clear_has_routing_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingFeature::clear_routing_response() {
  if (routing_response_ != NULL) routing_response_->Clear();
  clear_has_routing_response();
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::_internal_routing_response() const {
  return *routing_response_;
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::routing_response() const {
  const ::apollo::planning::RoutingResponseFeature* p = routing_response_;
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingFeature.routing_response)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::RoutingResponseFeature*>(
      &::apollo::planning::_RoutingResponseFeature_default_instance_);
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::release_routing_response() {
  // @@protoc_insertion_point(field_release:apollo.planning.RoutingFeature.routing_response)
  clear_has_routing_response();
  ::apollo::planning::RoutingResponseFeature* temp = routing_response_;
  routing_response_ = NULL;
  return temp;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::mutable_routing_response() {
  set_has_routing_response();
  if (routing_response_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::RoutingResponseFeature>(GetArenaNoVirtual());
    routing_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingFeature.routing_response)
  return routing_response_;
}
inline void RoutingFeature::set_allocated_routing_response(::apollo::planning::RoutingResponseFeature* routing_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete routing_response_;
  }
  if (routing_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      routing_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, routing_response, submessage_arena);
    }
    set_has_routing_response();
  } else {
    clear_has_routing_response();
  }
  routing_response_ = routing_response;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.RoutingFeature.routing_response)
}

// repeated string local_routing_lane_id = 2;
inline int RoutingFeature::local_routing_lane_id_size() const {
  return local_routing_lane_id_.size();
}
inline void RoutingFeature::clear_local_routing_lane_id() {
  local_routing_lane_id_.Clear();
}
inline const ::std::string& RoutingFeature::local_routing_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_.Get(index);
}
inline ::std::string* RoutingFeature::mutable_local_routing_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_.Mutable(index);
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.RoutingFeature.local_routing_lane_id)
  local_routing_lane_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RoutingFeature::set_local_routing_lane_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.RoutingFeature.local_routing_lane_id)
  local_routing_lane_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RoutingFeature::set_local_routing_lane_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_routing_lane_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::set_local_routing_lane_id(int index, const char* value, size_t size) {
  local_routing_lane_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline ::std::string* RoutingFeature::add_local_routing_lane_id() {
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_.Add();
}
inline void RoutingFeature::add_local_routing_lane_id(const ::std::string& value) {
  local_routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.RoutingFeature.local_routing_lane_id)
}
#if LANG_CXX11
inline void RoutingFeature::add_local_routing_lane_id(::std::string&& value) {
  local_routing_lane_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.planning.RoutingFeature.local_routing_lane_id)
}
#endif
inline void RoutingFeature::add_local_routing_lane_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_routing_lane_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline void RoutingFeature::add_local_routing_lane_id(const char* value, size_t size) {
  local_routing_lane_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.RoutingFeature.local_routing_lane_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RoutingFeature::local_routing_lane_id() const {
  // @@protoc_insertion_point(field_list:apollo.planning.RoutingFeature.local_routing_lane_id)
  return local_routing_lane_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RoutingFeature::mutable_local_routing_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.RoutingFeature.local_routing_lane_id)
  return &local_routing_lane_id_;
}

// optional .apollo.planning.RoutingResponseFeature local_routing = 3;
inline bool RoutingFeature::has_local_routing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingFeature::set_has_local_routing() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingFeature::clear_has_local_routing() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingFeature::clear_local_routing() {
  if (local_routing_ != NULL) local_routing_->Clear();
  clear_has_local_routing();
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::_internal_local_routing() const {
  return *local_routing_;
}
inline const ::apollo::planning::RoutingResponseFeature& RoutingFeature::local_routing() const {
  const ::apollo::planning::RoutingResponseFeature* p = local_routing_;
  // @@protoc_insertion_point(field_get:apollo.planning.RoutingFeature.local_routing)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::RoutingResponseFeature*>(
      &::apollo::planning::_RoutingResponseFeature_default_instance_);
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::release_local_routing() {
  // @@protoc_insertion_point(field_release:apollo.planning.RoutingFeature.local_routing)
  clear_has_local_routing();
  ::apollo::planning::RoutingResponseFeature* temp = local_routing_;
  local_routing_ = NULL;
  return temp;
}
inline ::apollo::planning::RoutingResponseFeature* RoutingFeature::mutable_local_routing() {
  set_has_local_routing();
  if (local_routing_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::RoutingResponseFeature>(GetArenaNoVirtual());
    local_routing_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.RoutingFeature.local_routing)
  return local_routing_;
}
inline void RoutingFeature::set_allocated_local_routing(::apollo::planning::RoutingResponseFeature* local_routing) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete local_routing_;
  }
  if (local_routing) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_routing = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_routing, submessage_arena);
    }
    set_has_local_routing();
  } else {
    clear_has_local_routing();
  }
  local_routing_ = local_routing;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.RoutingFeature.local_routing)
}

// -------------------------------------------------------------------

// TrafficLightFeature

// optional .apollo.perception.TrafficLight.Color color = 1;
inline bool TrafficLightFeature::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightFeature::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightFeature::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightFeature::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::apollo::perception::TrafficLight_Color TrafficLightFeature::color() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.color)
  return static_cast< ::apollo::perception::TrafficLight_Color >(color_);
}
inline void TrafficLightFeature::set_color(::apollo::perception::TrafficLight_Color value) {
  assert(::apollo::perception::TrafficLight_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.color)
}

// optional string id = 2;
inline bool TrafficLightFeature::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightFeature::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightFeature::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightFeature::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& TrafficLightFeature::id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.id)
  return id_.GetNoArena();
}
inline void TrafficLightFeature::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.id)
}
#if LANG_CXX11
inline void TrafficLightFeature::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TrafficLightFeature.id)
}
#endif
inline void TrafficLightFeature::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TrafficLightFeature.id)
}
inline void TrafficLightFeature::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TrafficLightFeature.id)
}
inline ::std::string* TrafficLightFeature::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightFeature.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrafficLightFeature::release_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficLightFeature.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrafficLightFeature::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficLightFeature.id)
}

// optional double confidence = 3 [default = 1];
inline bool TrafficLightFeature::has_confidence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficLightFeature::set_has_confidence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficLightFeature::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficLightFeature::clear_confidence() {
  confidence_ = 1;
  clear_has_confidence();
}
inline double TrafficLightFeature::confidence() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.confidence)
  return confidence_;
}
inline void TrafficLightFeature::set_confidence(double value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.confidence)
}

// optional double tracking_time = 4;
inline bool TrafficLightFeature::has_tracking_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightFeature::set_has_tracking_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightFeature::clear_has_tracking_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightFeature::clear_tracking_time() {
  tracking_time_ = 0;
  clear_has_tracking_time();
}
inline double TrafficLightFeature::tracking_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.tracking_time)
  return tracking_time_;
}
inline void TrafficLightFeature::set_tracking_time(double value) {
  set_has_tracking_time();
  tracking_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.tracking_time)
}

// optional bool blink = 5;
inline bool TrafficLightFeature::has_blink() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightFeature::set_has_blink() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightFeature::clear_has_blink() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightFeature::clear_blink() {
  blink_ = false;
  clear_has_blink();
}
inline bool TrafficLightFeature::blink() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.blink)
  return blink_;
}
inline void TrafficLightFeature::set_blink(bool value) {
  set_has_blink();
  blink_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.blink)
}

// optional double remaining_time = 6;
inline bool TrafficLightFeature::has_remaining_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightFeature::set_has_remaining_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightFeature::clear_has_remaining_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightFeature::clear_remaining_time() {
  remaining_time_ = 0;
  clear_has_remaining_time();
}
inline double TrafficLightFeature::remaining_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightFeature.remaining_time)
  return remaining_time_;
}
inline void TrafficLightFeature::set_remaining_time(double value) {
  set_has_remaining_time();
  remaining_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightFeature.remaining_time)
}

// -------------------------------------------------------------------

// TrafficLightDetectionFeature

// optional double message_timestamp_sec = 1;
inline bool TrafficLightDetectionFeature::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightDetectionFeature::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightDetectionFeature::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightDetectionFeature::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double TrafficLightDetectionFeature::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightDetectionFeature.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void TrafficLightDetectionFeature::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightDetectionFeature.message_timestamp_sec)
}

// repeated .apollo.planning.TrafficLightFeature traffic_light = 2;
inline int TrafficLightDetectionFeature::traffic_light_size() const {
  return traffic_light_.size();
}
inline void TrafficLightDetectionFeature::clear_traffic_light() {
  traffic_light_.Clear();
}
inline ::apollo::planning::TrafficLightFeature* TrafficLightDetectionFeature::mutable_traffic_light(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >*
TrafficLightDetectionFeature::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return &traffic_light_;
}
inline const ::apollo::planning::TrafficLightFeature& TrafficLightDetectionFeature::traffic_light(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_.Get(index);
}
inline ::apollo::planning::TrafficLightFeature* TrafficLightDetectionFeature::add_traffic_light() {
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficLightFeature >&
TrafficLightDetectionFeature::traffic_light() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficLightDetectionFeature.traffic_light)
  return traffic_light_;
}

// -------------------------------------------------------------------

// ADCTrajectoryPoint

// optional double timestamp_sec = 1;
inline bool ADCTrajectoryPoint::has_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ADCTrajectoryPoint::set_has_timestamp_sec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ADCTrajectoryPoint::clear_has_timestamp_sec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ADCTrajectoryPoint::clear_timestamp_sec() {
  timestamp_sec_ = 0;
  clear_has_timestamp_sec();
}
inline double ADCTrajectoryPoint::timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ADCTrajectoryPoint.timestamp_sec)
  return timestamp_sec_;
}
inline void ADCTrajectoryPoint::set_timestamp_sec(double value) {
  set_has_timestamp_sec();
  timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ADCTrajectoryPoint.timestamp_sec)
}

// optional .apollo.planning.PlanningTag planning_tag = 2;
inline bool ADCTrajectoryPoint::has_planning_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADCTrajectoryPoint::set_has_planning_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ADCTrajectoryPoint::clear_has_planning_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ADCTrajectoryPoint::clear_planning_tag() {
  if (planning_tag_ != NULL) planning_tag_->Clear();
  clear_has_planning_tag();
}
inline const ::apollo::planning::PlanningTag& ADCTrajectoryPoint::_internal_planning_tag() const {
  return *planning_tag_;
}
inline const ::apollo::planning::PlanningTag& ADCTrajectoryPoint::planning_tag() const {
  const ::apollo::planning::PlanningTag* p = planning_tag_;
  // @@protoc_insertion_point(field_get:apollo.planning.ADCTrajectoryPoint.planning_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::PlanningTag*>(
      &::apollo::planning::_PlanningTag_default_instance_);
}
inline ::apollo::planning::PlanningTag* ADCTrajectoryPoint::release_planning_tag() {
  // @@protoc_insertion_point(field_release:apollo.planning.ADCTrajectoryPoint.planning_tag)
  clear_has_planning_tag();
  ::apollo::planning::PlanningTag* temp = planning_tag_;
  planning_tag_ = NULL;
  return temp;
}
inline ::apollo::planning::PlanningTag* ADCTrajectoryPoint::mutable_planning_tag() {
  set_has_planning_tag();
  if (planning_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlanningTag>(GetArenaNoVirtual());
    planning_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ADCTrajectoryPoint.planning_tag)
  return planning_tag_;
}
inline void ADCTrajectoryPoint::set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete planning_tag_;
  }
  if (planning_tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      planning_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, planning_tag, submessage_arena);
    }
    set_has_planning_tag();
  } else {
    clear_has_planning_tag();
  }
  planning_tag_ = planning_tag;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ADCTrajectoryPoint.planning_tag)
}

// optional .apollo.planning.CommonTrajectoryPointFeature trajectory_point = 3;
inline bool ADCTrajectoryPoint::has_trajectory_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ADCTrajectoryPoint::set_has_trajectory_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ADCTrajectoryPoint::clear_has_trajectory_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ADCTrajectoryPoint::clear_trajectory_point() {
  if (trajectory_point_ != NULL) trajectory_point_->Clear();
  clear_has_trajectory_point();
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& ADCTrajectoryPoint::_internal_trajectory_point() const {
  return *trajectory_point_;
}
inline const ::apollo::planning::CommonTrajectoryPointFeature& ADCTrajectoryPoint::trajectory_point() const {
  const ::apollo::planning::CommonTrajectoryPointFeature* p = trajectory_point_;
  // @@protoc_insertion_point(field_get:apollo.planning.ADCTrajectoryPoint.trajectory_point)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::CommonTrajectoryPointFeature*>(
      &::apollo::planning::_CommonTrajectoryPointFeature_default_instance_);
}
inline ::apollo::planning::CommonTrajectoryPointFeature* ADCTrajectoryPoint::release_trajectory_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.ADCTrajectoryPoint.trajectory_point)
  clear_has_trajectory_point();
  ::apollo::planning::CommonTrajectoryPointFeature* temp = trajectory_point_;
  trajectory_point_ = NULL;
  return temp;
}
inline ::apollo::planning::CommonTrajectoryPointFeature* ADCTrajectoryPoint::mutable_trajectory_point() {
  set_has_trajectory_point();
  if (trajectory_point_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::CommonTrajectoryPointFeature>(GetArenaNoVirtual());
    trajectory_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ADCTrajectoryPoint.trajectory_point)
  return trajectory_point_;
}
inline void ADCTrajectoryPoint::set_allocated_trajectory_point(::apollo::planning::CommonTrajectoryPointFeature* trajectory_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_point_;
  }
  if (trajectory_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory_point, submessage_arena);
    }
    set_has_trajectory_point();
  } else {
    clear_has_trajectory_point();
  }
  trajectory_point_ = trajectory_point;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ADCTrajectoryPoint.trajectory_point)
}

// -------------------------------------------------------------------

// LearningOutput

// repeated .apollo.planning.TrajectoryPointFeature adc_future_trajectory_point = 1;
inline int LearningOutput::adc_future_trajectory_point_size() const {
  return adc_future_trajectory_point_.size();
}
inline void LearningOutput::clear_adc_future_trajectory_point() {
  adc_future_trajectory_point_.Clear();
}
inline ::apollo::planning::TrajectoryPointFeature* LearningOutput::mutable_adc_future_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >*
LearningOutput::mutable_adc_future_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return &adc_future_trajectory_point_;
}
inline const ::apollo::planning::TrajectoryPointFeature& LearningOutput::adc_future_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_.Get(index);
}
inline ::apollo::planning::TrajectoryPointFeature* LearningOutput::add_adc_future_trajectory_point() {
  // @@protoc_insertion_point(field_add:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrajectoryPointFeature >&
LearningOutput::adc_future_trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningOutput.adc_future_trajectory_point)
  return adc_future_trajectory_point_;
}

// -------------------------------------------------------------------

// LearningDataFrame

// optional double message_timestamp_sec = 1;
inline bool LearningDataFrame::has_message_timestamp_sec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LearningDataFrame::set_has_message_timestamp_sec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LearningDataFrame::clear_has_message_timestamp_sec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LearningDataFrame::clear_message_timestamp_sec() {
  message_timestamp_sec_ = 0;
  clear_has_message_timestamp_sec();
}
inline double LearningDataFrame::message_timestamp_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.message_timestamp_sec)
  return message_timestamp_sec_;
}
inline void LearningDataFrame::set_message_timestamp_sec(double value) {
  set_has_message_timestamp_sec();
  message_timestamp_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LearningDataFrame.message_timestamp_sec)
}

// optional uint32 frame_num = 2;
inline bool LearningDataFrame::has_frame_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LearningDataFrame::set_has_frame_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LearningDataFrame::clear_has_frame_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LearningDataFrame::clear_frame_num() {
  frame_num_ = 0u;
  clear_has_frame_num();
}
inline ::google::protobuf::uint32 LearningDataFrame::frame_num() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.frame_num)
  return frame_num_;
}
inline void LearningDataFrame::set_frame_num(::google::protobuf::uint32 value) {
  set_has_frame_num();
  frame_num_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LearningDataFrame.frame_num)
}

// optional string map_name = 3;
inline bool LearningDataFrame::has_map_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LearningDataFrame::set_has_map_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LearningDataFrame::clear_has_map_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LearningDataFrame::clear_map_name() {
  map_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_name();
}
inline const ::std::string& LearningDataFrame::map_name() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.map_name)
  return map_name_.GetNoArena();
}
inline void LearningDataFrame::set_map_name(const ::std::string& value) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.LearningDataFrame.map_name)
}
#if LANG_CXX11
inline void LearningDataFrame::set_map_name(::std::string&& value) {
  set_has_map_name();
  map_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.LearningDataFrame.map_name)
}
#endif
inline void LearningDataFrame::set_map_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.LearningDataFrame.map_name)
}
inline void LearningDataFrame::set_map_name(const char* value, size_t size) {
  set_has_map_name();
  map_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.LearningDataFrame.map_name)
}
inline ::std::string* LearningDataFrame::mutable_map_name() {
  set_has_map_name();
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.map_name)
  return map_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LearningDataFrame::release_map_name() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.map_name)
  if (!has_map_name()) {
    return NULL;
  }
  clear_has_map_name();
  return map_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LearningDataFrame::set_allocated_map_name(::std::string* map_name) {
  if (map_name != NULL) {
    set_has_map_name();
  } else {
    clear_has_map_name();
  }
  map_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_name);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.map_name)
}

// optional .apollo.planning.PlanningTag planning_tag = 4;
inline bool LearningDataFrame::has_planning_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LearningDataFrame::set_has_planning_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LearningDataFrame::clear_has_planning_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LearningDataFrame::clear_planning_tag() {
  if (planning_tag_ != NULL) planning_tag_->Clear();
  clear_has_planning_tag();
}
inline const ::apollo::planning::PlanningTag& LearningDataFrame::_internal_planning_tag() const {
  return *planning_tag_;
}
inline const ::apollo::planning::PlanningTag& LearningDataFrame::planning_tag() const {
  const ::apollo::planning::PlanningTag* p = planning_tag_;
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.planning_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::PlanningTag*>(
      &::apollo::planning::_PlanningTag_default_instance_);
}
inline ::apollo::planning::PlanningTag* LearningDataFrame::release_planning_tag() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.planning_tag)
  clear_has_planning_tag();
  ::apollo::planning::PlanningTag* temp = planning_tag_;
  planning_tag_ = NULL;
  return temp;
}
inline ::apollo::planning::PlanningTag* LearningDataFrame::mutable_planning_tag() {
  set_has_planning_tag();
  if (planning_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlanningTag>(GetArenaNoVirtual());
    planning_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.planning_tag)
  return planning_tag_;
}
inline void LearningDataFrame::set_allocated_planning_tag(::apollo::planning::PlanningTag* planning_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete planning_tag_;
  }
  if (planning_tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      planning_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, planning_tag, submessage_arena);
    }
    set_has_planning_tag();
  } else {
    clear_has_planning_tag();
  }
  planning_tag_ = planning_tag;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.planning_tag)
}

// optional .apollo.planning.ChassisFeature chassis = 5;
inline bool LearningDataFrame::has_chassis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LearningDataFrame::set_has_chassis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LearningDataFrame::clear_has_chassis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LearningDataFrame::clear_chassis() {
  if (chassis_ != NULL) chassis_->Clear();
  clear_has_chassis();
}
inline const ::apollo::planning::ChassisFeature& LearningDataFrame::_internal_chassis() const {
  return *chassis_;
}
inline const ::apollo::planning::ChassisFeature& LearningDataFrame::chassis() const {
  const ::apollo::planning::ChassisFeature* p = chassis_;
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.chassis)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::ChassisFeature*>(
      &::apollo::planning::_ChassisFeature_default_instance_);
}
inline ::apollo::planning::ChassisFeature* LearningDataFrame::release_chassis() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.chassis)
  clear_has_chassis();
  ::apollo::planning::ChassisFeature* temp = chassis_;
  chassis_ = NULL;
  return temp;
}
inline ::apollo::planning::ChassisFeature* LearningDataFrame::mutable_chassis() {
  set_has_chassis();
  if (chassis_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::ChassisFeature>(GetArenaNoVirtual());
    chassis_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.chassis)
  return chassis_;
}
inline void LearningDataFrame::set_allocated_chassis(::apollo::planning::ChassisFeature* chassis) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete chassis_;
  }
  if (chassis) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      chassis = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, chassis, submessage_arena);
    }
    set_has_chassis();
  } else {
    clear_has_chassis();
  }
  chassis_ = chassis;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.chassis)
}

// optional .apollo.planning.LocalizationFeature localization = 6;
inline bool LearningDataFrame::has_localization() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LearningDataFrame::set_has_localization() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LearningDataFrame::clear_has_localization() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LearningDataFrame::clear_localization() {
  if (localization_ != NULL) localization_->Clear();
  clear_has_localization();
}
inline const ::apollo::planning::LocalizationFeature& LearningDataFrame::_internal_localization() const {
  return *localization_;
}
inline const ::apollo::planning::LocalizationFeature& LearningDataFrame::localization() const {
  const ::apollo::planning::LocalizationFeature* p = localization_;
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.localization)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::LocalizationFeature*>(
      &::apollo::planning::_LocalizationFeature_default_instance_);
}
inline ::apollo::planning::LocalizationFeature* LearningDataFrame::release_localization() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.localization)
  clear_has_localization();
  ::apollo::planning::LocalizationFeature* temp = localization_;
  localization_ = NULL;
  return temp;
}
inline ::apollo::planning::LocalizationFeature* LearningDataFrame::mutable_localization() {
  set_has_localization();
  if (localization_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::LocalizationFeature>(GetArenaNoVirtual());
    localization_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.localization)
  return localization_;
}
inline void LearningDataFrame::set_allocated_localization(::apollo::planning::LocalizationFeature* localization) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete localization_;
  }
  if (localization) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      localization = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    set_has_localization();
  } else {
    clear_has_localization();
  }
  localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.localization)
}

// repeated .apollo.planning.ObstacleFeature obstacle = 7;
inline int LearningDataFrame::obstacle_size() const {
  return obstacle_.size();
}
inline void LearningDataFrame::clear_obstacle() {
  obstacle_.Clear();
}
inline ::apollo::planning::ObstacleFeature* LearningDataFrame::mutable_obstacle(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.obstacle)
  return obstacle_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::ObstacleFeature >*
LearningDataFrame::mutable_obstacle() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningDataFrame.obstacle)
  return &obstacle_;
}
inline const ::apollo::planning::ObstacleFeature& LearningDataFrame::obstacle(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.obstacle)
  return obstacle_.Get(index);
}
inline ::apollo::planning::ObstacleFeature* LearningDataFrame::add_obstacle() {
  // @@protoc_insertion_point(field_add:apollo.planning.LearningDataFrame.obstacle)
  return obstacle_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::ObstacleFeature >&
LearningDataFrame::obstacle() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningDataFrame.obstacle)
  return obstacle_;
}

// optional .apollo.planning.RoutingFeature routing = 8;
inline bool LearningDataFrame::has_routing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LearningDataFrame::set_has_routing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LearningDataFrame::clear_has_routing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LearningDataFrame::clear_routing() {
  if (routing_ != NULL) routing_->Clear();
  clear_has_routing();
}
inline const ::apollo::planning::RoutingFeature& LearningDataFrame::_internal_routing() const {
  return *routing_;
}
inline const ::apollo::planning::RoutingFeature& LearningDataFrame::routing() const {
  const ::apollo::planning::RoutingFeature* p = routing_;
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.routing)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::RoutingFeature*>(
      &::apollo::planning::_RoutingFeature_default_instance_);
}
inline ::apollo::planning::RoutingFeature* LearningDataFrame::release_routing() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.routing)
  clear_has_routing();
  ::apollo::planning::RoutingFeature* temp = routing_;
  routing_ = NULL;
  return temp;
}
inline ::apollo::planning::RoutingFeature* LearningDataFrame::mutable_routing() {
  set_has_routing();
  if (routing_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::RoutingFeature>(GetArenaNoVirtual());
    routing_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.routing)
  return routing_;
}
inline void LearningDataFrame::set_allocated_routing(::apollo::planning::RoutingFeature* routing) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete routing_;
  }
  if (routing) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      routing = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    set_has_routing();
  } else {
    clear_has_routing();
  }
  routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.routing)
}

// optional .apollo.planning.TrafficLightDetectionFeature traffic_light_detection = 9;
inline bool LearningDataFrame::has_traffic_light_detection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LearningDataFrame::set_has_traffic_light_detection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LearningDataFrame::clear_has_traffic_light_detection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LearningDataFrame::clear_traffic_light_detection() {
  if (traffic_light_detection_ != NULL) traffic_light_detection_->Clear();
  clear_has_traffic_light_detection();
}
inline const ::apollo::planning::TrafficLightDetectionFeature& LearningDataFrame::_internal_traffic_light_detection() const {
  return *traffic_light_detection_;
}
inline const ::apollo::planning::TrafficLightDetectionFeature& LearningDataFrame::traffic_light_detection() const {
  const ::apollo::planning::TrafficLightDetectionFeature* p = traffic_light_detection_;
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.traffic_light_detection)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::TrafficLightDetectionFeature*>(
      &::apollo::planning::_TrafficLightDetectionFeature_default_instance_);
}
inline ::apollo::planning::TrafficLightDetectionFeature* LearningDataFrame::release_traffic_light_detection() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.traffic_light_detection)
  clear_has_traffic_light_detection();
  ::apollo::planning::TrafficLightDetectionFeature* temp = traffic_light_detection_;
  traffic_light_detection_ = NULL;
  return temp;
}
inline ::apollo::planning::TrafficLightDetectionFeature* LearningDataFrame::mutable_traffic_light_detection() {
  set_has_traffic_light_detection();
  if (traffic_light_detection_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::TrafficLightDetectionFeature>(GetArenaNoVirtual());
    traffic_light_detection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.traffic_light_detection)
  return traffic_light_detection_;
}
inline void LearningDataFrame::set_allocated_traffic_light_detection(::apollo::planning::TrafficLightDetectionFeature* traffic_light_detection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete traffic_light_detection_;
  }
  if (traffic_light_detection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traffic_light_detection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traffic_light_detection, submessage_arena);
    }
    set_has_traffic_light_detection();
  } else {
    clear_has_traffic_light_detection();
  }
  traffic_light_detection_ = traffic_light_detection;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.traffic_light_detection)
}

// repeated .apollo.planning.ADCTrajectoryPoint adc_trajectory_point = 10;
inline int LearningDataFrame::adc_trajectory_point_size() const {
  return adc_trajectory_point_.size();
}
inline void LearningDataFrame::clear_adc_trajectory_point() {
  adc_trajectory_point_.Clear();
}
inline ::apollo::planning::ADCTrajectoryPoint* LearningDataFrame::mutable_adc_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >*
LearningDataFrame::mutable_adc_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return &adc_trajectory_point_;
}
inline const ::apollo::planning::ADCTrajectoryPoint& LearningDataFrame::adc_trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_.Get(index);
}
inline ::apollo::planning::ADCTrajectoryPoint* LearningDataFrame::add_adc_trajectory_point() {
  // @@protoc_insertion_point(field_add:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::ADCTrajectoryPoint >&
LearningDataFrame::adc_trajectory_point() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningDataFrame.adc_trajectory_point)
  return adc_trajectory_point_;
}

// optional .apollo.planning.LearningOutput output = 11;
inline bool LearningDataFrame::has_output() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LearningDataFrame::set_has_output() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LearningDataFrame::clear_has_output() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LearningDataFrame::clear_output() {
  if (output_ != NULL) output_->Clear();
  clear_has_output();
}
inline const ::apollo::planning::LearningOutput& LearningDataFrame::_internal_output() const {
  return *output_;
}
inline const ::apollo::planning::LearningOutput& LearningDataFrame::output() const {
  const ::apollo::planning::LearningOutput* p = output_;
  // @@protoc_insertion_point(field_get:apollo.planning.LearningDataFrame.output)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::LearningOutput*>(
      &::apollo::planning::_LearningOutput_default_instance_);
}
inline ::apollo::planning::LearningOutput* LearningDataFrame::release_output() {
  // @@protoc_insertion_point(field_release:apollo.planning.LearningDataFrame.output)
  clear_has_output();
  ::apollo::planning::LearningOutput* temp = output_;
  output_ = NULL;
  return temp;
}
inline ::apollo::planning::LearningOutput* LearningDataFrame::mutable_output() {
  set_has_output();
  if (output_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::LearningOutput>(GetArenaNoVirtual());
    output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningDataFrame.output)
  return output_;
}
inline void LearningDataFrame::set_allocated_output(::apollo::planning::LearningOutput* output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete output_;
  }
  if (output) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    set_has_output();
  } else {
    clear_has_output();
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LearningDataFrame.output)
}

// -------------------------------------------------------------------

// LearningData

// repeated .apollo.planning.LearningDataFrame learning_data_frame = 1;
inline int LearningData::learning_data_frame_size() const {
  return learning_data_frame_.size();
}
inline void LearningData::clear_learning_data_frame() {
  learning_data_frame_.Clear();
}
inline ::apollo::planning::LearningDataFrame* LearningData::mutable_learning_data_frame(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.LearningData.learning_data_frame)
  return learning_data_frame_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::LearningDataFrame >*
LearningData::mutable_learning_data_frame() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.LearningData.learning_data_frame)
  return &learning_data_frame_;
}
inline const ::apollo::planning::LearningDataFrame& LearningData::learning_data_frame(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.LearningData.learning_data_frame)
  return learning_data_frame_.Get(index);
}
inline ::apollo::planning::LearningDataFrame* LearningData::add_learning_data_frame() {
  // @@protoc_insertion_point(field_add:apollo.planning.LearningData.learning_data_frame)
  return learning_data_frame_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::LearningDataFrame >&
LearningData::learning_data_frame() const {
  // @@protoc_insertion_point(field_list:apollo.planning.LearningData.learning_data_frame)
  return learning_data_frame_;
}

// -------------------------------------------------------------------

// PlanningLearningData

// optional .apollo.common.Header header = 1;
inline bool PlanningLearningData::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningLearningData::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningLearningData::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::common::Header& PlanningLearningData::_internal_header() const {
  return *header_;
}
inline const ::apollo::common::Header& PlanningLearningData::header() const {
  const ::apollo::common::Header* p = header_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningLearningData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::common::Header*>(
      &::apollo::common::_Header_default_instance_);
}
inline ::apollo::common::Header* PlanningLearningData::release_header() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningLearningData.header)
  clear_has_header();
  ::apollo::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::apollo::common::Header* PlanningLearningData::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::common::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningLearningData.header)
  return header_;
}
inline void PlanningLearningData::set_allocated_header(::apollo::common::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningLearningData.header)
}

// optional .apollo.planning.LearningDataFrame learning_data_frame = 2;
inline bool PlanningLearningData::has_learning_data_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningLearningData::set_has_learning_data_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningLearningData::clear_has_learning_data_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningLearningData::clear_learning_data_frame() {
  if (learning_data_frame_ != NULL) learning_data_frame_->Clear();
  clear_has_learning_data_frame();
}
inline const ::apollo::planning::LearningDataFrame& PlanningLearningData::_internal_learning_data_frame() const {
  return *learning_data_frame_;
}
inline const ::apollo::planning::LearningDataFrame& PlanningLearningData::learning_data_frame() const {
  const ::apollo::planning::LearningDataFrame* p = learning_data_frame_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningLearningData.learning_data_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::LearningDataFrame*>(
      &::apollo::planning::_LearningDataFrame_default_instance_);
}
inline ::apollo::planning::LearningDataFrame* PlanningLearningData::release_learning_data_frame() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningLearningData.learning_data_frame)
  clear_has_learning_data_frame();
  ::apollo::planning::LearningDataFrame* temp = learning_data_frame_;
  learning_data_frame_ = NULL;
  return temp;
}
inline ::apollo::planning::LearningDataFrame* PlanningLearningData::mutable_learning_data_frame() {
  set_has_learning_data_frame();
  if (learning_data_frame_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::LearningDataFrame>(GetArenaNoVirtual());
    learning_data_frame_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningLearningData.learning_data_frame)
  return learning_data_frame_;
}
inline void PlanningLearningData::set_allocated_learning_data_frame(::apollo::planning::LearningDataFrame* learning_data_frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete learning_data_frame_;
  }
  if (learning_data_frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      learning_data_frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, learning_data_frame, submessage_arena);
    }
    set_has_learning_data_frame();
  } else {
    clear_has_learning_data_frame();
  }
  learning_data_frame_ = learning_data_frame;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningLearningData.learning_data_frame)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2flearning_5fdata_2eproto
