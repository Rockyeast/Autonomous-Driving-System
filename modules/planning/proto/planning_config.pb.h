// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/planning_config.proto

#ifndef PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto
#define PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/planning/proto/open_space_task_config.pb.h"
#include "modules/planning/proto/task_config.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto 

namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[25];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto
namespace apollo {
namespace planning {
class NavigationPlanningConfig;
class NavigationPlanningConfigDefaultTypeInternal;
extern NavigationPlanningConfigDefaultTypeInternal _NavigationPlanningConfig_default_instance_;
class PlannerNaviConfig;
class PlannerNaviConfigDefaultTypeInternal;
extern PlannerNaviConfigDefaultTypeInternal _PlannerNaviConfig_default_instance_;
class PlannerPublicRoadConfig;
class PlannerPublicRoadConfigDefaultTypeInternal;
extern PlannerPublicRoadConfigDefaultTypeInternal _PlannerPublicRoadConfig_default_instance_;
class PlanningConfig;
class PlanningConfigDefaultTypeInternal;
extern PlanningConfigDefaultTypeInternal _PlanningConfig_default_instance_;
class RtkPlanningConfig;
class RtkPlanningConfigDefaultTypeInternal;
extern RtkPlanningConfigDefaultTypeInternal _RtkPlanningConfig_default_instance_;
class ScenarioBareIntersectionUnprotectedConfig;
class ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal;
extern ScenarioBareIntersectionUnprotectedConfigDefaultTypeInternal _ScenarioBareIntersectionUnprotectedConfig_default_instance_;
class ScenarioConfig;
class ScenarioConfigDefaultTypeInternal;
extern ScenarioConfigDefaultTypeInternal _ScenarioConfig_default_instance_;
class ScenarioConfig_StageConfig;
class ScenarioConfig_StageConfigDefaultTypeInternal;
extern ScenarioConfig_StageConfigDefaultTypeInternal _ScenarioConfig_StageConfig_default_instance_;
class ScenarioDeadEndTurnAroundConfig;
class ScenarioDeadEndTurnAroundConfigDefaultTypeInternal;
extern ScenarioDeadEndTurnAroundConfigDefaultTypeInternal _ScenarioDeadEndTurnAroundConfig_default_instance_;
class ScenarioEmergencyPullOverConfig;
class ScenarioEmergencyPullOverConfigDefaultTypeInternal;
extern ScenarioEmergencyPullOverConfigDefaultTypeInternal _ScenarioEmergencyPullOverConfig_default_instance_;
class ScenarioEmergencyStopConfig;
class ScenarioEmergencyStopConfigDefaultTypeInternal;
extern ScenarioEmergencyStopConfigDefaultTypeInternal _ScenarioEmergencyStopConfig_default_instance_;
class ScenarioLaneFollowConfig;
class ScenarioLaneFollowConfigDefaultTypeInternal;
extern ScenarioLaneFollowConfigDefaultTypeInternal _ScenarioLaneFollowConfig_default_instance_;
class ScenarioLearningModelSampleConfig;
class ScenarioLearningModelSampleConfigDefaultTypeInternal;
extern ScenarioLearningModelSampleConfigDefaultTypeInternal _ScenarioLearningModelSampleConfig_default_instance_;
class ScenarioNarrowStreetUTurnConfig;
class ScenarioNarrowStreetUTurnConfigDefaultTypeInternal;
extern ScenarioNarrowStreetUTurnConfigDefaultTypeInternal _ScenarioNarrowStreetUTurnConfig_default_instance_;
class ScenarioParkAndGoConfig;
class ScenarioParkAndGoConfigDefaultTypeInternal;
extern ScenarioParkAndGoConfigDefaultTypeInternal _ScenarioParkAndGoConfig_default_instance_;
class ScenarioPullOverConfig;
class ScenarioPullOverConfigDefaultTypeInternal;
extern ScenarioPullOverConfigDefaultTypeInternal _ScenarioPullOverConfig_default_instance_;
class ScenarioStopSignUnprotectedConfig;
class ScenarioStopSignUnprotectedConfigDefaultTypeInternal;
extern ScenarioStopSignUnprotectedConfigDefaultTypeInternal _ScenarioStopSignUnprotectedConfig_default_instance_;
class ScenarioTrafficLightProtectedConfig;
class ScenarioTrafficLightProtectedConfigDefaultTypeInternal;
extern ScenarioTrafficLightProtectedConfigDefaultTypeInternal _ScenarioTrafficLightProtectedConfig_default_instance_;
class ScenarioTrafficLightUnprotectedLeftTurnConfig;
class ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedLeftTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_;
class ScenarioTrafficLightUnprotectedRightTurnConfig;
class ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal;
extern ScenarioTrafficLightUnprotectedRightTurnConfigDefaultTypeInternal _ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_;
class ScenarioValetParkingConfig;
class ScenarioValetParkingConfigDefaultTypeInternal;
extern ScenarioValetParkingConfigDefaultTypeInternal _ScenarioValetParkingConfig_default_instance_;
class ScenarioYieldSignConfig;
class ScenarioYieldSignConfigDefaultTypeInternal;
extern ScenarioYieldSignConfigDefaultTypeInternal _ScenarioYieldSignConfig_default_instance_;
class StandardPlanningConfig;
class StandardPlanningConfigDefaultTypeInternal;
extern StandardPlanningConfigDefaultTypeInternal _StandardPlanningConfig_default_instance_;
class TaskConfig;
class TaskConfigDefaultTypeInternal;
extern TaskConfigDefaultTypeInternal _TaskConfig_default_instance_;
class TopicConfig;
class TopicConfigDefaultTypeInternal;
extern TopicConfigDefaultTypeInternal _TopicConfig_default_instance_;
}  // namespace planning
}  // namespace apollo
namespace google {
namespace protobuf {
template<> ::apollo::planning::NavigationPlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::NavigationPlanningConfig>(Arena*);
template<> ::apollo::planning::PlannerNaviConfig* Arena::CreateMaybeMessage<::apollo::planning::PlannerNaviConfig>(Arena*);
template<> ::apollo::planning::PlannerPublicRoadConfig* Arena::CreateMaybeMessage<::apollo::planning::PlannerPublicRoadConfig>(Arena*);
template<> ::apollo::planning::PlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::PlanningConfig>(Arena*);
template<> ::apollo::planning::RtkPlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::RtkPlanningConfig>(Arena*);
template<> ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioBareIntersectionUnprotectedConfig>(Arena*);
template<> ::apollo::planning::ScenarioConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioConfig>(Arena*);
template<> ::apollo::planning::ScenarioConfig_StageConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioConfig_StageConfig>(Arena*);
template<> ::apollo::planning::ScenarioDeadEndTurnAroundConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioDeadEndTurnAroundConfig>(Arena*);
template<> ::apollo::planning::ScenarioEmergencyPullOverConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioEmergencyPullOverConfig>(Arena*);
template<> ::apollo::planning::ScenarioEmergencyStopConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioEmergencyStopConfig>(Arena*);
template<> ::apollo::planning::ScenarioLaneFollowConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioLaneFollowConfig>(Arena*);
template<> ::apollo::planning::ScenarioLearningModelSampleConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioLearningModelSampleConfig>(Arena*);
template<> ::apollo::planning::ScenarioNarrowStreetUTurnConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioNarrowStreetUTurnConfig>(Arena*);
template<> ::apollo::planning::ScenarioParkAndGoConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioParkAndGoConfig>(Arena*);
template<> ::apollo::planning::ScenarioPullOverConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioPullOverConfig>(Arena*);
template<> ::apollo::planning::ScenarioStopSignUnprotectedConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioStopSignUnprotectedConfig>(Arena*);
template<> ::apollo::planning::ScenarioTrafficLightProtectedConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioTrafficLightProtectedConfig>(Arena*);
template<> ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig>(Arena*);
template<> ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig>(Arena*);
template<> ::apollo::planning::ScenarioValetParkingConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioValetParkingConfig>(Arena*);
template<> ::apollo::planning::ScenarioYieldSignConfig* Arena::CreateMaybeMessage<::apollo::planning::ScenarioYieldSignConfig>(Arena*);
template<> ::apollo::planning::StandardPlanningConfig* Arena::CreateMaybeMessage<::apollo::planning::StandardPlanningConfig>(Arena*);
template<> ::apollo::planning::TaskConfig* Arena::CreateMaybeMessage<::apollo::planning::TaskConfig>(Arena*);
template<> ::apollo::planning::TopicConfig* Arena::CreateMaybeMessage<::apollo::planning::TopicConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace apollo {
namespace planning {

enum TaskConfig_TaskType {
  TaskConfig_TaskType_CREEP_DECIDER = 1,
  TaskConfig_TaskType_LANE_CHANGE_DECIDER = 2,
  TaskConfig_TaskType_NAVI_OBSTACLE_DECIDER = 3,
  TaskConfig_TaskType_NAVI_PATH_DECIDER = 4,
  TaskConfig_TaskType_NAVI_SPEED_DECIDER = 5,
  TaskConfig_TaskType_OPEN_SPACE_FALLBACK_DECIDER = 6,
  TaskConfig_TaskType_OPEN_SPACE_PRE_STOP_DECIDER = 7,
  TaskConfig_TaskType_OPEN_SPACE_ROI_DECIDER = 8,
  TaskConfig_TaskType_PATH_ASSESSMENT_DECIDER = 9,
  TaskConfig_TaskType_PATH_BOUNDS_DECIDER = 10,
  TaskConfig_TaskType_PATH_DECIDER = 11,
  TaskConfig_TaskType_PATH_LANE_BORROW_DECIDER = 12,
  TaskConfig_TaskType_PATH_REFERENCE_DECIDER = 13,
  TaskConfig_TaskType_PATH_REUSE_DECIDER = 14,
  TaskConfig_TaskType_RSS_DECIDER = 15,
  TaskConfig_TaskType_RULE_BASED_STOP_DECIDER = 16,
  TaskConfig_TaskType_SPEED_BOUNDS_PRIORI_DECIDER = 17,
  TaskConfig_TaskType_SPEED_BOUNDS_FINAL_DECIDER = 18,
  TaskConfig_TaskType_SPEED_DECIDER = 19,
  TaskConfig_TaskType_ST_BOUNDS_DECIDER = 20,
  TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PARTITION = 21,
  TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PROVIDER = 22,
  TaskConfig_TaskType_PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER = 23,
  TaskConfig_TaskType_PIECEWISE_JERK_PATH_OPTIMIZER = 24,
  TaskConfig_TaskType_PIECEWISE_JERK_SPEED_OPTIMIZER = 25,
  TaskConfig_TaskType_SPEED_HEURISTIC_OPTIMIZER = 26,
  TaskConfig_TaskType_LEARNING_MODEL_INFERENCE_TASK = 27,
  TaskConfig_TaskType_LEARNING_MODEL_INFERENCE_TRAJECTORY_TASK = 28,
  TaskConfig_TaskType_NEW_TEST_DECIDER = 29,
  TaskConfig_TaskType_ST_GENERATE_DECIDER = 30
};
bool TaskConfig_TaskType_IsValid(int value);
const TaskConfig_TaskType TaskConfig_TaskType_TaskType_MIN = TaskConfig_TaskType_CREEP_DECIDER;
const TaskConfig_TaskType TaskConfig_TaskType_TaskType_MAX = TaskConfig_TaskType_ST_GENERATE_DECIDER;
const int TaskConfig_TaskType_TaskType_ARRAYSIZE = TaskConfig_TaskType_TaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskConfig_TaskType_descriptor();
inline const ::std::string& TaskConfig_TaskType_Name(TaskConfig_TaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskConfig_TaskType_descriptor(), value);
}
inline bool TaskConfig_TaskType_Parse(
    const ::std::string& name, TaskConfig_TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskConfig_TaskType>(
    TaskConfig_TaskType_descriptor(), name, value);
}
enum ScenarioConfig_ScenarioType {
  ScenarioConfig_ScenarioType_LANE_FOLLOW = 0,
  ScenarioConfig_ScenarioType_BARE_INTERSECTION_UNPROTECTED = 2,
  ScenarioConfig_ScenarioType_STOP_SIGN_PROTECTED = 3,
  ScenarioConfig_ScenarioType_STOP_SIGN_UNPROTECTED = 4,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_PROTECTED = 5,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN = 6,
  ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN = 7,
  ScenarioConfig_ScenarioType_YIELD_SIGN = 8,
  ScenarioConfig_ScenarioType_PULL_OVER = 9,
  ScenarioConfig_ScenarioType_VALET_PARKING = 10,
  ScenarioConfig_ScenarioType_EMERGENCY_PULL_OVER = 11,
  ScenarioConfig_ScenarioType_EMERGENCY_STOP = 12,
  ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN = 13,
  ScenarioConfig_ScenarioType_PARK_AND_GO = 14,
  ScenarioConfig_ScenarioType_LEARNING_MODEL_SAMPLE = 15,
  ScenarioConfig_ScenarioType_DEADEND_TURNAROUND = 16
};
bool ScenarioConfig_ScenarioType_IsValid(int value);
const ScenarioConfig_ScenarioType ScenarioConfig_ScenarioType_ScenarioType_MIN = ScenarioConfig_ScenarioType_LANE_FOLLOW;
const ScenarioConfig_ScenarioType ScenarioConfig_ScenarioType_ScenarioType_MAX = ScenarioConfig_ScenarioType_DEADEND_TURNAROUND;
const int ScenarioConfig_ScenarioType_ScenarioType_ARRAYSIZE = ScenarioConfig_ScenarioType_ScenarioType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScenarioConfig_ScenarioType_descriptor();
inline const ::std::string& ScenarioConfig_ScenarioType_Name(ScenarioConfig_ScenarioType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScenarioConfig_ScenarioType_descriptor(), value);
}
inline bool ScenarioConfig_ScenarioType_Parse(
    const ::std::string& name, ScenarioConfig_ScenarioType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScenarioConfig_ScenarioType>(
    ScenarioConfig_ScenarioType_descriptor(), name, value);
}
enum ScenarioConfig_StageType {
  ScenarioConfig_StageType_NO_STAGE = 0,
  ScenarioConfig_StageType_LANE_FOLLOW_DEFAULT_STAGE = 1,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_APPROACH = 200,
  ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE = 201,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_PRE_STOP = 300,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_STOP = 301,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_CREEP = 302,
  ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE = 303,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_APPROACH = 400,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE = 401,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH = 410,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP = 411,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE = 412,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP = 420,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP = 421,
  ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE = 422,
  ScenarioConfig_StageType_PULL_OVER_APPROACH = 500,
  ScenarioConfig_StageType_PULL_OVER_RETRY_APPROACH_PARKING = 501,
  ScenarioConfig_StageType_PULL_OVER_RETRY_PARKING = 502,
  ScenarioConfig_StageType_EMERGENCY_PULL_OVER_SLOW_DOWN = 600,
  ScenarioConfig_StageType_EMERGENCY_PULL_OVER_APPROACH = 601,
  ScenarioConfig_StageType_EMERGENCY_PULL_OVER_STANDBY = 602,
  ScenarioConfig_StageType_EMERGENCY_STOP_APPROACH = 610,
  ScenarioConfig_StageType_EMERGENCY_STOP_STANDBY = 611,
  ScenarioConfig_StageType_VALET_PARKING_APPROACHING_PARKING_SPOT = 700,
  ScenarioConfig_StageType_VALET_PARKING_PARKING = 701,
  ScenarioConfig_StageType_DEADEND_TURNAROUND_APPROACHING_TURNING_POINT = 1100,
  ScenarioConfig_StageType_DEADEND_TURNAROUND_TURNING = 1101,
  ScenarioConfig_StageType_PARK_AND_GO_CHECK = 800,
  ScenarioConfig_StageType_PARK_AND_GO_CRUISE = 801,
  ScenarioConfig_StageType_PARK_AND_GO_ADJUST = 802,
  ScenarioConfig_StageType_PARK_AND_GO_PRE_CRUISE = 803,
  ScenarioConfig_StageType_YIELD_SIGN_APPROACH = 900,
  ScenarioConfig_StageType_YIELD_SIGN_CREEP = 901,
  ScenarioConfig_StageType_LEARNING_MODEL_RUN = 1000
};
bool ScenarioConfig_StageType_IsValid(int value);
const ScenarioConfig_StageType ScenarioConfig_StageType_StageType_MIN = ScenarioConfig_StageType_NO_STAGE;
const ScenarioConfig_StageType ScenarioConfig_StageType_StageType_MAX = ScenarioConfig_StageType_DEADEND_TURNAROUND_TURNING;
const int ScenarioConfig_StageType_StageType_ARRAYSIZE = ScenarioConfig_StageType_StageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScenarioConfig_StageType_descriptor();
inline const ::std::string& ScenarioConfig_StageType_Name(ScenarioConfig_StageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScenarioConfig_StageType_descriptor(), value);
}
inline bool ScenarioConfig_StageType_Parse(
    const ::std::string& name, ScenarioConfig_StageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScenarioConfig_StageType>(
    ScenarioConfig_StageType_descriptor(), name, value);
}
enum PlanningConfig_PlanningLearningMode {
  PlanningConfig_PlanningLearningMode_NO_LEARNING = 0,
  PlanningConfig_PlanningLearningMode_E2E = 1,
  PlanningConfig_PlanningLearningMode_HYBRID = 2,
  PlanningConfig_PlanningLearningMode_RL_TEST = 3,
  PlanningConfig_PlanningLearningMode_E2E_TEST = 4,
  PlanningConfig_PlanningLearningMode_HYBRID_TEST = 5
};
bool PlanningConfig_PlanningLearningMode_IsValid(int value);
const PlanningConfig_PlanningLearningMode PlanningConfig_PlanningLearningMode_PlanningLearningMode_MIN = PlanningConfig_PlanningLearningMode_NO_LEARNING;
const PlanningConfig_PlanningLearningMode PlanningConfig_PlanningLearningMode_PlanningLearningMode_MAX = PlanningConfig_PlanningLearningMode_HYBRID_TEST;
const int PlanningConfig_PlanningLearningMode_PlanningLearningMode_ARRAYSIZE = PlanningConfig_PlanningLearningMode_PlanningLearningMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlanningConfig_PlanningLearningMode_descriptor();
inline const ::std::string& PlanningConfig_PlanningLearningMode_Name(PlanningConfig_PlanningLearningMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlanningConfig_PlanningLearningMode_descriptor(), value);
}
inline bool PlanningConfig_PlanningLearningMode_Parse(
    const ::std::string& name, PlanningConfig_PlanningLearningMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlanningConfig_PlanningLearningMode>(
    PlanningConfig_PlanningLearningMode_descriptor(), name, value);
}
enum PlannerType {
  RTK = 0,
  PUBLIC_ROAD = 1,
  NAVI = 2,
  LATTICE = 3
};
bool PlannerType_IsValid(int value);
const PlannerType PlannerType_MIN = RTK;
const PlannerType PlannerType_MAX = LATTICE;
const int PlannerType_ARRAYSIZE = PlannerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlannerType_descriptor();
inline const ::std::string& PlannerType_Name(PlannerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlannerType_descriptor(), value);
}
inline bool PlannerType_Parse(
    const ::std::string& name, PlannerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlannerType>(
    PlannerType_descriptor(), name, value);
}
// ===================================================================

class TaskConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TaskConfig) */ {
 public:
  TaskConfig();
  virtual ~TaskConfig();

  TaskConfig(const TaskConfig& from);

  inline TaskConfig& operator=(const TaskConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskConfig(TaskConfig&& from) noexcept
    : TaskConfig() {
    *this = ::std::move(from);
  }

  inline TaskConfig& operator=(TaskConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskConfig& default_instance();

  enum TaskConfigCase {
    kCreepDeciderConfig = 2,
    kLaneChangeDeciderConfig = 3,
    kOpenSpaceFallbackDeciderConfig = 4,
    kOpenSpacePreStopDeciderConfig = 5,
    kOpenSpaceRoiDeciderConfig = 6,
    kPathAssessmentDeciderConfig = 7,
    kPathBoundsDeciderConfig = 8,
    kPathDeciderConfig = 9,
    kPathLaneBorrowDeciderConfig = 10,
    kPathReferenceDeciderConfig = 11,
    kPathReuseDeciderConfig = 12,
    kRuleBasedStopDeciderConfig = 13,
    kSpeedBoundsDeciderConfig = 14,
    kStBoundsDeciderConfig = 15,
    kOpenSpaceTrajectoryPartitionConfig = 16,
    kOpenSpaceTrajectoryProviderConfig = 17,
    kPiecewiseJerkNonlinearSpeedOptimizerConfig = 18,
    kPiecewiseJerkPathOptimizerConfig = 19,
    kPiecewiseJerkSpeedOptimizerConfig = 20,
    kSpeedHeuristicOptimizerConfig = 21,
    kLearningModelInferenceTaskConfig = 22,
    kLearningModelInferenceTrajectoryTaskConfig = 23,
    kNewTestDeciderConfig = 24,
    kStGenerateDeciderConfig = 25,
    TASK_CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskConfig* internal_default_instance() {
    return reinterpret_cast<const TaskConfig*>(
               &_TaskConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TaskConfig* other);
  friend void swap(TaskConfig& a, TaskConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskConfig* New() const final {
    return CreateMaybeMessage<TaskConfig>(NULL);
  }

  TaskConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskConfig& from);
  void MergeFrom(const TaskConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TaskConfig_TaskType TaskType;
  static const TaskType CREEP_DECIDER =
    TaskConfig_TaskType_CREEP_DECIDER;
  static const TaskType LANE_CHANGE_DECIDER =
    TaskConfig_TaskType_LANE_CHANGE_DECIDER;
  static const TaskType NAVI_OBSTACLE_DECIDER =
    TaskConfig_TaskType_NAVI_OBSTACLE_DECIDER;
  static const TaskType NAVI_PATH_DECIDER =
    TaskConfig_TaskType_NAVI_PATH_DECIDER;
  static const TaskType NAVI_SPEED_DECIDER =
    TaskConfig_TaskType_NAVI_SPEED_DECIDER;
  static const TaskType OPEN_SPACE_FALLBACK_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_FALLBACK_DECIDER;
  static const TaskType OPEN_SPACE_PRE_STOP_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_PRE_STOP_DECIDER;
  static const TaskType OPEN_SPACE_ROI_DECIDER =
    TaskConfig_TaskType_OPEN_SPACE_ROI_DECIDER;
  static const TaskType PATH_ASSESSMENT_DECIDER =
    TaskConfig_TaskType_PATH_ASSESSMENT_DECIDER;
  static const TaskType PATH_BOUNDS_DECIDER =
    TaskConfig_TaskType_PATH_BOUNDS_DECIDER;
  static const TaskType PATH_DECIDER =
    TaskConfig_TaskType_PATH_DECIDER;
  static const TaskType PATH_LANE_BORROW_DECIDER =
    TaskConfig_TaskType_PATH_LANE_BORROW_DECIDER;
  static const TaskType PATH_REFERENCE_DECIDER =
    TaskConfig_TaskType_PATH_REFERENCE_DECIDER;
  static const TaskType PATH_REUSE_DECIDER =
    TaskConfig_TaskType_PATH_REUSE_DECIDER;
  static const TaskType RSS_DECIDER =
    TaskConfig_TaskType_RSS_DECIDER;
  static const TaskType RULE_BASED_STOP_DECIDER =
    TaskConfig_TaskType_RULE_BASED_STOP_DECIDER;
  static const TaskType SPEED_BOUNDS_PRIORI_DECIDER =
    TaskConfig_TaskType_SPEED_BOUNDS_PRIORI_DECIDER;
  static const TaskType SPEED_BOUNDS_FINAL_DECIDER =
    TaskConfig_TaskType_SPEED_BOUNDS_FINAL_DECIDER;
  static const TaskType SPEED_DECIDER =
    TaskConfig_TaskType_SPEED_DECIDER;
  static const TaskType ST_BOUNDS_DECIDER =
    TaskConfig_TaskType_ST_BOUNDS_DECIDER;
  static const TaskType OPEN_SPACE_TRAJECTORY_PARTITION =
    TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PARTITION;
  static const TaskType OPEN_SPACE_TRAJECTORY_PROVIDER =
    TaskConfig_TaskType_OPEN_SPACE_TRAJECTORY_PROVIDER;
  static const TaskType PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_NONLINEAR_SPEED_OPTIMIZER;
  static const TaskType PIECEWISE_JERK_PATH_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_PATH_OPTIMIZER;
  static const TaskType PIECEWISE_JERK_SPEED_OPTIMIZER =
    TaskConfig_TaskType_PIECEWISE_JERK_SPEED_OPTIMIZER;
  static const TaskType SPEED_HEURISTIC_OPTIMIZER =
    TaskConfig_TaskType_SPEED_HEURISTIC_OPTIMIZER;
  static const TaskType LEARNING_MODEL_INFERENCE_TASK =
    TaskConfig_TaskType_LEARNING_MODEL_INFERENCE_TASK;
  static const TaskType LEARNING_MODEL_INFERENCE_TRAJECTORY_TASK =
    TaskConfig_TaskType_LEARNING_MODEL_INFERENCE_TRAJECTORY_TASK;
  static const TaskType NEW_TEST_DECIDER =
    TaskConfig_TaskType_NEW_TEST_DECIDER;
  static const TaskType ST_GENERATE_DECIDER =
    TaskConfig_TaskType_ST_GENERATE_DECIDER;
  static inline bool TaskType_IsValid(int value) {
    return TaskConfig_TaskType_IsValid(value);
  }
  static const TaskType TaskType_MIN =
    TaskConfig_TaskType_TaskType_MIN;
  static const TaskType TaskType_MAX =
    TaskConfig_TaskType_TaskType_MAX;
  static const int TaskType_ARRAYSIZE =
    TaskConfig_TaskType_TaskType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TaskType_descriptor() {
    return TaskConfig_TaskType_descriptor();
  }
  static inline const ::std::string& TaskType_Name(TaskType value) {
    return TaskConfig_TaskType_Name(value);
  }
  static inline bool TaskType_Parse(const ::std::string& name,
      TaskType* value) {
    return TaskConfig_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.planning.TaskConfig.TaskType task_type = 1;
  bool has_task_type() const;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 1;
  ::apollo::planning::TaskConfig_TaskType task_type() const;
  void set_task_type(::apollo::planning::TaskConfig_TaskType value);

  // optional .apollo.planning.CreepDeciderConfig creep_decider_config = 2;
  bool has_creep_decider_config() const;
  void clear_creep_decider_config();
  static const int kCreepDeciderConfigFieldNumber = 2;
  private:
  const ::apollo::planning::CreepDeciderConfig& _internal_creep_decider_config() const;
  public:
  const ::apollo::planning::CreepDeciderConfig& creep_decider_config() const;
  ::apollo::planning::CreepDeciderConfig* release_creep_decider_config();
  ::apollo::planning::CreepDeciderConfig* mutable_creep_decider_config();
  void set_allocated_creep_decider_config(::apollo::planning::CreepDeciderConfig* creep_decider_config);

  // optional .apollo.planning.LaneChangeDeciderConfig lane_change_decider_config = 3;
  bool has_lane_change_decider_config() const;
  void clear_lane_change_decider_config();
  static const int kLaneChangeDeciderConfigFieldNumber = 3;
  private:
  const ::apollo::planning::LaneChangeDeciderConfig& _internal_lane_change_decider_config() const;
  public:
  const ::apollo::planning::LaneChangeDeciderConfig& lane_change_decider_config() const;
  ::apollo::planning::LaneChangeDeciderConfig* release_lane_change_decider_config();
  ::apollo::planning::LaneChangeDeciderConfig* mutable_lane_change_decider_config();
  void set_allocated_lane_change_decider_config(::apollo::planning::LaneChangeDeciderConfig* lane_change_decider_config);

  // optional .apollo.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 4;
  bool has_open_space_fallback_decider_config() const;
  void clear_open_space_fallback_decider_config();
  static const int kOpenSpaceFallbackDeciderConfigFieldNumber = 4;
  private:
  const ::apollo::planning::OpenSpaceFallBackDeciderConfig& _internal_open_space_fallback_decider_config() const;
  public:
  const ::apollo::planning::OpenSpaceFallBackDeciderConfig& open_space_fallback_decider_config() const;
  ::apollo::planning::OpenSpaceFallBackDeciderConfig* release_open_space_fallback_decider_config();
  ::apollo::planning::OpenSpaceFallBackDeciderConfig* mutable_open_space_fallback_decider_config();
  void set_allocated_open_space_fallback_decider_config(::apollo::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config);

  // optional .apollo.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 5;
  bool has_open_space_pre_stop_decider_config() const;
  void clear_open_space_pre_stop_decider_config();
  static const int kOpenSpacePreStopDeciderConfigFieldNumber = 5;
  private:
  const ::apollo::planning::OpenSpacePreStopDeciderConfig& _internal_open_space_pre_stop_decider_config() const;
  public:
  const ::apollo::planning::OpenSpacePreStopDeciderConfig& open_space_pre_stop_decider_config() const;
  ::apollo::planning::OpenSpacePreStopDeciderConfig* release_open_space_pre_stop_decider_config();
  ::apollo::planning::OpenSpacePreStopDeciderConfig* mutable_open_space_pre_stop_decider_config();
  void set_allocated_open_space_pre_stop_decider_config(::apollo::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config);

  // optional .apollo.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 6;
  bool has_open_space_roi_decider_config() const;
  void clear_open_space_roi_decider_config();
  static const int kOpenSpaceRoiDeciderConfigFieldNumber = 6;
  private:
  const ::apollo::planning::OpenSpaceRoiDeciderConfig& _internal_open_space_roi_decider_config() const;
  public:
  const ::apollo::planning::OpenSpaceRoiDeciderConfig& open_space_roi_decider_config() const;
  ::apollo::planning::OpenSpaceRoiDeciderConfig* release_open_space_roi_decider_config();
  ::apollo::planning::OpenSpaceRoiDeciderConfig* mutable_open_space_roi_decider_config();
  void set_allocated_open_space_roi_decider_config(::apollo::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config);

  // optional .apollo.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 7;
  bool has_path_assessment_decider_config() const;
  void clear_path_assessment_decider_config();
  static const int kPathAssessmentDeciderConfigFieldNumber = 7;
  private:
  const ::apollo::planning::PathAssessmentDeciderConfig& _internal_path_assessment_decider_config() const;
  public:
  const ::apollo::planning::PathAssessmentDeciderConfig& path_assessment_decider_config() const;
  ::apollo::planning::PathAssessmentDeciderConfig* release_path_assessment_decider_config();
  ::apollo::planning::PathAssessmentDeciderConfig* mutable_path_assessment_decider_config();
  void set_allocated_path_assessment_decider_config(::apollo::planning::PathAssessmentDeciderConfig* path_assessment_decider_config);

  // optional .apollo.planning.PathBoundsDeciderConfig path_bounds_decider_config = 8;
  bool has_path_bounds_decider_config() const;
  void clear_path_bounds_decider_config();
  static const int kPathBoundsDeciderConfigFieldNumber = 8;
  private:
  const ::apollo::planning::PathBoundsDeciderConfig& _internal_path_bounds_decider_config() const;
  public:
  const ::apollo::planning::PathBoundsDeciderConfig& path_bounds_decider_config() const;
  ::apollo::planning::PathBoundsDeciderConfig* release_path_bounds_decider_config();
  ::apollo::planning::PathBoundsDeciderConfig* mutable_path_bounds_decider_config();
  void set_allocated_path_bounds_decider_config(::apollo::planning::PathBoundsDeciderConfig* path_bounds_decider_config);

  // optional .apollo.planning.PathDeciderConfig path_decider_config = 9;
  bool has_path_decider_config() const;
  void clear_path_decider_config();
  static const int kPathDeciderConfigFieldNumber = 9;
  private:
  const ::apollo::planning::PathDeciderConfig& _internal_path_decider_config() const;
  public:
  const ::apollo::planning::PathDeciderConfig& path_decider_config() const;
  ::apollo::planning::PathDeciderConfig* release_path_decider_config();
  ::apollo::planning::PathDeciderConfig* mutable_path_decider_config();
  void set_allocated_path_decider_config(::apollo::planning::PathDeciderConfig* path_decider_config);

  // optional .apollo.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 10;
  bool has_path_lane_borrow_decider_config() const;
  void clear_path_lane_borrow_decider_config();
  static const int kPathLaneBorrowDeciderConfigFieldNumber = 10;
  private:
  const ::apollo::planning::PathLaneBorrowDeciderConfig& _internal_path_lane_borrow_decider_config() const;
  public:
  const ::apollo::planning::PathLaneBorrowDeciderConfig& path_lane_borrow_decider_config() const;
  ::apollo::planning::PathLaneBorrowDeciderConfig* release_path_lane_borrow_decider_config();
  ::apollo::planning::PathLaneBorrowDeciderConfig* mutable_path_lane_borrow_decider_config();
  void set_allocated_path_lane_borrow_decider_config(::apollo::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config);

  // optional .apollo.planning.PathReferenceDeciderConfig path_reference_decider_config = 11;
  bool has_path_reference_decider_config() const;
  void clear_path_reference_decider_config();
  static const int kPathReferenceDeciderConfigFieldNumber = 11;
  private:
  const ::apollo::planning::PathReferenceDeciderConfig& _internal_path_reference_decider_config() const;
  public:
  const ::apollo::planning::PathReferenceDeciderConfig& path_reference_decider_config() const;
  ::apollo::planning::PathReferenceDeciderConfig* release_path_reference_decider_config();
  ::apollo::planning::PathReferenceDeciderConfig* mutable_path_reference_decider_config();
  void set_allocated_path_reference_decider_config(::apollo::planning::PathReferenceDeciderConfig* path_reference_decider_config);

  // optional .apollo.planning.PathReuseDeciderConfig path_reuse_decider_config = 12;
  bool has_path_reuse_decider_config() const;
  void clear_path_reuse_decider_config();
  static const int kPathReuseDeciderConfigFieldNumber = 12;
  private:
  const ::apollo::planning::PathReuseDeciderConfig& _internal_path_reuse_decider_config() const;
  public:
  const ::apollo::planning::PathReuseDeciderConfig& path_reuse_decider_config() const;
  ::apollo::planning::PathReuseDeciderConfig* release_path_reuse_decider_config();
  ::apollo::planning::PathReuseDeciderConfig* mutable_path_reuse_decider_config();
  void set_allocated_path_reuse_decider_config(::apollo::planning::PathReuseDeciderConfig* path_reuse_decider_config);

  // optional .apollo.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 13;
  bool has_rule_based_stop_decider_config() const;
  void clear_rule_based_stop_decider_config();
  static const int kRuleBasedStopDeciderConfigFieldNumber = 13;
  private:
  const ::apollo::planning::RuleBasedStopDeciderConfig& _internal_rule_based_stop_decider_config() const;
  public:
  const ::apollo::planning::RuleBasedStopDeciderConfig& rule_based_stop_decider_config() const;
  ::apollo::planning::RuleBasedStopDeciderConfig* release_rule_based_stop_decider_config();
  ::apollo::planning::RuleBasedStopDeciderConfig* mutable_rule_based_stop_decider_config();
  void set_allocated_rule_based_stop_decider_config(::apollo::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config);

  // optional .apollo.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 14;
  bool has_speed_bounds_decider_config() const;
  void clear_speed_bounds_decider_config();
  static const int kSpeedBoundsDeciderConfigFieldNumber = 14;
  private:
  const ::apollo::planning::SpeedBoundsDeciderConfig& _internal_speed_bounds_decider_config() const;
  public:
  const ::apollo::planning::SpeedBoundsDeciderConfig& speed_bounds_decider_config() const;
  ::apollo::planning::SpeedBoundsDeciderConfig* release_speed_bounds_decider_config();
  ::apollo::planning::SpeedBoundsDeciderConfig* mutable_speed_bounds_decider_config();
  void set_allocated_speed_bounds_decider_config(::apollo::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config);

  // optional .apollo.planning.STBoundsDeciderConfig st_bounds_decider_config = 15;
  bool has_st_bounds_decider_config() const;
  void clear_st_bounds_decider_config();
  static const int kStBoundsDeciderConfigFieldNumber = 15;
  private:
  const ::apollo::planning::STBoundsDeciderConfig& _internal_st_bounds_decider_config() const;
  public:
  const ::apollo::planning::STBoundsDeciderConfig& st_bounds_decider_config() const;
  ::apollo::planning::STBoundsDeciderConfig* release_st_bounds_decider_config();
  ::apollo::planning::STBoundsDeciderConfig* mutable_st_bounds_decider_config();
  void set_allocated_st_bounds_decider_config(::apollo::planning::STBoundsDeciderConfig* st_bounds_decider_config);

  // optional .apollo.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 16;
  bool has_open_space_trajectory_partition_config() const;
  void clear_open_space_trajectory_partition_config();
  static const int kOpenSpaceTrajectoryPartitionConfigFieldNumber = 16;
  private:
  const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& _internal_open_space_trajectory_partition_config() const;
  public:
  const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& open_space_trajectory_partition_config() const;
  ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* release_open_space_trajectory_partition_config();
  ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* mutable_open_space_trajectory_partition_config();
  void set_allocated_open_space_trajectory_partition_config(::apollo::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config);

  // optional .apollo.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 17;
  bool has_open_space_trajectory_provider_config() const;
  void clear_open_space_trajectory_provider_config();
  static const int kOpenSpaceTrajectoryProviderConfigFieldNumber = 17;
  private:
  const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& _internal_open_space_trajectory_provider_config() const;
  public:
  const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& open_space_trajectory_provider_config() const;
  ::apollo::planning::OpenSpaceTrajectoryProviderConfig* release_open_space_trajectory_provider_config();
  ::apollo::planning::OpenSpaceTrajectoryProviderConfig* mutable_open_space_trajectory_provider_config();
  void set_allocated_open_space_trajectory_provider_config(::apollo::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config);

  // optional .apollo.planning.PiecewiseJerkNonlinearSpeedOptimizerConfig piecewise_jerk_nonlinear_speed_optimizer_config = 18;
  bool has_piecewise_jerk_nonlinear_speed_optimizer_config() const;
  void clear_piecewise_jerk_nonlinear_speed_optimizer_config();
  static const int kPiecewiseJerkNonlinearSpeedOptimizerConfigFieldNumber = 18;
  private:
  const ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig& _internal_piecewise_jerk_nonlinear_speed_optimizer_config() const;
  public:
  const ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig& piecewise_jerk_nonlinear_speed_optimizer_config() const;
  ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* release_piecewise_jerk_nonlinear_speed_optimizer_config();
  ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* mutable_piecewise_jerk_nonlinear_speed_optimizer_config();
  void set_allocated_piecewise_jerk_nonlinear_speed_optimizer_config(::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* piecewise_jerk_nonlinear_speed_optimizer_config);

  // optional .apollo.planning.PiecewiseJerkPathOptimizerConfig piecewise_jerk_path_optimizer_config = 19;
  bool has_piecewise_jerk_path_optimizer_config() const;
  void clear_piecewise_jerk_path_optimizer_config();
  static const int kPiecewiseJerkPathOptimizerConfigFieldNumber = 19;
  private:
  const ::apollo::planning::PiecewiseJerkPathOptimizerConfig& _internal_piecewise_jerk_path_optimizer_config() const;
  public:
  const ::apollo::planning::PiecewiseJerkPathOptimizerConfig& piecewise_jerk_path_optimizer_config() const;
  ::apollo::planning::PiecewiseJerkPathOptimizerConfig* release_piecewise_jerk_path_optimizer_config();
  ::apollo::planning::PiecewiseJerkPathOptimizerConfig* mutable_piecewise_jerk_path_optimizer_config();
  void set_allocated_piecewise_jerk_path_optimizer_config(::apollo::planning::PiecewiseJerkPathOptimizerConfig* piecewise_jerk_path_optimizer_config);

  // optional .apollo.planning.PiecewiseJerkSpeedOptimizerConfig piecewise_jerk_speed_optimizer_config = 20;
  bool has_piecewise_jerk_speed_optimizer_config() const;
  void clear_piecewise_jerk_speed_optimizer_config();
  static const int kPiecewiseJerkSpeedOptimizerConfigFieldNumber = 20;
  private:
  const ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig& _internal_piecewise_jerk_speed_optimizer_config() const;
  public:
  const ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig& piecewise_jerk_speed_optimizer_config() const;
  ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* release_piecewise_jerk_speed_optimizer_config();
  ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* mutable_piecewise_jerk_speed_optimizer_config();
  void set_allocated_piecewise_jerk_speed_optimizer_config(::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* piecewise_jerk_speed_optimizer_config);

  // optional .apollo.planning.SpeedHeuristicOptimizerConfig speed_heuristic_optimizer_config = 21;
  bool has_speed_heuristic_optimizer_config() const;
  void clear_speed_heuristic_optimizer_config();
  static const int kSpeedHeuristicOptimizerConfigFieldNumber = 21;
  private:
  const ::apollo::planning::SpeedHeuristicOptimizerConfig& _internal_speed_heuristic_optimizer_config() const;
  public:
  const ::apollo::planning::SpeedHeuristicOptimizerConfig& speed_heuristic_optimizer_config() const;
  ::apollo::planning::SpeedHeuristicOptimizerConfig* release_speed_heuristic_optimizer_config();
  ::apollo::planning::SpeedHeuristicOptimizerConfig* mutable_speed_heuristic_optimizer_config();
  void set_allocated_speed_heuristic_optimizer_config(::apollo::planning::SpeedHeuristicOptimizerConfig* speed_heuristic_optimizer_config);

  // optional .apollo.planning.LearningModelInferenceTaskConfig learning_model_inference_task_config = 22;
  bool has_learning_model_inference_task_config() const;
  void clear_learning_model_inference_task_config();
  static const int kLearningModelInferenceTaskConfigFieldNumber = 22;
  private:
  const ::apollo::planning::LearningModelInferenceTaskConfig& _internal_learning_model_inference_task_config() const;
  public:
  const ::apollo::planning::LearningModelInferenceTaskConfig& learning_model_inference_task_config() const;
  ::apollo::planning::LearningModelInferenceTaskConfig* release_learning_model_inference_task_config();
  ::apollo::planning::LearningModelInferenceTaskConfig* mutable_learning_model_inference_task_config();
  void set_allocated_learning_model_inference_task_config(::apollo::planning::LearningModelInferenceTaskConfig* learning_model_inference_task_config);

  // optional .apollo.planning.LearningModelInferenceTrajectoryTaskConfig learning_model_inference_trajectory_task_config = 23;
  bool has_learning_model_inference_trajectory_task_config() const;
  void clear_learning_model_inference_trajectory_task_config();
  static const int kLearningModelInferenceTrajectoryTaskConfigFieldNumber = 23;
  private:
  const ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig& _internal_learning_model_inference_trajectory_task_config() const;
  public:
  const ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig& learning_model_inference_trajectory_task_config() const;
  ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* release_learning_model_inference_trajectory_task_config();
  ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* mutable_learning_model_inference_trajectory_task_config();
  void set_allocated_learning_model_inference_trajectory_task_config(::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* learning_model_inference_trajectory_task_config);

  // optional .apollo.planning.NewTestDeciderConfig new_test_decider_config = 24;
  bool has_new_test_decider_config() const;
  void clear_new_test_decider_config();
  static const int kNewTestDeciderConfigFieldNumber = 24;
  private:
  const ::apollo::planning::NewTestDeciderConfig& _internal_new_test_decider_config() const;
  public:
  const ::apollo::planning::NewTestDeciderConfig& new_test_decider_config() const;
  ::apollo::planning::NewTestDeciderConfig* release_new_test_decider_config();
  ::apollo::planning::NewTestDeciderConfig* mutable_new_test_decider_config();
  void set_allocated_new_test_decider_config(::apollo::planning::NewTestDeciderConfig* new_test_decider_config);

  // optional .apollo.planning.StGenerateDeciderConfig st_generate_decider_config = 25;
  bool has_st_generate_decider_config() const;
  void clear_st_generate_decider_config();
  static const int kStGenerateDeciderConfigFieldNumber = 25;
  private:
  const ::apollo::planning::StGenerateDeciderConfig& _internal_st_generate_decider_config() const;
  public:
  const ::apollo::planning::StGenerateDeciderConfig& st_generate_decider_config() const;
  ::apollo::planning::StGenerateDeciderConfig* release_st_generate_decider_config();
  ::apollo::planning::StGenerateDeciderConfig* mutable_st_generate_decider_config();
  void set_allocated_st_generate_decider_config(::apollo::planning::StGenerateDeciderConfig* st_generate_decider_config);

  void clear_task_config();
  TaskConfigCase task_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.TaskConfig)
 private:
  void set_has_task_type();
  void clear_has_task_type();
  void set_has_creep_decider_config();
  void set_has_lane_change_decider_config();
  void set_has_open_space_fallback_decider_config();
  void set_has_open_space_pre_stop_decider_config();
  void set_has_open_space_roi_decider_config();
  void set_has_path_assessment_decider_config();
  void set_has_path_bounds_decider_config();
  void set_has_path_decider_config();
  void set_has_path_lane_borrow_decider_config();
  void set_has_path_reference_decider_config();
  void set_has_path_reuse_decider_config();
  void set_has_rule_based_stop_decider_config();
  void set_has_speed_bounds_decider_config();
  void set_has_st_bounds_decider_config();
  void set_has_open_space_trajectory_partition_config();
  void set_has_open_space_trajectory_provider_config();
  void set_has_piecewise_jerk_nonlinear_speed_optimizer_config();
  void set_has_piecewise_jerk_path_optimizer_config();
  void set_has_piecewise_jerk_speed_optimizer_config();
  void set_has_speed_heuristic_optimizer_config();
  void set_has_learning_model_inference_task_config();
  void set_has_learning_model_inference_trajectory_task_config();
  void set_has_new_test_decider_config();
  void set_has_st_generate_decider_config();

  inline bool has_task_config() const;
  inline void clear_has_task_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int task_type_;
  union TaskConfigUnion {
    TaskConfigUnion() {}
    ::apollo::planning::CreepDeciderConfig* creep_decider_config_;
    ::apollo::planning::LaneChangeDeciderConfig* lane_change_decider_config_;
    ::apollo::planning::OpenSpaceFallBackDeciderConfig* open_space_fallback_decider_config_;
    ::apollo::planning::OpenSpacePreStopDeciderConfig* open_space_pre_stop_decider_config_;
    ::apollo::planning::OpenSpaceRoiDeciderConfig* open_space_roi_decider_config_;
    ::apollo::planning::PathAssessmentDeciderConfig* path_assessment_decider_config_;
    ::apollo::planning::PathBoundsDeciderConfig* path_bounds_decider_config_;
    ::apollo::planning::PathDeciderConfig* path_decider_config_;
    ::apollo::planning::PathLaneBorrowDeciderConfig* path_lane_borrow_decider_config_;
    ::apollo::planning::PathReferenceDeciderConfig* path_reference_decider_config_;
    ::apollo::planning::PathReuseDeciderConfig* path_reuse_decider_config_;
    ::apollo::planning::RuleBasedStopDeciderConfig* rule_based_stop_decider_config_;
    ::apollo::planning::SpeedBoundsDeciderConfig* speed_bounds_decider_config_;
    ::apollo::planning::STBoundsDeciderConfig* st_bounds_decider_config_;
    ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* open_space_trajectory_partition_config_;
    ::apollo::planning::OpenSpaceTrajectoryProviderConfig* open_space_trajectory_provider_config_;
    ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* piecewise_jerk_nonlinear_speed_optimizer_config_;
    ::apollo::planning::PiecewiseJerkPathOptimizerConfig* piecewise_jerk_path_optimizer_config_;
    ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* piecewise_jerk_speed_optimizer_config_;
    ::apollo::planning::SpeedHeuristicOptimizerConfig* speed_heuristic_optimizer_config_;
    ::apollo::planning::LearningModelInferenceTaskConfig* learning_model_inference_task_config_;
    ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* learning_model_inference_trajectory_task_config_;
    ::apollo::planning::NewTestDeciderConfig* new_test_decider_config_;
    ::apollo::planning::StGenerateDeciderConfig* st_generate_decider_config_;
  } task_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioBareIntersectionUnprotectedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioBareIntersectionUnprotectedConfig) */ {
 public:
  ScenarioBareIntersectionUnprotectedConfig();
  virtual ~ScenarioBareIntersectionUnprotectedConfig();

  ScenarioBareIntersectionUnprotectedConfig(const ScenarioBareIntersectionUnprotectedConfig& from);

  inline ScenarioBareIntersectionUnprotectedConfig& operator=(const ScenarioBareIntersectionUnprotectedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioBareIntersectionUnprotectedConfig(ScenarioBareIntersectionUnprotectedConfig&& from) noexcept
    : ScenarioBareIntersectionUnprotectedConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioBareIntersectionUnprotectedConfig& operator=(ScenarioBareIntersectionUnprotectedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioBareIntersectionUnprotectedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioBareIntersectionUnprotectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioBareIntersectionUnprotectedConfig*>(
               &_ScenarioBareIntersectionUnprotectedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ScenarioBareIntersectionUnprotectedConfig* other);
  friend void swap(ScenarioBareIntersectionUnprotectedConfig& a, ScenarioBareIntersectionUnprotectedConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioBareIntersectionUnprotectedConfig* New() const final {
    return CreateMaybeMessage<ScenarioBareIntersectionUnprotectedConfig>(NULL);
  }

  ScenarioBareIntersectionUnprotectedConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioBareIntersectionUnprotectedConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioBareIntersectionUnprotectedConfig& from);
  void MergeFrom(const ScenarioBareIntersectionUnprotectedConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioBareIntersectionUnprotectedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_explicit_stop = 2 [default = false];
  bool has_enable_explicit_stop() const;
  void clear_enable_explicit_stop();
  static const int kEnableExplicitStopFieldNumber = 2;
  bool enable_explicit_stop() const;
  void set_enable_explicit_stop(bool value);

  // optional double start_bare_intersection_scenario_distance = 1 [default = 25];
  bool has_start_bare_intersection_scenario_distance() const;
  void clear_start_bare_intersection_scenario_distance();
  static const int kStartBareIntersectionScenarioDistanceFieldNumber = 1;
  double start_bare_intersection_scenario_distance() const;
  void set_start_bare_intersection_scenario_distance(double value);

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double approach_cruise_speed = 4 [default = 6.7056];
  bool has_approach_cruise_speed() const;
  void clear_approach_cruise_speed();
  static const int kApproachCruiseSpeedFieldNumber = 4;
  double approach_cruise_speed() const;
  void set_approach_cruise_speed(double value);

  // optional double stop_distance = 5 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 5;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional float stop_timeout_sec = 6 [default = 8];
  bool has_stop_timeout_sec() const;
  void clear_stop_timeout_sec();
  static const int kStopTimeoutSecFieldNumber = 6;
  float stop_timeout_sec() const;
  void set_stop_timeout_sec(float value);

  // optional float creep_timeout_sec = 7 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 7;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioBareIntersectionUnprotectedConfig)
 private:
  void set_has_start_bare_intersection_scenario_distance();
  void clear_has_start_bare_intersection_scenario_distance();
  void set_has_enable_explicit_stop();
  void clear_has_enable_explicit_stop();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_approach_cruise_speed();
  void clear_has_approach_cruise_speed();
  void set_has_stop_distance();
  void clear_has_stop_distance();
  void set_has_stop_timeout_sec();
  void clear_has_stop_timeout_sec();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool enable_explicit_stop_;
  double start_bare_intersection_scenario_distance_;
  double min_pass_s_distance_;
  double approach_cruise_speed_;
  double stop_distance_;
  float stop_timeout_sec_;
  float creep_timeout_sec_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioEmergencyPullOverConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioEmergencyPullOverConfig) */ {
 public:
  ScenarioEmergencyPullOverConfig();
  virtual ~ScenarioEmergencyPullOverConfig();

  ScenarioEmergencyPullOverConfig(const ScenarioEmergencyPullOverConfig& from);

  inline ScenarioEmergencyPullOverConfig& operator=(const ScenarioEmergencyPullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioEmergencyPullOverConfig(ScenarioEmergencyPullOverConfig&& from) noexcept
    : ScenarioEmergencyPullOverConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioEmergencyPullOverConfig& operator=(ScenarioEmergencyPullOverConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioEmergencyPullOverConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioEmergencyPullOverConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioEmergencyPullOverConfig*>(
               &_ScenarioEmergencyPullOverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ScenarioEmergencyPullOverConfig* other);
  friend void swap(ScenarioEmergencyPullOverConfig& a, ScenarioEmergencyPullOverConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioEmergencyPullOverConfig* New() const final {
    return CreateMaybeMessage<ScenarioEmergencyPullOverConfig>(NULL);
  }

  ScenarioEmergencyPullOverConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioEmergencyPullOverConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioEmergencyPullOverConfig& from);
  void MergeFrom(const ScenarioEmergencyPullOverConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioEmergencyPullOverConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_stop_deceleration = 1 [default = 3];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 1;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double slow_down_deceleration_time = 2 [default = 3];
  bool has_slow_down_deceleration_time() const;
  void clear_slow_down_deceleration_time();
  static const int kSlowDownDecelerationTimeFieldNumber = 2;
  double slow_down_deceleration_time() const;
  void set_slow_down_deceleration_time(double value);

  // optional double target_slow_down_speed = 3 [default = 2.5];
  bool has_target_slow_down_speed() const;
  void clear_target_slow_down_speed();
  static const int kTargetSlowDownSpeedFieldNumber = 3;
  double target_slow_down_speed() const;
  void set_target_slow_down_speed(double value);

  // optional double stop_distance = 4 [default = 1.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 4;
  double stop_distance() const;
  void set_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioEmergencyPullOverConfig)
 private:
  void set_has_max_stop_deceleration();
  void clear_has_max_stop_deceleration();
  void set_has_slow_down_deceleration_time();
  void clear_has_slow_down_deceleration_time();
  void set_has_target_slow_down_speed();
  void clear_has_target_slow_down_speed();
  void set_has_stop_distance();
  void clear_has_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double max_stop_deceleration_;
  double slow_down_deceleration_time_;
  double target_slow_down_speed_;
  double stop_distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioEmergencyStopConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioEmergencyStopConfig) */ {
 public:
  ScenarioEmergencyStopConfig();
  virtual ~ScenarioEmergencyStopConfig();

  ScenarioEmergencyStopConfig(const ScenarioEmergencyStopConfig& from);

  inline ScenarioEmergencyStopConfig& operator=(const ScenarioEmergencyStopConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioEmergencyStopConfig(ScenarioEmergencyStopConfig&& from) noexcept
    : ScenarioEmergencyStopConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioEmergencyStopConfig& operator=(ScenarioEmergencyStopConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioEmergencyStopConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioEmergencyStopConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioEmergencyStopConfig*>(
               &_ScenarioEmergencyStopConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ScenarioEmergencyStopConfig* other);
  friend void swap(ScenarioEmergencyStopConfig& a, ScenarioEmergencyStopConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioEmergencyStopConfig* New() const final {
    return CreateMaybeMessage<ScenarioEmergencyStopConfig>(NULL);
  }

  ScenarioEmergencyStopConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioEmergencyStopConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioEmergencyStopConfig& from);
  void MergeFrom(const ScenarioEmergencyStopConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioEmergencyStopConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_stop_deceleration = 1 [default = 6];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 1;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 2;
  double stop_distance() const;
  void set_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioEmergencyStopConfig)
 private:
  void set_has_max_stop_deceleration();
  void clear_has_max_stop_deceleration();
  void set_has_stop_distance();
  void clear_has_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double max_stop_deceleration_;
  double stop_distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioLaneFollowConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioLaneFollowConfig) */ {
 public:
  ScenarioLaneFollowConfig();
  virtual ~ScenarioLaneFollowConfig();

  ScenarioLaneFollowConfig(const ScenarioLaneFollowConfig& from);

  inline ScenarioLaneFollowConfig& operator=(const ScenarioLaneFollowConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioLaneFollowConfig(ScenarioLaneFollowConfig&& from) noexcept
    : ScenarioLaneFollowConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioLaneFollowConfig& operator=(ScenarioLaneFollowConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioLaneFollowConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioLaneFollowConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioLaneFollowConfig*>(
               &_ScenarioLaneFollowConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ScenarioLaneFollowConfig* other);
  friend void swap(ScenarioLaneFollowConfig& a, ScenarioLaneFollowConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioLaneFollowConfig* New() const final {
    return CreateMaybeMessage<ScenarioLaneFollowConfig>(NULL);
  }

  ScenarioLaneFollowConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioLaneFollowConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioLaneFollowConfig& from);
  void MergeFrom(const ScenarioLaneFollowConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioLaneFollowConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioLaneFollowConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioLearningModelSampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioLearningModelSampleConfig) */ {
 public:
  ScenarioLearningModelSampleConfig();
  virtual ~ScenarioLearningModelSampleConfig();

  ScenarioLearningModelSampleConfig(const ScenarioLearningModelSampleConfig& from);

  inline ScenarioLearningModelSampleConfig& operator=(const ScenarioLearningModelSampleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioLearningModelSampleConfig(ScenarioLearningModelSampleConfig&& from) noexcept
    : ScenarioLearningModelSampleConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioLearningModelSampleConfig& operator=(ScenarioLearningModelSampleConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioLearningModelSampleConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioLearningModelSampleConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioLearningModelSampleConfig*>(
               &_ScenarioLearningModelSampleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ScenarioLearningModelSampleConfig* other);
  friend void swap(ScenarioLearningModelSampleConfig& a, ScenarioLearningModelSampleConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioLearningModelSampleConfig* New() const final {
    return CreateMaybeMessage<ScenarioLearningModelSampleConfig>(NULL);
  }

  ScenarioLearningModelSampleConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioLearningModelSampleConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioLearningModelSampleConfig& from);
  void MergeFrom(const ScenarioLearningModelSampleConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioLearningModelSampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioLearningModelSampleConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioNarrowStreetUTurnConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioNarrowStreetUTurnConfig) */ {
 public:
  ScenarioNarrowStreetUTurnConfig();
  virtual ~ScenarioNarrowStreetUTurnConfig();

  ScenarioNarrowStreetUTurnConfig(const ScenarioNarrowStreetUTurnConfig& from);

  inline ScenarioNarrowStreetUTurnConfig& operator=(const ScenarioNarrowStreetUTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioNarrowStreetUTurnConfig(ScenarioNarrowStreetUTurnConfig&& from) noexcept
    : ScenarioNarrowStreetUTurnConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioNarrowStreetUTurnConfig& operator=(ScenarioNarrowStreetUTurnConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioNarrowStreetUTurnConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioNarrowStreetUTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioNarrowStreetUTurnConfig*>(
               &_ScenarioNarrowStreetUTurnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ScenarioNarrowStreetUTurnConfig* other);
  friend void swap(ScenarioNarrowStreetUTurnConfig& a, ScenarioNarrowStreetUTurnConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioNarrowStreetUTurnConfig* New() const final {
    return CreateMaybeMessage<ScenarioNarrowStreetUTurnConfig>(NULL);
  }

  ScenarioNarrowStreetUTurnConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioNarrowStreetUTurnConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioNarrowStreetUTurnConfig& from);
  void MergeFrom(const ScenarioNarrowStreetUTurnConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioNarrowStreetUTurnConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioNarrowStreetUTurnConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioParkAndGoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioParkAndGoConfig) */ {
 public:
  ScenarioParkAndGoConfig();
  virtual ~ScenarioParkAndGoConfig();

  ScenarioParkAndGoConfig(const ScenarioParkAndGoConfig& from);

  inline ScenarioParkAndGoConfig& operator=(const ScenarioParkAndGoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioParkAndGoConfig(ScenarioParkAndGoConfig&& from) noexcept
    : ScenarioParkAndGoConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioParkAndGoConfig& operator=(ScenarioParkAndGoConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioParkAndGoConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioParkAndGoConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioParkAndGoConfig*>(
               &_ScenarioParkAndGoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ScenarioParkAndGoConfig* other);
  friend void swap(ScenarioParkAndGoConfig& a, ScenarioParkAndGoConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioParkAndGoConfig* New() const final {
    return CreateMaybeMessage<ScenarioParkAndGoConfig>(NULL);
  }

  ScenarioParkAndGoConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioParkAndGoConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioParkAndGoConfig& from);
  void MergeFrom(const ScenarioParkAndGoConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioParkAndGoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double front_obstacle_buffer = 1 [default = 4];
  bool has_front_obstacle_buffer() const;
  void clear_front_obstacle_buffer();
  static const int kFrontObstacleBufferFieldNumber = 1;
  double front_obstacle_buffer() const;
  void set_front_obstacle_buffer(double value);

  // optional double heading_buffer = 2 [default = 0.5];
  bool has_heading_buffer() const;
  void clear_heading_buffer();
  static const int kHeadingBufferFieldNumber = 2;
  double heading_buffer() const;
  void set_heading_buffer(double value);

  // optional double min_dist_to_dest = 3 [default = 25];
  bool has_min_dist_to_dest() const;
  void clear_min_dist_to_dest();
  static const int kMinDistToDestFieldNumber = 3;
  double min_dist_to_dest() const;
  void set_min_dist_to_dest(double value);

  // optional double max_steering_percentage_when_cruise = 4 [default = 90];
  bool has_max_steering_percentage_when_cruise() const;
  void clear_max_steering_percentage_when_cruise();
  static const int kMaxSteeringPercentageWhenCruiseFieldNumber = 4;
  double max_steering_percentage_when_cruise() const;
  void set_max_steering_percentage_when_cruise(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioParkAndGoConfig)
 private:
  void set_has_front_obstacle_buffer();
  void clear_has_front_obstacle_buffer();
  void set_has_heading_buffer();
  void clear_has_heading_buffer();
  void set_has_min_dist_to_dest();
  void clear_has_min_dist_to_dest();
  void set_has_max_steering_percentage_when_cruise();
  void clear_has_max_steering_percentage_when_cruise();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double front_obstacle_buffer_;
  double heading_buffer_;
  double min_dist_to_dest_;
  double max_steering_percentage_when_cruise_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioPullOverConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioPullOverConfig) */ {
 public:
  ScenarioPullOverConfig();
  virtual ~ScenarioPullOverConfig();

  ScenarioPullOverConfig(const ScenarioPullOverConfig& from);

  inline ScenarioPullOverConfig& operator=(const ScenarioPullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioPullOverConfig(ScenarioPullOverConfig&& from) noexcept
    : ScenarioPullOverConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioPullOverConfig& operator=(ScenarioPullOverConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioPullOverConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioPullOverConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioPullOverConfig*>(
               &_ScenarioPullOverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ScenarioPullOverConfig* other);
  friend void swap(ScenarioPullOverConfig& a, ScenarioPullOverConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioPullOverConfig* New() const final {
    return CreateMaybeMessage<ScenarioPullOverConfig>(NULL);
  }

  ScenarioPullOverConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioPullOverConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioPullOverConfig& from);
  void MergeFrom(const ScenarioPullOverConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioPullOverConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_pull_over_scenario_distance = 1 [default = 50];
  bool has_start_pull_over_scenario_distance() const;
  void clear_start_pull_over_scenario_distance();
  static const int kStartPullOverScenarioDistanceFieldNumber = 1;
  double start_pull_over_scenario_distance() const;
  void set_start_pull_over_scenario_distance(double value);

  // optional double pull_over_min_distance_buffer = 2 [default = 10];
  bool has_pull_over_min_distance_buffer() const;
  void clear_pull_over_min_distance_buffer();
  static const int kPullOverMinDistanceBufferFieldNumber = 2;
  double pull_over_min_distance_buffer() const;
  void set_pull_over_min_distance_buffer(double value);

  // optional double max_distance_stop_search = 3 [default = 25];
  bool has_max_distance_stop_search() const;
  void clear_max_distance_stop_search();
  static const int kMaxDistanceStopSearchFieldNumber = 3;
  double max_distance_stop_search() const;
  void set_max_distance_stop_search(double value);

  // optional double max_s_error_to_end_point = 4 [default = 0.2];
  bool has_max_s_error_to_end_point() const;
  void clear_max_s_error_to_end_point();
  static const int kMaxSErrorToEndPointFieldNumber = 4;
  double max_s_error_to_end_point() const;
  void set_max_s_error_to_end_point(double value);

  // optional double max_l_error_to_end_point = 5 [default = 0.5];
  bool has_max_l_error_to_end_point() const;
  void clear_max_l_error_to_end_point();
  static const int kMaxLErrorToEndPointFieldNumber = 5;
  double max_l_error_to_end_point() const;
  void set_max_l_error_to_end_point(double value);

  // optional double max_theta_error_to_end_point = 6 [default = 0.2];
  bool has_max_theta_error_to_end_point() const;
  void clear_max_theta_error_to_end_point();
  static const int kMaxThetaErrorToEndPointFieldNumber = 6;
  double max_theta_error_to_end_point() const;
  void set_max_theta_error_to_end_point(double value);

  // optional double max_distance_error_to_end_point = 7 [default = 0.2];
  bool has_max_distance_error_to_end_point() const;
  void clear_max_distance_error_to_end_point();
  static const int kMaxDistanceErrorToEndPointFieldNumber = 7;
  double max_distance_error_to_end_point() const;
  void set_max_distance_error_to_end_point(double value);

  // optional double pass_destination_threshold = 8 [default = 10];
  bool has_pass_destination_threshold() const;
  void clear_pass_destination_threshold();
  static const int kPassDestinationThresholdFieldNumber = 8;
  double pass_destination_threshold() const;
  void set_pass_destination_threshold(double value);

  // optional double max_valid_stop_distance = 9 [default = 1];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 9;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
  bool has_s_distance_to_stop_for_open_space_parking() const;
  void clear_s_distance_to_stop_for_open_space_parking();
  static const int kSDistanceToStopForOpenSpaceParkingFieldNumber = 10;
  double s_distance_to_stop_for_open_space_parking() const;
  void set_s_distance_to_stop_for_open_space_parking(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioPullOverConfig)
 private:
  void set_has_start_pull_over_scenario_distance();
  void clear_has_start_pull_over_scenario_distance();
  void set_has_pull_over_min_distance_buffer();
  void clear_has_pull_over_min_distance_buffer();
  void set_has_max_distance_stop_search();
  void clear_has_max_distance_stop_search();
  void set_has_max_s_error_to_end_point();
  void clear_has_max_s_error_to_end_point();
  void set_has_max_l_error_to_end_point();
  void clear_has_max_l_error_to_end_point();
  void set_has_max_theta_error_to_end_point();
  void clear_has_max_theta_error_to_end_point();
  void set_has_max_distance_error_to_end_point();
  void clear_has_max_distance_error_to_end_point();
  void set_has_pass_destination_threshold();
  void clear_has_pass_destination_threshold();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_s_distance_to_stop_for_open_space_parking();
  void clear_has_s_distance_to_stop_for_open_space_parking();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double start_pull_over_scenario_distance_;
  double pull_over_min_distance_buffer_;
  double max_distance_stop_search_;
  double max_s_error_to_end_point_;
  double max_l_error_to_end_point_;
  double max_theta_error_to_end_point_;
  double max_distance_error_to_end_point_;
  double pass_destination_threshold_;
  double max_valid_stop_distance_;
  double s_distance_to_stop_for_open_space_parking_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioStopSignUnprotectedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioStopSignUnprotectedConfig) */ {
 public:
  ScenarioStopSignUnprotectedConfig();
  virtual ~ScenarioStopSignUnprotectedConfig();

  ScenarioStopSignUnprotectedConfig(const ScenarioStopSignUnprotectedConfig& from);

  inline ScenarioStopSignUnprotectedConfig& operator=(const ScenarioStopSignUnprotectedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioStopSignUnprotectedConfig(ScenarioStopSignUnprotectedConfig&& from) noexcept
    : ScenarioStopSignUnprotectedConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioStopSignUnprotectedConfig& operator=(ScenarioStopSignUnprotectedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioStopSignUnprotectedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioStopSignUnprotectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioStopSignUnprotectedConfig*>(
               &_ScenarioStopSignUnprotectedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ScenarioStopSignUnprotectedConfig* other);
  friend void swap(ScenarioStopSignUnprotectedConfig& a, ScenarioStopSignUnprotectedConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioStopSignUnprotectedConfig* New() const final {
    return CreateMaybeMessage<ScenarioStopSignUnprotectedConfig>(NULL);
  }

  ScenarioStopSignUnprotectedConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioStopSignUnprotectedConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioStopSignUnprotectedConfig& from);
  void MergeFrom(const ScenarioStopSignUnprotectedConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioStopSignUnprotectedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float creep_timeout_sec = 7 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 7;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double start_stop_sign_scenario_distance = 1 [default = 5];
  bool has_start_stop_sign_scenario_distance() const;
  void clear_start_stop_sign_scenario_distance();
  static const int kStartStopSignScenarioDistanceFieldNumber = 1;
  double start_stop_sign_scenario_distance() const;
  void set_start_stop_sign_scenario_distance(double value);

  // optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
  bool has_watch_vehicle_max_valid_stop_distance() const;
  void clear_watch_vehicle_max_valid_stop_distance();
  static const int kWatchVehicleMaxValidStopDistanceFieldNumber = 2;
  double watch_vehicle_max_valid_stop_distance() const;
  void set_watch_vehicle_max_valid_stop_distance(double value);

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 5 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 5;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional float stop_duration_sec = 4 [default = 1];
  bool has_stop_duration_sec() const;
  void clear_stop_duration_sec();
  static const int kStopDurationSecFieldNumber = 4;
  float stop_duration_sec() const;
  void set_stop_duration_sec(float value);

  // optional float stop_timeout_sec = 6 [default = 8];
  bool has_stop_timeout_sec() const;
  void clear_stop_timeout_sec();
  static const int kStopTimeoutSecFieldNumber = 6;
  float stop_timeout_sec() const;
  void set_stop_timeout_sec(float value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioStopSignUnprotectedConfig)
 private:
  void set_has_start_stop_sign_scenario_distance();
  void clear_has_start_stop_sign_scenario_distance();
  void set_has_watch_vehicle_max_valid_stop_distance();
  void clear_has_watch_vehicle_max_valid_stop_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_stop_duration_sec();
  void clear_has_stop_duration_sec();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_stop_timeout_sec();
  void clear_has_stop_timeout_sec();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float creep_timeout_sec_;
  double start_stop_sign_scenario_distance_;
  double watch_vehicle_max_valid_stop_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  float stop_duration_sec_;
  float stop_timeout_sec_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightProtectedConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioTrafficLightProtectedConfig) */ {
 public:
  ScenarioTrafficLightProtectedConfig();
  virtual ~ScenarioTrafficLightProtectedConfig();

  ScenarioTrafficLightProtectedConfig(const ScenarioTrafficLightProtectedConfig& from);

  inline ScenarioTrafficLightProtectedConfig& operator=(const ScenarioTrafficLightProtectedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioTrafficLightProtectedConfig(ScenarioTrafficLightProtectedConfig&& from) noexcept
    : ScenarioTrafficLightProtectedConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioTrafficLightProtectedConfig& operator=(ScenarioTrafficLightProtectedConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTrafficLightProtectedConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTrafficLightProtectedConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightProtectedConfig*>(
               &_ScenarioTrafficLightProtectedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ScenarioTrafficLightProtectedConfig* other);
  friend void swap(ScenarioTrafficLightProtectedConfig& a, ScenarioTrafficLightProtectedConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightProtectedConfig* New() const final {
    return CreateMaybeMessage<ScenarioTrafficLightProtectedConfig>(NULL);
  }

  ScenarioTrafficLightProtectedConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTrafficLightProtectedConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioTrafficLightProtectedConfig& from);
  void MergeFrom(const ScenarioTrafficLightProtectedConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTrafficLightProtectedConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  void clear_start_traffic_light_scenario_distance();
  static const int kStartTrafficLightScenarioDistanceFieldNumber = 1;
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);

  // optional double max_valid_stop_distance = 2 [default = 2];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioTrafficLightProtectedConfig)
 private:
  void set_has_start_traffic_light_scenario_distance();
  void clear_has_start_traffic_light_scenario_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightUnprotectedLeftTurnConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig) */ {
 public:
  ScenarioTrafficLightUnprotectedLeftTurnConfig();
  virtual ~ScenarioTrafficLightUnprotectedLeftTurnConfig();

  ScenarioTrafficLightUnprotectedLeftTurnConfig(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig& operator=(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioTrafficLightUnprotectedLeftTurnConfig(ScenarioTrafficLightUnprotectedLeftTurnConfig&& from) noexcept
    : ScenarioTrafficLightUnprotectedLeftTurnConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig& operator=(ScenarioTrafficLightUnprotectedLeftTurnConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTrafficLightUnprotectedLeftTurnConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTrafficLightUnprotectedLeftTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightUnprotectedLeftTurnConfig*>(
               &_ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other);
  friend void swap(ScenarioTrafficLightUnprotectedLeftTurnConfig& a, ScenarioTrafficLightUnprotectedLeftTurnConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightUnprotectedLeftTurnConfig* New() const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedLeftTurnConfig>(NULL);
  }

  ScenarioTrafficLightUnprotectedLeftTurnConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedLeftTurnConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  void MergeFrom(const ScenarioTrafficLightUnprotectedLeftTurnConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTrafficLightUnprotectedLeftTurnConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float creep_timeout_sec = 5 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 5;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  void clear_start_traffic_light_scenario_distance();
  static const int kStartTrafficLightScenarioDistanceFieldNumber = 1;
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);

  // optional double approach_cruise_speed = 2 [default = 2.78];
  bool has_approach_cruise_speed() const;
  void clear_approach_cruise_speed();
  static const int kApproachCruiseSpeedFieldNumber = 2;
  double approach_cruise_speed() const;
  void set_approach_cruise_speed(double value);

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 4 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 4;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double max_adc_speed_before_creep = 6 [default = 5.56];
  bool has_max_adc_speed_before_creep() const;
  void clear_max_adc_speed_before_creep();
  static const int kMaxAdcSpeedBeforeCreepFieldNumber = 6;
  double max_adc_speed_before_creep() const;
  void set_max_adc_speed_before_creep(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig)
 private:
  void set_has_start_traffic_light_scenario_distance();
  void clear_has_start_traffic_light_scenario_distance();
  void set_has_approach_cruise_speed();
  void clear_has_approach_cruise_speed();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();
  void set_has_max_adc_speed_before_creep();
  void clear_has_max_adc_speed_before_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float creep_timeout_sec_;
  double start_traffic_light_scenario_distance_;
  double approach_cruise_speed_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  double max_adc_speed_before_creep_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioTrafficLightUnprotectedRightTurnConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig) */ {
 public:
  ScenarioTrafficLightUnprotectedRightTurnConfig();
  virtual ~ScenarioTrafficLightUnprotectedRightTurnConfig();

  ScenarioTrafficLightUnprotectedRightTurnConfig(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);

  inline ScenarioTrafficLightUnprotectedRightTurnConfig& operator=(const ScenarioTrafficLightUnprotectedRightTurnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioTrafficLightUnprotectedRightTurnConfig(ScenarioTrafficLightUnprotectedRightTurnConfig&& from) noexcept
    : ScenarioTrafficLightUnprotectedRightTurnConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioTrafficLightUnprotectedRightTurnConfig& operator=(ScenarioTrafficLightUnprotectedRightTurnConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioTrafficLightUnprotectedRightTurnConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioTrafficLightUnprotectedRightTurnConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioTrafficLightUnprotectedRightTurnConfig*>(
               &_ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ScenarioTrafficLightUnprotectedRightTurnConfig* other);
  friend void swap(ScenarioTrafficLightUnprotectedRightTurnConfig& a, ScenarioTrafficLightUnprotectedRightTurnConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioTrafficLightUnprotectedRightTurnConfig* New() const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedRightTurnConfig>(NULL);
  }

  ScenarioTrafficLightUnprotectedRightTurnConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioTrafficLightUnprotectedRightTurnConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  void MergeFrom(const ScenarioTrafficLightUnprotectedRightTurnConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioTrafficLightUnprotectedRightTurnConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_right_turn_on_red = 2 [default = false];
  bool has_enable_right_turn_on_red() const;
  void clear_enable_right_turn_on_red();
  static const int kEnableRightTurnOnRedFieldNumber = 2;
  bool enable_right_turn_on_red() const;
  void set_enable_right_turn_on_red(bool value);

  // optional double start_traffic_light_scenario_distance = 1 [default = 5];
  bool has_start_traffic_light_scenario_distance() const;
  void clear_start_traffic_light_scenario_distance();
  static const int kStartTrafficLightScenarioDistanceFieldNumber = 1;
  double start_traffic_light_scenario_distance() const;
  void set_start_traffic_light_scenario_distance(double value);

  // optional double max_valid_stop_distance = 3 [default = 3.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 4 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 4;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
  bool has_red_light_right_turn_stop_duration_sec() const;
  void clear_red_light_right_turn_stop_duration_sec();
  static const int kRedLightRightTurnStopDurationSecFieldNumber = 5;
  float red_light_right_turn_stop_duration_sec() const;
  void set_red_light_right_turn_stop_duration_sec(float value);

  // optional float creep_timeout_sec = 6 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 6;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double max_adc_speed_before_creep = 7 [default = 3];
  bool has_max_adc_speed_before_creep() const;
  void clear_max_adc_speed_before_creep();
  static const int kMaxAdcSpeedBeforeCreepFieldNumber = 7;
  double max_adc_speed_before_creep() const;
  void set_max_adc_speed_before_creep(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig)
 private:
  void set_has_start_traffic_light_scenario_distance();
  void clear_has_start_traffic_light_scenario_distance();
  void set_has_enable_right_turn_on_red();
  void clear_has_enable_right_turn_on_red();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_red_light_right_turn_stop_duration_sec();
  void clear_has_red_light_right_turn_stop_duration_sec();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();
  void set_has_max_adc_speed_before_creep();
  void clear_has_max_adc_speed_before_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool enable_right_turn_on_red_;
  double start_traffic_light_scenario_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  float red_light_right_turn_stop_duration_sec_;
  float creep_timeout_sec_;
  double max_adc_speed_before_creep_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioValetParkingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioValetParkingConfig) */ {
 public:
  ScenarioValetParkingConfig();
  virtual ~ScenarioValetParkingConfig();

  ScenarioValetParkingConfig(const ScenarioValetParkingConfig& from);

  inline ScenarioValetParkingConfig& operator=(const ScenarioValetParkingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioValetParkingConfig(ScenarioValetParkingConfig&& from) noexcept
    : ScenarioValetParkingConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioValetParkingConfig& operator=(ScenarioValetParkingConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioValetParkingConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioValetParkingConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioValetParkingConfig*>(
               &_ScenarioValetParkingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ScenarioValetParkingConfig* other);
  friend void swap(ScenarioValetParkingConfig& a, ScenarioValetParkingConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioValetParkingConfig* New() const final {
    return CreateMaybeMessage<ScenarioValetParkingConfig>(NULL);
  }

  ScenarioValetParkingConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioValetParkingConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioValetParkingConfig& from);
  void MergeFrom(const ScenarioValetParkingConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioValetParkingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double parking_spot_range_to_start = 1 [default = 20];
  bool has_parking_spot_range_to_start() const;
  void clear_parking_spot_range_to_start();
  static const int kParkingSpotRangeToStartFieldNumber = 1;
  double parking_spot_range_to_start() const;
  void set_parking_spot_range_to_start(double value);

  // optional double max_valid_stop_distance = 2 [default = 1];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioValetParkingConfig)
 private:
  void set_has_parking_spot_range_to_start();
  void clear_has_parking_spot_range_to_start();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double parking_spot_range_to_start_;
  double max_valid_stop_distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioDeadEndTurnAroundConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioDeadEndTurnAroundConfig) */ {
 public:
  ScenarioDeadEndTurnAroundConfig();
  virtual ~ScenarioDeadEndTurnAroundConfig();

  ScenarioDeadEndTurnAroundConfig(const ScenarioDeadEndTurnAroundConfig& from);

  inline ScenarioDeadEndTurnAroundConfig& operator=(const ScenarioDeadEndTurnAroundConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioDeadEndTurnAroundConfig(ScenarioDeadEndTurnAroundConfig&& from) noexcept
    : ScenarioDeadEndTurnAroundConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioDeadEndTurnAroundConfig& operator=(ScenarioDeadEndTurnAroundConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioDeadEndTurnAroundConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioDeadEndTurnAroundConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioDeadEndTurnAroundConfig*>(
               &_ScenarioDeadEndTurnAroundConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ScenarioDeadEndTurnAroundConfig* other);
  friend void swap(ScenarioDeadEndTurnAroundConfig& a, ScenarioDeadEndTurnAroundConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioDeadEndTurnAroundConfig* New() const final {
    return CreateMaybeMessage<ScenarioDeadEndTurnAroundConfig>(NULL);
  }

  ScenarioDeadEndTurnAroundConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioDeadEndTurnAroundConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioDeadEndTurnAroundConfig& from);
  void MergeFrom(const ScenarioDeadEndTurnAroundConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioDeadEndTurnAroundConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double dead_end_start_range = 1 [default = 20];
  bool has_dead_end_start_range() const;
  void clear_dead_end_start_range();
  static const int kDeadEndStartRangeFieldNumber = 1;
  double dead_end_start_range() const;
  void set_dead_end_start_range(double value);

  // optional double max_valid_stop_distance = 2 [default = 1];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioDeadEndTurnAroundConfig)
 private:
  void set_has_dead_end_start_range();
  void clear_has_dead_end_start_range();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double dead_end_start_range_;
  double max_valid_stop_distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioYieldSignConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioYieldSignConfig) */ {
 public:
  ScenarioYieldSignConfig();
  virtual ~ScenarioYieldSignConfig();

  ScenarioYieldSignConfig(const ScenarioYieldSignConfig& from);

  inline ScenarioYieldSignConfig& operator=(const ScenarioYieldSignConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioYieldSignConfig(ScenarioYieldSignConfig&& from) noexcept
    : ScenarioYieldSignConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioYieldSignConfig& operator=(ScenarioYieldSignConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioYieldSignConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioYieldSignConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioYieldSignConfig*>(
               &_ScenarioYieldSignConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ScenarioYieldSignConfig* other);
  friend void swap(ScenarioYieldSignConfig& a, ScenarioYieldSignConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioYieldSignConfig* New() const final {
    return CreateMaybeMessage<ScenarioYieldSignConfig>(NULL);
  }

  ScenarioYieldSignConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioYieldSignConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioYieldSignConfig& from);
  void MergeFrom(const ScenarioYieldSignConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioYieldSignConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float creep_timeout_sec = 4 [default = 10];
  bool has_creep_timeout_sec() const;
  void clear_creep_timeout_sec();
  static const int kCreepTimeoutSecFieldNumber = 4;
  float creep_timeout_sec() const;
  void set_creep_timeout_sec(float value);

  // optional double start_yield_sign_scenario_distance = 1 [default = 10];
  bool has_start_yield_sign_scenario_distance() const;
  void clear_start_yield_sign_scenario_distance();
  static const int kStartYieldSignScenarioDistanceFieldNumber = 1;
  double start_yield_sign_scenario_distance() const;
  void set_start_yield_sign_scenario_distance(double value);

  // optional double max_valid_stop_distance = 2 [default = 4.5];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 2;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_pass_s_distance = 3 [default = 3];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioYieldSignConfig)
 private:
  void set_has_start_yield_sign_scenario_distance();
  void clear_has_start_yield_sign_scenario_distance();
  void set_has_max_valid_stop_distance();
  void clear_has_max_valid_stop_distance();
  void set_has_min_pass_s_distance();
  void clear_has_min_pass_s_distance();
  void set_has_creep_timeout_sec();
  void clear_has_creep_timeout_sec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float creep_timeout_sec_;
  double start_yield_sign_scenario_distance_;
  double max_valid_stop_distance_;
  double min_pass_s_distance_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioConfig_StageConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioConfig.StageConfig) */ {
 public:
  ScenarioConfig_StageConfig();
  virtual ~ScenarioConfig_StageConfig();

  ScenarioConfig_StageConfig(const ScenarioConfig_StageConfig& from);

  inline ScenarioConfig_StageConfig& operator=(const ScenarioConfig_StageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioConfig_StageConfig(ScenarioConfig_StageConfig&& from) noexcept
    : ScenarioConfig_StageConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioConfig_StageConfig& operator=(ScenarioConfig_StageConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioConfig_StageConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioConfig_StageConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig_StageConfig*>(
               &_ScenarioConfig_StageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ScenarioConfig_StageConfig* other);
  friend void swap(ScenarioConfig_StageConfig& a, ScenarioConfig_StageConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioConfig_StageConfig* New() const final {
    return CreateMaybeMessage<ScenarioConfig_StageConfig>(NULL);
  }

  ScenarioConfig_StageConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioConfig_StageConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioConfig_StageConfig& from);
  void MergeFrom(const ScenarioConfig_StageConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioConfig_StageConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TaskConfig.TaskType task_type = 3;
  int task_type_size() const;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 3;
  ::apollo::planning::TaskConfig_TaskType task_type(int index) const;
  void set_task_type(int index, ::apollo::planning::TaskConfig_TaskType value);
  void add_task_type(::apollo::planning::TaskConfig_TaskType value);
  const ::google::protobuf::RepeatedField<int>& task_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_task_type();

  // repeated .apollo.planning.TaskConfig task_config = 4;
  int task_config_size() const;
  void clear_task_config();
  static const int kTaskConfigFieldNumber = 4;
  ::apollo::planning::TaskConfig* mutable_task_config(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >*
      mutable_task_config();
  const ::apollo::planning::TaskConfig& task_config(int index) const;
  ::apollo::planning::TaskConfig* add_task_config();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >&
      task_config() const;

  // optional .apollo.planning.ScenarioConfig.StageType stage_type = 1;
  bool has_stage_type() const;
  void clear_stage_type();
  static const int kStageTypeFieldNumber = 1;
  ::apollo::planning::ScenarioConfig_StageType stage_type() const;
  void set_stage_type(::apollo::planning::ScenarioConfig_StageType value);

  // optional bool enabled = 2 [default = true];
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioConfig.StageConfig)
 private:
  void set_has_stage_type();
  void clear_has_stage_type();
  void set_has_enabled();
  void clear_has_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> task_type_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig > task_config_;
  int stage_type_;
  bool enabled_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScenarioConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ScenarioConfig) */ {
 public:
  ScenarioConfig();
  virtual ~ScenarioConfig();

  ScenarioConfig(const ScenarioConfig& from);

  inline ScenarioConfig& operator=(const ScenarioConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScenarioConfig(ScenarioConfig&& from) noexcept
    : ScenarioConfig() {
    *this = ::std::move(from);
  }

  inline ScenarioConfig& operator=(ScenarioConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScenarioConfig& default_instance();

  enum ScenarioConfigCase {
    kLaneFollowConfig = 2,
    kBareIntersectionUnprotectedConfig = 3,
    kEmergencyPullOverConfig = 4,
    kEmergencyStopConfig = 5,
    kLearningModelSampleConfig = 6,
    kNarrowStreetUTurnConfig = 7,
    kParkAndGoConfig = 8,
    kPullOverConfig = 9,
    kStopSignUnprotectedConfig = 10,
    kTrafficLightProtectedConfig = 11,
    kTrafficLightUnprotectedLeftTurnConfig = 12,
    kTrafficLightUnprotectedRightTurnConfig = 13,
    kValetParkingConfig = 14,
    kYieldSignConfig = 15,
    kDeadendTurnaroundConfig = 18,
    SCENARIO_CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScenarioConfig* internal_default_instance() {
    return reinterpret_cast<const ScenarioConfig*>(
               &_ScenarioConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ScenarioConfig* other);
  friend void swap(ScenarioConfig& a, ScenarioConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScenarioConfig* New() const final {
    return CreateMaybeMessage<ScenarioConfig>(NULL);
  }

  ScenarioConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScenarioConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScenarioConfig& from);
  void MergeFrom(const ScenarioConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScenarioConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ScenarioConfig_StageConfig StageConfig;

  typedef ScenarioConfig_ScenarioType ScenarioType;
  static const ScenarioType LANE_FOLLOW =
    ScenarioConfig_ScenarioType_LANE_FOLLOW;
  static const ScenarioType BARE_INTERSECTION_UNPROTECTED =
    ScenarioConfig_ScenarioType_BARE_INTERSECTION_UNPROTECTED;
  static const ScenarioType STOP_SIGN_PROTECTED =
    ScenarioConfig_ScenarioType_STOP_SIGN_PROTECTED;
  static const ScenarioType STOP_SIGN_UNPROTECTED =
    ScenarioConfig_ScenarioType_STOP_SIGN_UNPROTECTED;
  static const ScenarioType TRAFFIC_LIGHT_PROTECTED =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_PROTECTED;
  static const ScenarioType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN;
  static const ScenarioType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN =
    ScenarioConfig_ScenarioType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN;
  static const ScenarioType YIELD_SIGN =
    ScenarioConfig_ScenarioType_YIELD_SIGN;
  static const ScenarioType PULL_OVER =
    ScenarioConfig_ScenarioType_PULL_OVER;
  static const ScenarioType VALET_PARKING =
    ScenarioConfig_ScenarioType_VALET_PARKING;
  static const ScenarioType EMERGENCY_PULL_OVER =
    ScenarioConfig_ScenarioType_EMERGENCY_PULL_OVER;
  static const ScenarioType EMERGENCY_STOP =
    ScenarioConfig_ScenarioType_EMERGENCY_STOP;
  static const ScenarioType NARROW_STREET_U_TURN =
    ScenarioConfig_ScenarioType_NARROW_STREET_U_TURN;
  static const ScenarioType PARK_AND_GO =
    ScenarioConfig_ScenarioType_PARK_AND_GO;
  static const ScenarioType LEARNING_MODEL_SAMPLE =
    ScenarioConfig_ScenarioType_LEARNING_MODEL_SAMPLE;
  static const ScenarioType DEADEND_TURNAROUND =
    ScenarioConfig_ScenarioType_DEADEND_TURNAROUND;
  static inline bool ScenarioType_IsValid(int value) {
    return ScenarioConfig_ScenarioType_IsValid(value);
  }
  static const ScenarioType ScenarioType_MIN =
    ScenarioConfig_ScenarioType_ScenarioType_MIN;
  static const ScenarioType ScenarioType_MAX =
    ScenarioConfig_ScenarioType_ScenarioType_MAX;
  static const int ScenarioType_ARRAYSIZE =
    ScenarioConfig_ScenarioType_ScenarioType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScenarioType_descriptor() {
    return ScenarioConfig_ScenarioType_descriptor();
  }
  static inline const ::std::string& ScenarioType_Name(ScenarioType value) {
    return ScenarioConfig_ScenarioType_Name(value);
  }
  static inline bool ScenarioType_Parse(const ::std::string& name,
      ScenarioType* value) {
    return ScenarioConfig_ScenarioType_Parse(name, value);
  }

  typedef ScenarioConfig_StageType StageType;
  static const StageType NO_STAGE =
    ScenarioConfig_StageType_NO_STAGE;
  static const StageType LANE_FOLLOW_DEFAULT_STAGE =
    ScenarioConfig_StageType_LANE_FOLLOW_DEFAULT_STAGE;
  static const StageType BARE_INTERSECTION_UNPROTECTED_APPROACH =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_APPROACH;
  static const StageType BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_BARE_INTERSECTION_UNPROTECTED_INTERSECTION_CRUISE;
  static const StageType STOP_SIGN_UNPROTECTED_PRE_STOP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_PRE_STOP;
  static const StageType STOP_SIGN_UNPROTECTED_STOP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_STOP;
  static const StageType STOP_SIGN_UNPROTECTED_CREEP =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_CREEP;
  static const StageType STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_STOP_SIGN_UNPROTECTED_INTERSECTION_CRUISE;
  static const StageType TRAFFIC_LIGHT_PROTECTED_APPROACH =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_APPROACH;
  static const StageType TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_PROTECTED_INTERSECTION_CRUISE;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_APPROACH;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_CREEP;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_LEFT_TURN_INTERSECTION_CRUISE;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_STOP;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_CREEP;
  static const StageType TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE =
    ScenarioConfig_StageType_TRAFFIC_LIGHT_UNPROTECTED_RIGHT_TURN_INTERSECTION_CRUISE;
  static const StageType PULL_OVER_APPROACH =
    ScenarioConfig_StageType_PULL_OVER_APPROACH;
  static const StageType PULL_OVER_RETRY_APPROACH_PARKING =
    ScenarioConfig_StageType_PULL_OVER_RETRY_APPROACH_PARKING;
  static const StageType PULL_OVER_RETRY_PARKING =
    ScenarioConfig_StageType_PULL_OVER_RETRY_PARKING;
  static const StageType EMERGENCY_PULL_OVER_SLOW_DOWN =
    ScenarioConfig_StageType_EMERGENCY_PULL_OVER_SLOW_DOWN;
  static const StageType EMERGENCY_PULL_OVER_APPROACH =
    ScenarioConfig_StageType_EMERGENCY_PULL_OVER_APPROACH;
  static const StageType EMERGENCY_PULL_OVER_STANDBY =
    ScenarioConfig_StageType_EMERGENCY_PULL_OVER_STANDBY;
  static const StageType EMERGENCY_STOP_APPROACH =
    ScenarioConfig_StageType_EMERGENCY_STOP_APPROACH;
  static const StageType EMERGENCY_STOP_STANDBY =
    ScenarioConfig_StageType_EMERGENCY_STOP_STANDBY;
  static const StageType VALET_PARKING_APPROACHING_PARKING_SPOT =
    ScenarioConfig_StageType_VALET_PARKING_APPROACHING_PARKING_SPOT;
  static const StageType VALET_PARKING_PARKING =
    ScenarioConfig_StageType_VALET_PARKING_PARKING;
  static const StageType DEADEND_TURNAROUND_APPROACHING_TURNING_POINT =
    ScenarioConfig_StageType_DEADEND_TURNAROUND_APPROACHING_TURNING_POINT;
  static const StageType DEADEND_TURNAROUND_TURNING =
    ScenarioConfig_StageType_DEADEND_TURNAROUND_TURNING;
  static const StageType PARK_AND_GO_CHECK =
    ScenarioConfig_StageType_PARK_AND_GO_CHECK;
  static const StageType PARK_AND_GO_CRUISE =
    ScenarioConfig_StageType_PARK_AND_GO_CRUISE;
  static const StageType PARK_AND_GO_ADJUST =
    ScenarioConfig_StageType_PARK_AND_GO_ADJUST;
  static const StageType PARK_AND_GO_PRE_CRUISE =
    ScenarioConfig_StageType_PARK_AND_GO_PRE_CRUISE;
  static const StageType YIELD_SIGN_APPROACH =
    ScenarioConfig_StageType_YIELD_SIGN_APPROACH;
  static const StageType YIELD_SIGN_CREEP =
    ScenarioConfig_StageType_YIELD_SIGN_CREEP;
  static const StageType LEARNING_MODEL_RUN =
    ScenarioConfig_StageType_LEARNING_MODEL_RUN;
  static inline bool StageType_IsValid(int value) {
    return ScenarioConfig_StageType_IsValid(value);
  }
  static const StageType StageType_MIN =
    ScenarioConfig_StageType_StageType_MIN;
  static const StageType StageType_MAX =
    ScenarioConfig_StageType_StageType_MAX;
  static const int StageType_ARRAYSIZE =
    ScenarioConfig_StageType_StageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StageType_descriptor() {
    return ScenarioConfig_StageType_descriptor();
  }
  static inline const ::std::string& StageType_Name(StageType value) {
    return ScenarioConfig_StageType_Name(value);
  }
  static inline bool StageType_Parse(const ::std::string& name,
      StageType* value) {
    return ScenarioConfig_StageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.ScenarioConfig.StageType stage_type = 16;
  int stage_type_size() const;
  void clear_stage_type();
  static const int kStageTypeFieldNumber = 16;
  ::apollo::planning::ScenarioConfig_StageType stage_type(int index) const;
  void set_stage_type(int index, ::apollo::planning::ScenarioConfig_StageType value);
  void add_stage_type(::apollo::planning::ScenarioConfig_StageType value);
  const ::google::protobuf::RepeatedField<int>& stage_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_stage_type();

  // repeated .apollo.planning.ScenarioConfig.StageConfig stage_config = 17;
  int stage_config_size() const;
  void clear_stage_config();
  static const int kStageConfigFieldNumber = 17;
  ::apollo::planning::ScenarioConfig_StageConfig* mutable_stage_config(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >*
      mutable_stage_config();
  const ::apollo::planning::ScenarioConfig_StageConfig& stage_config(int index) const;
  ::apollo::planning::ScenarioConfig_StageConfig* add_stage_config();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >&
      stage_config() const;

  // optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
  bool has_scenario_type() const;
  void clear_scenario_type();
  static const int kScenarioTypeFieldNumber = 1;
  ::apollo::planning::ScenarioConfig_ScenarioType scenario_type() const;
  void set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value);

  // optional .apollo.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
  bool has_lane_follow_config() const;
  void clear_lane_follow_config();
  static const int kLaneFollowConfigFieldNumber = 2;
  private:
  const ::apollo::planning::ScenarioLaneFollowConfig& _internal_lane_follow_config() const;
  public:
  const ::apollo::planning::ScenarioLaneFollowConfig& lane_follow_config() const;
  ::apollo::planning::ScenarioLaneFollowConfig* release_lane_follow_config();
  ::apollo::planning::ScenarioLaneFollowConfig* mutable_lane_follow_config();
  void set_allocated_lane_follow_config(::apollo::planning::ScenarioLaneFollowConfig* lane_follow_config);

  // optional .apollo.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 3;
  bool has_bare_intersection_unprotected_config() const;
  void clear_bare_intersection_unprotected_config();
  static const int kBareIntersectionUnprotectedConfigFieldNumber = 3;
  private:
  const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& _internal_bare_intersection_unprotected_config() const;
  public:
  const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& bare_intersection_unprotected_config() const;
  ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* release_bare_intersection_unprotected_config();
  ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* mutable_bare_intersection_unprotected_config();
  void set_allocated_bare_intersection_unprotected_config(::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config);

  // optional .apollo.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 4;
  bool has_emergency_pull_over_config() const;
  void clear_emergency_pull_over_config();
  static const int kEmergencyPullOverConfigFieldNumber = 4;
  private:
  const ::apollo::planning::ScenarioEmergencyPullOverConfig& _internal_emergency_pull_over_config() const;
  public:
  const ::apollo::planning::ScenarioEmergencyPullOverConfig& emergency_pull_over_config() const;
  ::apollo::planning::ScenarioEmergencyPullOverConfig* release_emergency_pull_over_config();
  ::apollo::planning::ScenarioEmergencyPullOverConfig* mutable_emergency_pull_over_config();
  void set_allocated_emergency_pull_over_config(::apollo::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config);

  // optional .apollo.planning.ScenarioEmergencyStopConfig emergency_stop_config = 5;
  bool has_emergency_stop_config() const;
  void clear_emergency_stop_config();
  static const int kEmergencyStopConfigFieldNumber = 5;
  private:
  const ::apollo::planning::ScenarioEmergencyStopConfig& _internal_emergency_stop_config() const;
  public:
  const ::apollo::planning::ScenarioEmergencyStopConfig& emergency_stop_config() const;
  ::apollo::planning::ScenarioEmergencyStopConfig* release_emergency_stop_config();
  ::apollo::planning::ScenarioEmergencyStopConfig* mutable_emergency_stop_config();
  void set_allocated_emergency_stop_config(::apollo::planning::ScenarioEmergencyStopConfig* emergency_stop_config);

  // optional .apollo.planning.ScenarioLearningModelSampleConfig learning_model_sample_config = 6;
  bool has_learning_model_sample_config() const;
  void clear_learning_model_sample_config();
  static const int kLearningModelSampleConfigFieldNumber = 6;
  private:
  const ::apollo::planning::ScenarioLearningModelSampleConfig& _internal_learning_model_sample_config() const;
  public:
  const ::apollo::planning::ScenarioLearningModelSampleConfig& learning_model_sample_config() const;
  ::apollo::planning::ScenarioLearningModelSampleConfig* release_learning_model_sample_config();
  ::apollo::planning::ScenarioLearningModelSampleConfig* mutable_learning_model_sample_config();
  void set_allocated_learning_model_sample_config(::apollo::planning::ScenarioLearningModelSampleConfig* learning_model_sample_config);

  // optional .apollo.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
  bool has_narrow_street_u_turn_config() const;
  void clear_narrow_street_u_turn_config();
  static const int kNarrowStreetUTurnConfigFieldNumber = 7;
  private:
  const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& _internal_narrow_street_u_turn_config() const;
  public:
  const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& narrow_street_u_turn_config() const;
  ::apollo::planning::ScenarioNarrowStreetUTurnConfig* release_narrow_street_u_turn_config();
  ::apollo::planning::ScenarioNarrowStreetUTurnConfig* mutable_narrow_street_u_turn_config();
  void set_allocated_narrow_street_u_turn_config(::apollo::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config);

  // optional .apollo.planning.ScenarioParkAndGoConfig park_and_go_config = 8;
  bool has_park_and_go_config() const;
  void clear_park_and_go_config();
  static const int kParkAndGoConfigFieldNumber = 8;
  private:
  const ::apollo::planning::ScenarioParkAndGoConfig& _internal_park_and_go_config() const;
  public:
  const ::apollo::planning::ScenarioParkAndGoConfig& park_and_go_config() const;
  ::apollo::planning::ScenarioParkAndGoConfig* release_park_and_go_config();
  ::apollo::planning::ScenarioParkAndGoConfig* mutable_park_and_go_config();
  void set_allocated_park_and_go_config(::apollo::planning::ScenarioParkAndGoConfig* park_and_go_config);

  // optional .apollo.planning.ScenarioPullOverConfig pull_over_config = 9;
  bool has_pull_over_config() const;
  void clear_pull_over_config();
  static const int kPullOverConfigFieldNumber = 9;
  private:
  const ::apollo::planning::ScenarioPullOverConfig& _internal_pull_over_config() const;
  public:
  const ::apollo::planning::ScenarioPullOverConfig& pull_over_config() const;
  ::apollo::planning::ScenarioPullOverConfig* release_pull_over_config();
  ::apollo::planning::ScenarioPullOverConfig* mutable_pull_over_config();
  void set_allocated_pull_over_config(::apollo::planning::ScenarioPullOverConfig* pull_over_config);

  // optional .apollo.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 10;
  bool has_stop_sign_unprotected_config() const;
  void clear_stop_sign_unprotected_config();
  static const int kStopSignUnprotectedConfigFieldNumber = 10;
  private:
  const ::apollo::planning::ScenarioStopSignUnprotectedConfig& _internal_stop_sign_unprotected_config() const;
  public:
  const ::apollo::planning::ScenarioStopSignUnprotectedConfig& stop_sign_unprotected_config() const;
  ::apollo::planning::ScenarioStopSignUnprotectedConfig* release_stop_sign_unprotected_config();
  ::apollo::planning::ScenarioStopSignUnprotectedConfig* mutable_stop_sign_unprotected_config();
  void set_allocated_stop_sign_unprotected_config(::apollo::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config);

  // optional .apollo.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 11;
  bool has_traffic_light_protected_config() const;
  void clear_traffic_light_protected_config();
  static const int kTrafficLightProtectedConfigFieldNumber = 11;
  private:
  const ::apollo::planning::ScenarioTrafficLightProtectedConfig& _internal_traffic_light_protected_config() const;
  public:
  const ::apollo::planning::ScenarioTrafficLightProtectedConfig& traffic_light_protected_config() const;
  ::apollo::planning::ScenarioTrafficLightProtectedConfig* release_traffic_light_protected_config();
  ::apollo::planning::ScenarioTrafficLightProtectedConfig* mutable_traffic_light_protected_config();
  void set_allocated_traffic_light_protected_config(::apollo::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config);

  // optional .apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 12;
  bool has_traffic_light_unprotected_left_turn_config() const;
  void clear_traffic_light_unprotected_left_turn_config();
  static const int kTrafficLightUnprotectedLeftTurnConfigFieldNumber = 12;
  private:
  const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& _internal_traffic_light_unprotected_left_turn_config() const;
  public:
  const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& traffic_light_unprotected_left_turn_config() const;
  ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* release_traffic_light_unprotected_left_turn_config();
  ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* mutable_traffic_light_unprotected_left_turn_config();
  void set_allocated_traffic_light_unprotected_left_turn_config(::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config);

  // optional .apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 13;
  bool has_traffic_light_unprotected_right_turn_config() const;
  void clear_traffic_light_unprotected_right_turn_config();
  static const int kTrafficLightUnprotectedRightTurnConfigFieldNumber = 13;
  private:
  const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& _internal_traffic_light_unprotected_right_turn_config() const;
  public:
  const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& traffic_light_unprotected_right_turn_config() const;
  ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* release_traffic_light_unprotected_right_turn_config();
  ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* mutable_traffic_light_unprotected_right_turn_config();
  void set_allocated_traffic_light_unprotected_right_turn_config(::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config);

  // optional .apollo.planning.ScenarioValetParkingConfig valet_parking_config = 14;
  bool has_valet_parking_config() const;
  void clear_valet_parking_config();
  static const int kValetParkingConfigFieldNumber = 14;
  private:
  const ::apollo::planning::ScenarioValetParkingConfig& _internal_valet_parking_config() const;
  public:
  const ::apollo::planning::ScenarioValetParkingConfig& valet_parking_config() const;
  ::apollo::planning::ScenarioValetParkingConfig* release_valet_parking_config();
  ::apollo::planning::ScenarioValetParkingConfig* mutable_valet_parking_config();
  void set_allocated_valet_parking_config(::apollo::planning::ScenarioValetParkingConfig* valet_parking_config);

  // optional .apollo.planning.ScenarioYieldSignConfig yield_sign_config = 15;
  bool has_yield_sign_config() const;
  void clear_yield_sign_config();
  static const int kYieldSignConfigFieldNumber = 15;
  private:
  const ::apollo::planning::ScenarioYieldSignConfig& _internal_yield_sign_config() const;
  public:
  const ::apollo::planning::ScenarioYieldSignConfig& yield_sign_config() const;
  ::apollo::planning::ScenarioYieldSignConfig* release_yield_sign_config();
  ::apollo::planning::ScenarioYieldSignConfig* mutable_yield_sign_config();
  void set_allocated_yield_sign_config(::apollo::planning::ScenarioYieldSignConfig* yield_sign_config);

  // optional .apollo.planning.ScenarioDeadEndTurnAroundConfig deadend_turnaround_config = 18;
  bool has_deadend_turnaround_config() const;
  void clear_deadend_turnaround_config();
  static const int kDeadendTurnaroundConfigFieldNumber = 18;
  private:
  const ::apollo::planning::ScenarioDeadEndTurnAroundConfig& _internal_deadend_turnaround_config() const;
  public:
  const ::apollo::planning::ScenarioDeadEndTurnAroundConfig& deadend_turnaround_config() const;
  ::apollo::planning::ScenarioDeadEndTurnAroundConfig* release_deadend_turnaround_config();
  ::apollo::planning::ScenarioDeadEndTurnAroundConfig* mutable_deadend_turnaround_config();
  void set_allocated_deadend_turnaround_config(::apollo::planning::ScenarioDeadEndTurnAroundConfig* deadend_turnaround_config);

  void clear_scenario_config();
  ScenarioConfigCase scenario_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.ScenarioConfig)
 private:
  void set_has_scenario_type();
  void clear_has_scenario_type();
  void set_has_lane_follow_config();
  void set_has_bare_intersection_unprotected_config();
  void set_has_emergency_pull_over_config();
  void set_has_emergency_stop_config();
  void set_has_learning_model_sample_config();
  void set_has_narrow_street_u_turn_config();
  void set_has_park_and_go_config();
  void set_has_pull_over_config();
  void set_has_stop_sign_unprotected_config();
  void set_has_traffic_light_protected_config();
  void set_has_traffic_light_unprotected_left_turn_config();
  void set_has_traffic_light_unprotected_right_turn_config();
  void set_has_valet_parking_config();
  void set_has_yield_sign_config();
  void set_has_deadend_turnaround_config();

  inline bool has_scenario_config() const;
  inline void clear_has_scenario_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> stage_type_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig > stage_config_;
  int scenario_type_;
  union ScenarioConfigUnion {
    ScenarioConfigUnion() {}
    ::apollo::planning::ScenarioLaneFollowConfig* lane_follow_config_;
    ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* bare_intersection_unprotected_config_;
    ::apollo::planning::ScenarioEmergencyPullOverConfig* emergency_pull_over_config_;
    ::apollo::planning::ScenarioEmergencyStopConfig* emergency_stop_config_;
    ::apollo::planning::ScenarioLearningModelSampleConfig* learning_model_sample_config_;
    ::apollo::planning::ScenarioNarrowStreetUTurnConfig* narrow_street_u_turn_config_;
    ::apollo::planning::ScenarioParkAndGoConfig* park_and_go_config_;
    ::apollo::planning::ScenarioPullOverConfig* pull_over_config_;
    ::apollo::planning::ScenarioStopSignUnprotectedConfig* stop_sign_unprotected_config_;
    ::apollo::planning::ScenarioTrafficLightProtectedConfig* traffic_light_protected_config_;
    ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* traffic_light_unprotected_left_turn_config_;
    ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* traffic_light_unprotected_right_turn_config_;
    ::apollo::planning::ScenarioValetParkingConfig* valet_parking_config_;
    ::apollo::planning::ScenarioYieldSignConfig* yield_sign_config_;
    ::apollo::planning::ScenarioDeadEndTurnAroundConfig* deadend_turnaround_config_;
  } scenario_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlannerPublicRoadConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlannerPublicRoadConfig) */ {
 public:
  PlannerPublicRoadConfig();
  virtual ~PlannerPublicRoadConfig();

  PlannerPublicRoadConfig(const PlannerPublicRoadConfig& from);

  inline PlannerPublicRoadConfig& operator=(const PlannerPublicRoadConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerPublicRoadConfig(PlannerPublicRoadConfig&& from) noexcept
    : PlannerPublicRoadConfig() {
    *this = ::std::move(from);
  }

  inline PlannerPublicRoadConfig& operator=(PlannerPublicRoadConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerPublicRoadConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerPublicRoadConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerPublicRoadConfig*>(
               &_PlannerPublicRoadConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(PlannerPublicRoadConfig* other);
  friend void swap(PlannerPublicRoadConfig& a, PlannerPublicRoadConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerPublicRoadConfig* New() const final {
    return CreateMaybeMessage<PlannerPublicRoadConfig>(NULL);
  }

  PlannerPublicRoadConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlannerPublicRoadConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlannerPublicRoadConfig& from);
  void MergeFrom(const PlannerPublicRoadConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerPublicRoadConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.planning.PlannerPublicRoadConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlannerNaviConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlannerNaviConfig) */ {
 public:
  PlannerNaviConfig();
  virtual ~PlannerNaviConfig();

  PlannerNaviConfig(const PlannerNaviConfig& from);

  inline PlannerNaviConfig& operator=(const PlannerNaviConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerNaviConfig(PlannerNaviConfig&& from) noexcept
    : PlannerNaviConfig() {
    *this = ::std::move(from);
  }

  inline PlannerNaviConfig& operator=(PlannerNaviConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerNaviConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerNaviConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerNaviConfig*>(
               &_PlannerNaviConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(PlannerNaviConfig* other);
  friend void swap(PlannerNaviConfig& a, PlannerNaviConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerNaviConfig* New() const final {
    return CreateMaybeMessage<PlannerNaviConfig>(NULL);
  }

  PlannerNaviConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlannerNaviConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlannerNaviConfig& from);
  void MergeFrom(const PlannerNaviConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlannerNaviConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TaskConfig.TaskType task = 1;
  int task_size() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  ::apollo::planning::TaskConfig_TaskType task(int index) const;
  void set_task(int index, ::apollo::planning::TaskConfig_TaskType value);
  void add_task(::apollo::planning::TaskConfig_TaskType value);
  const ::google::protobuf::RepeatedField<int>& task() const;
  ::google::protobuf::RepeatedField<int>* mutable_task();

  // optional .apollo.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
  bool has_navi_path_decider_config() const;
  void clear_navi_path_decider_config();
  static const int kNaviPathDeciderConfigFieldNumber = 2;
  private:
  const ::apollo::planning::NaviPathDeciderConfig& _internal_navi_path_decider_config() const;
  public:
  const ::apollo::planning::NaviPathDeciderConfig& navi_path_decider_config() const;
  ::apollo::planning::NaviPathDeciderConfig* release_navi_path_decider_config();
  ::apollo::planning::NaviPathDeciderConfig* mutable_navi_path_decider_config();
  void set_allocated_navi_path_decider_config(::apollo::planning::NaviPathDeciderConfig* navi_path_decider_config);

  // optional .apollo.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
  bool has_navi_speed_decider_config() const;
  void clear_navi_speed_decider_config();
  static const int kNaviSpeedDeciderConfigFieldNumber = 3;
  private:
  const ::apollo::planning::NaviSpeedDeciderConfig& _internal_navi_speed_decider_config() const;
  public:
  const ::apollo::planning::NaviSpeedDeciderConfig& navi_speed_decider_config() const;
  ::apollo::planning::NaviSpeedDeciderConfig* release_navi_speed_decider_config();
  ::apollo::planning::NaviSpeedDeciderConfig* mutable_navi_speed_decider_config();
  void set_allocated_navi_speed_decider_config(::apollo::planning::NaviSpeedDeciderConfig* navi_speed_decider_config);

  // optional .apollo.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
  bool has_navi_obstacle_decider_config() const;
  void clear_navi_obstacle_decider_config();
  static const int kNaviObstacleDeciderConfigFieldNumber = 4;
  private:
  const ::apollo::planning::NaviObstacleDeciderConfig& _internal_navi_obstacle_decider_config() const;
  public:
  const ::apollo::planning::NaviObstacleDeciderConfig& navi_obstacle_decider_config() const;
  ::apollo::planning::NaviObstacleDeciderConfig* release_navi_obstacle_decider_config();
  ::apollo::planning::NaviObstacleDeciderConfig* mutable_navi_obstacle_decider_config();
  void set_allocated_navi_obstacle_decider_config(::apollo::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config);

  // @@protoc_insertion_point(class_scope:apollo.planning.PlannerNaviConfig)
 private:
  void set_has_navi_path_decider_config();
  void clear_has_navi_path_decider_config();
  void set_has_navi_speed_decider_config();
  void clear_has_navi_speed_decider_config();
  void set_has_navi_obstacle_decider_config();
  void clear_has_navi_obstacle_decider_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> task_;
  ::apollo::planning::NaviPathDeciderConfig* navi_path_decider_config_;
  ::apollo::planning::NaviSpeedDeciderConfig* navi_speed_decider_config_;
  ::apollo::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RtkPlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RtkPlanningConfig) */ {
 public:
  RtkPlanningConfig();
  virtual ~RtkPlanningConfig();

  RtkPlanningConfig(const RtkPlanningConfig& from);

  inline RtkPlanningConfig& operator=(const RtkPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RtkPlanningConfig(RtkPlanningConfig&& from) noexcept
    : RtkPlanningConfig() {
    *this = ::std::move(from);
  }

  inline RtkPlanningConfig& operator=(RtkPlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RtkPlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RtkPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const RtkPlanningConfig*>(
               &_RtkPlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RtkPlanningConfig* other);
  friend void swap(RtkPlanningConfig& a, RtkPlanningConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RtkPlanningConfig* New() const final {
    return CreateMaybeMessage<RtkPlanningConfig>(NULL);
  }

  RtkPlanningConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RtkPlanningConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RtkPlanningConfig& from);
  void MergeFrom(const RtkPlanningConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtkPlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.PlannerType planner_type = 1;
  bool has_planner_type() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::apollo::planning::PlannerType planner_type() const;
  void set_planner_type(::apollo::planning::PlannerType value);

  // @@protoc_insertion_point(class_scope:apollo.planning.RtkPlanningConfig)
 private:
  void set_has_planner_type();
  void clear_has_planner_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int planner_type_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StandardPlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StandardPlanningConfig) */ {
 public:
  StandardPlanningConfig();
  virtual ~StandardPlanningConfig();

  StandardPlanningConfig(const StandardPlanningConfig& from);

  inline StandardPlanningConfig& operator=(const StandardPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StandardPlanningConfig(StandardPlanningConfig&& from) noexcept
    : StandardPlanningConfig() {
    *this = ::std::move(from);
  }

  inline StandardPlanningConfig& operator=(StandardPlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StandardPlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const StandardPlanningConfig*>(
               &_StandardPlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(StandardPlanningConfig* other);
  friend void swap(StandardPlanningConfig& a, StandardPlanningConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StandardPlanningConfig* New() const final {
    return CreateMaybeMessage<StandardPlanningConfig>(NULL);
  }

  StandardPlanningConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StandardPlanningConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StandardPlanningConfig& from);
  void MergeFrom(const StandardPlanningConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardPlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.PlannerType planner_type = 1;
  int planner_type_size() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::apollo::planning::PlannerType planner_type(int index) const;
  void set_planner_type(int index, ::apollo::planning::PlannerType value);
  void add_planner_type(::apollo::planning::PlannerType value);
  const ::google::protobuf::RepeatedField<int>& planner_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_planner_type();

  // optional .apollo.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
  bool has_planner_public_road_config() const;
  void clear_planner_public_road_config();
  static const int kPlannerPublicRoadConfigFieldNumber = 2;
  private:
  const ::apollo::planning::PlannerPublicRoadConfig& _internal_planner_public_road_config() const;
  public:
  const ::apollo::planning::PlannerPublicRoadConfig& planner_public_road_config() const;
  ::apollo::planning::PlannerPublicRoadConfig* release_planner_public_road_config();
  ::apollo::planning::PlannerPublicRoadConfig* mutable_planner_public_road_config();
  void set_allocated_planner_public_road_config(::apollo::planning::PlannerPublicRoadConfig* planner_public_road_config);

  // @@protoc_insertion_point(class_scope:apollo.planning.StandardPlanningConfig)
 private:
  void set_has_planner_public_road_config();
  void clear_has_planner_public_road_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> planner_type_;
  ::apollo::planning::PlannerPublicRoadConfig* planner_public_road_config_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavigationPlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.NavigationPlanningConfig) */ {
 public:
  NavigationPlanningConfig();
  virtual ~NavigationPlanningConfig();

  NavigationPlanningConfig(const NavigationPlanningConfig& from);

  inline NavigationPlanningConfig& operator=(const NavigationPlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NavigationPlanningConfig(NavigationPlanningConfig&& from) noexcept
    : NavigationPlanningConfig() {
    *this = ::std::move(from);
  }

  inline NavigationPlanningConfig& operator=(NavigationPlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationPlanningConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationPlanningConfig* internal_default_instance() {
    return reinterpret_cast<const NavigationPlanningConfig*>(
               &_NavigationPlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(NavigationPlanningConfig* other);
  friend void swap(NavigationPlanningConfig& a, NavigationPlanningConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavigationPlanningConfig* New() const final {
    return CreateMaybeMessage<NavigationPlanningConfig>(NULL);
  }

  NavigationPlanningConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NavigationPlanningConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NavigationPlanningConfig& from);
  void MergeFrom(const NavigationPlanningConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationPlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.PlannerType planner_type = 1;
  int planner_type_size() const;
  void clear_planner_type();
  static const int kPlannerTypeFieldNumber = 1;
  ::apollo::planning::PlannerType planner_type(int index) const;
  void set_planner_type(int index, ::apollo::planning::PlannerType value);
  void add_planner_type(::apollo::planning::PlannerType value);
  const ::google::protobuf::RepeatedField<int>& planner_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_planner_type();

  // optional .apollo.planning.PlannerNaviConfig planner_navi_config = 4;
  bool has_planner_navi_config() const;
  void clear_planner_navi_config();
  static const int kPlannerNaviConfigFieldNumber = 4;
  private:
  const ::apollo::planning::PlannerNaviConfig& _internal_planner_navi_config() const;
  public:
  const ::apollo::planning::PlannerNaviConfig& planner_navi_config() const;
  ::apollo::planning::PlannerNaviConfig* release_planner_navi_config();
  ::apollo::planning::PlannerNaviConfig* mutable_planner_navi_config();
  void set_allocated_planner_navi_config(::apollo::planning::PlannerNaviConfig* planner_navi_config);

  // @@protoc_insertion_point(class_scope:apollo.planning.NavigationPlanningConfig)
 private:
  void set_has_planner_navi_config();
  void clear_has_planner_navi_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> planner_type_;
  ::apollo::planning::PlannerNaviConfig* planner_navi_config_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopicConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TopicConfig) */ {
 public:
  TopicConfig();
  virtual ~TopicConfig();

  TopicConfig(const TopicConfig& from);

  inline TopicConfig& operator=(const TopicConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopicConfig(TopicConfig&& from) noexcept
    : TopicConfig() {
    *this = ::std::move(from);
  }

  inline TopicConfig& operator=(TopicConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopicConfig* internal_default_instance() {
    return reinterpret_cast<const TopicConfig*>(
               &_TopicConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(TopicConfig* other);
  friend void swap(TopicConfig& a, TopicConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopicConfig* New() const final {
    return CreateMaybeMessage<TopicConfig>(NULL);
  }

  TopicConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TopicConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TopicConfig& from);
  void MergeFrom(const TopicConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string chassis_topic = 1;
  bool has_chassis_topic() const;
  void clear_chassis_topic();
  static const int kChassisTopicFieldNumber = 1;
  const ::std::string& chassis_topic() const;
  void set_chassis_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_chassis_topic(::std::string&& value);
  #endif
  void set_chassis_topic(const char* value);
  void set_chassis_topic(const char* value, size_t size);
  ::std::string* mutable_chassis_topic();
  ::std::string* release_chassis_topic();
  void set_allocated_chassis_topic(::std::string* chassis_topic);

  // optional string hmi_status_topic = 2;
  bool has_hmi_status_topic() const;
  void clear_hmi_status_topic();
  static const int kHmiStatusTopicFieldNumber = 2;
  const ::std::string& hmi_status_topic() const;
  void set_hmi_status_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_hmi_status_topic(::std::string&& value);
  #endif
  void set_hmi_status_topic(const char* value);
  void set_hmi_status_topic(const char* value, size_t size);
  ::std::string* mutable_hmi_status_topic();
  ::std::string* release_hmi_status_topic();
  void set_allocated_hmi_status_topic(::std::string* hmi_status_topic);

  // optional string localization_topic = 3;
  bool has_localization_topic() const;
  void clear_localization_topic();
  static const int kLocalizationTopicFieldNumber = 3;
  const ::std::string& localization_topic() const;
  void set_localization_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_localization_topic(::std::string&& value);
  #endif
  void set_localization_topic(const char* value);
  void set_localization_topic(const char* value, size_t size);
  ::std::string* mutable_localization_topic();
  ::std::string* release_localization_topic();
  void set_allocated_localization_topic(::std::string* localization_topic);

  // optional string planning_pad_topic = 4;
  bool has_planning_pad_topic() const;
  void clear_planning_pad_topic();
  static const int kPlanningPadTopicFieldNumber = 4;
  const ::std::string& planning_pad_topic() const;
  void set_planning_pad_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_planning_pad_topic(::std::string&& value);
  #endif
  void set_planning_pad_topic(const char* value);
  void set_planning_pad_topic(const char* value, size_t size);
  ::std::string* mutable_planning_pad_topic();
  ::std::string* release_planning_pad_topic();
  void set_allocated_planning_pad_topic(::std::string* planning_pad_topic);

  // optional string planning_trajectory_topic = 5;
  bool has_planning_trajectory_topic() const;
  void clear_planning_trajectory_topic();
  static const int kPlanningTrajectoryTopicFieldNumber = 5;
  const ::std::string& planning_trajectory_topic() const;
  void set_planning_trajectory_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_planning_trajectory_topic(::std::string&& value);
  #endif
  void set_planning_trajectory_topic(const char* value);
  void set_planning_trajectory_topic(const char* value, size_t size);
  ::std::string* mutable_planning_trajectory_topic();
  ::std::string* release_planning_trajectory_topic();
  void set_allocated_planning_trajectory_topic(::std::string* planning_trajectory_topic);

  // optional string prediction_topic = 6;
  bool has_prediction_topic() const;
  void clear_prediction_topic();
  static const int kPredictionTopicFieldNumber = 6;
  const ::std::string& prediction_topic() const;
  void set_prediction_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_prediction_topic(::std::string&& value);
  #endif
  void set_prediction_topic(const char* value);
  void set_prediction_topic(const char* value, size_t size);
  ::std::string* mutable_prediction_topic();
  ::std::string* release_prediction_topic();
  void set_allocated_prediction_topic(::std::string* prediction_topic);

  // optional string relative_map_topic = 7;
  bool has_relative_map_topic() const;
  void clear_relative_map_topic();
  static const int kRelativeMapTopicFieldNumber = 7;
  const ::std::string& relative_map_topic() const;
  void set_relative_map_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_relative_map_topic(::std::string&& value);
  #endif
  void set_relative_map_topic(const char* value);
  void set_relative_map_topic(const char* value, size_t size);
  ::std::string* mutable_relative_map_topic();
  ::std::string* release_relative_map_topic();
  void set_allocated_relative_map_topic(::std::string* relative_map_topic);

  // optional string routing_request_topic = 8;
  bool has_routing_request_topic() const;
  void clear_routing_request_topic();
  static const int kRoutingRequestTopicFieldNumber = 8;
  const ::std::string& routing_request_topic() const;
  void set_routing_request_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_routing_request_topic(::std::string&& value);
  #endif
  void set_routing_request_topic(const char* value);
  void set_routing_request_topic(const char* value, size_t size);
  ::std::string* mutable_routing_request_topic();
  ::std::string* release_routing_request_topic();
  void set_allocated_routing_request_topic(::std::string* routing_request_topic);

  // optional string routing_response_topic = 9;
  bool has_routing_response_topic() const;
  void clear_routing_response_topic();
  static const int kRoutingResponseTopicFieldNumber = 9;
  const ::std::string& routing_response_topic() const;
  void set_routing_response_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_routing_response_topic(::std::string&& value);
  #endif
  void set_routing_response_topic(const char* value);
  void set_routing_response_topic(const char* value, size_t size);
  ::std::string* mutable_routing_response_topic();
  ::std::string* release_routing_response_topic();
  void set_allocated_routing_response_topic(::std::string* routing_response_topic);

  // optional string story_telling_topic = 10;
  bool has_story_telling_topic() const;
  void clear_story_telling_topic();
  static const int kStoryTellingTopicFieldNumber = 10;
  const ::std::string& story_telling_topic() const;
  void set_story_telling_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_story_telling_topic(::std::string&& value);
  #endif
  void set_story_telling_topic(const char* value);
  void set_story_telling_topic(const char* value, size_t size);
  ::std::string* mutable_story_telling_topic();
  ::std::string* release_story_telling_topic();
  void set_allocated_story_telling_topic(::std::string* story_telling_topic);

  // optional string traffic_light_detection_topic = 11;
  bool has_traffic_light_detection_topic() const;
  void clear_traffic_light_detection_topic();
  static const int kTrafficLightDetectionTopicFieldNumber = 11;
  const ::std::string& traffic_light_detection_topic() const;
  void set_traffic_light_detection_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_traffic_light_detection_topic(::std::string&& value);
  #endif
  void set_traffic_light_detection_topic(const char* value);
  void set_traffic_light_detection_topic(const char* value, size_t size);
  ::std::string* mutable_traffic_light_detection_topic();
  ::std::string* release_traffic_light_detection_topic();
  void set_allocated_traffic_light_detection_topic(::std::string* traffic_light_detection_topic);

  // optional string planning_learning_data_topic = 12;
  bool has_planning_learning_data_topic() const;
  void clear_planning_learning_data_topic();
  static const int kPlanningLearningDataTopicFieldNumber = 12;
  const ::std::string& planning_learning_data_topic() const;
  void set_planning_learning_data_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_planning_learning_data_topic(::std::string&& value);
  #endif
  void set_planning_learning_data_topic(const char* value);
  void set_planning_learning_data_topic(const char* value, size_t size);
  ::std::string* mutable_planning_learning_data_topic();
  ::std::string* release_planning_learning_data_topic();
  void set_allocated_planning_learning_data_topic(::std::string* planning_learning_data_topic);

  // @@protoc_insertion_point(class_scope:apollo.planning.TopicConfig)
 private:
  void set_has_chassis_topic();
  void clear_has_chassis_topic();
  void set_has_hmi_status_topic();
  void clear_has_hmi_status_topic();
  void set_has_localization_topic();
  void clear_has_localization_topic();
  void set_has_planning_pad_topic();
  void clear_has_planning_pad_topic();
  void set_has_planning_trajectory_topic();
  void clear_has_planning_trajectory_topic();
  void set_has_prediction_topic();
  void clear_has_prediction_topic();
  void set_has_relative_map_topic();
  void clear_has_relative_map_topic();
  void set_has_routing_request_topic();
  void clear_has_routing_request_topic();
  void set_has_routing_response_topic();
  void clear_has_routing_response_topic();
  void set_has_story_telling_topic();
  void clear_has_story_telling_topic();
  void set_has_traffic_light_detection_topic();
  void clear_has_traffic_light_detection_topic();
  void set_has_planning_learning_data_topic();
  void clear_has_planning_learning_data_topic();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chassis_topic_;
  ::google::protobuf::internal::ArenaStringPtr hmi_status_topic_;
  ::google::protobuf::internal::ArenaStringPtr localization_topic_;
  ::google::protobuf::internal::ArenaStringPtr planning_pad_topic_;
  ::google::protobuf::internal::ArenaStringPtr planning_trajectory_topic_;
  ::google::protobuf::internal::ArenaStringPtr prediction_topic_;
  ::google::protobuf::internal::ArenaStringPtr relative_map_topic_;
  ::google::protobuf::internal::ArenaStringPtr routing_request_topic_;
  ::google::protobuf::internal::ArenaStringPtr routing_response_topic_;
  ::google::protobuf::internal::ArenaStringPtr story_telling_topic_;
  ::google::protobuf::internal::ArenaStringPtr traffic_light_detection_topic_;
  ::google::protobuf::internal::ArenaStringPtr planning_learning_data_topic_;
  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanningConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningConfig) */ {
 public:
  PlanningConfig();
  virtual ~PlanningConfig();

  PlanningConfig(const PlanningConfig& from);

  inline PlanningConfig& operator=(const PlanningConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanningConfig(PlanningConfig&& from) noexcept
    : PlanningConfig() {
    *this = ::std::move(from);
  }

  inline PlanningConfig& operator=(PlanningConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningConfig& default_instance();

  enum PlanningConfigCase {
    kRtkPlanningConfig = 3,
    kStandardPlanningConfig = 4,
    kNavigationPlanningConfig = 5,
    PLANNING_CONFIG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanningConfig* internal_default_instance() {
    return reinterpret_cast<const PlanningConfig*>(
               &_PlanningConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(PlanningConfig* other);
  friend void swap(PlanningConfig& a, PlanningConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanningConfig* New() const final {
    return CreateMaybeMessage<PlanningConfig>(NULL);
  }

  PlanningConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanningConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanningConfig& from);
  void MergeFrom(const PlanningConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanningConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PlanningConfig_PlanningLearningMode PlanningLearningMode;
  static const PlanningLearningMode NO_LEARNING =
    PlanningConfig_PlanningLearningMode_NO_LEARNING;
  static const PlanningLearningMode E2E =
    PlanningConfig_PlanningLearningMode_E2E;
  static const PlanningLearningMode HYBRID =
    PlanningConfig_PlanningLearningMode_HYBRID;
  static const PlanningLearningMode RL_TEST =
    PlanningConfig_PlanningLearningMode_RL_TEST;
  static const PlanningLearningMode E2E_TEST =
    PlanningConfig_PlanningLearningMode_E2E_TEST;
  static const PlanningLearningMode HYBRID_TEST =
    PlanningConfig_PlanningLearningMode_HYBRID_TEST;
  static inline bool PlanningLearningMode_IsValid(int value) {
    return PlanningConfig_PlanningLearningMode_IsValid(value);
  }
  static const PlanningLearningMode PlanningLearningMode_MIN =
    PlanningConfig_PlanningLearningMode_PlanningLearningMode_MIN;
  static const PlanningLearningMode PlanningLearningMode_MAX =
    PlanningConfig_PlanningLearningMode_PlanningLearningMode_MAX;
  static const int PlanningLearningMode_ARRAYSIZE =
    PlanningConfig_PlanningLearningMode_PlanningLearningMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlanningLearningMode_descriptor() {
    return PlanningConfig_PlanningLearningMode_descriptor();
  }
  static inline const ::std::string& PlanningLearningMode_Name(PlanningLearningMode value) {
    return PlanningConfig_PlanningLearningMode_Name(value);
  }
  static inline bool PlanningLearningMode_Parse(const ::std::string& name,
      PlanningLearningMode* value) {
    return PlanningConfig_PlanningLearningMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TaskConfig default_task_config = 6;
  int default_task_config_size() const;
  void clear_default_task_config();
  static const int kDefaultTaskConfigFieldNumber = 6;
  ::apollo::planning::TaskConfig* mutable_default_task_config(int index);
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >*
      mutable_default_task_config();
  const ::apollo::planning::TaskConfig& default_task_config(int index) const;
  ::apollo::planning::TaskConfig* add_default_task_config();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >&
      default_task_config() const;

  // optional .apollo.planning.TopicConfig topic_config = 1;
  bool has_topic_config() const;
  void clear_topic_config();
  static const int kTopicConfigFieldNumber = 1;
  private:
  const ::apollo::planning::TopicConfig& _internal_topic_config() const;
  public:
  const ::apollo::planning::TopicConfig& topic_config() const;
  ::apollo::planning::TopicConfig* release_topic_config();
  ::apollo::planning::TopicConfig* mutable_topic_config();
  void set_allocated_topic_config(::apollo::planning::TopicConfig* topic_config);

  // optional .apollo.planning.PlanningConfig.PlanningLearningMode learning_mode = 2;
  bool has_learning_mode() const;
  void clear_learning_mode();
  static const int kLearningModeFieldNumber = 2;
  ::apollo::planning::PlanningConfig_PlanningLearningMode learning_mode() const;
  void set_learning_mode(::apollo::planning::PlanningConfig_PlanningLearningMode value);

  // optional .apollo.planning.RtkPlanningConfig rtk_planning_config = 3;
  bool has_rtk_planning_config() const;
  void clear_rtk_planning_config();
  static const int kRtkPlanningConfigFieldNumber = 3;
  private:
  const ::apollo::planning::RtkPlanningConfig& _internal_rtk_planning_config() const;
  public:
  const ::apollo::planning::RtkPlanningConfig& rtk_planning_config() const;
  ::apollo::planning::RtkPlanningConfig* release_rtk_planning_config();
  ::apollo::planning::RtkPlanningConfig* mutable_rtk_planning_config();
  void set_allocated_rtk_planning_config(::apollo::planning::RtkPlanningConfig* rtk_planning_config);

  // optional .apollo.planning.StandardPlanningConfig standard_planning_config = 4;
  bool has_standard_planning_config() const;
  void clear_standard_planning_config();
  static const int kStandardPlanningConfigFieldNumber = 4;
  private:
  const ::apollo::planning::StandardPlanningConfig& _internal_standard_planning_config() const;
  public:
  const ::apollo::planning::StandardPlanningConfig& standard_planning_config() const;
  ::apollo::planning::StandardPlanningConfig* release_standard_planning_config();
  ::apollo::planning::StandardPlanningConfig* mutable_standard_planning_config();
  void set_allocated_standard_planning_config(::apollo::planning::StandardPlanningConfig* standard_planning_config);

  // optional .apollo.planning.NavigationPlanningConfig navigation_planning_config = 5;
  bool has_navigation_planning_config() const;
  void clear_navigation_planning_config();
  static const int kNavigationPlanningConfigFieldNumber = 5;
  private:
  const ::apollo::planning::NavigationPlanningConfig& _internal_navigation_planning_config() const;
  public:
  const ::apollo::planning::NavigationPlanningConfig& navigation_planning_config() const;
  ::apollo::planning::NavigationPlanningConfig* release_navigation_planning_config();
  ::apollo::planning::NavigationPlanningConfig* mutable_navigation_planning_config();
  void set_allocated_navigation_planning_config(::apollo::planning::NavigationPlanningConfig* navigation_planning_config);

  void clear_planning_config();
  PlanningConfigCase planning_config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningConfig)
 private:
  void set_has_topic_config();
  void clear_has_topic_config();
  void set_has_learning_mode();
  void clear_has_learning_mode();
  void set_has_rtk_planning_config();
  void set_has_standard_planning_config();
  void set_has_navigation_planning_config();

  inline bool has_planning_config() const;
  inline void clear_has_planning_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig > default_task_config_;
  ::apollo::planning::TopicConfig* topic_config_;
  int learning_mode_;
  union PlanningConfigUnion {
    PlanningConfigUnion() {}
    ::apollo::planning::RtkPlanningConfig* rtk_planning_config_;
    ::apollo::planning::StandardPlanningConfig* standard_planning_config_;
    ::apollo::planning::NavigationPlanningConfig* navigation_planning_config_;
  } planning_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TaskConfig

// optional .apollo.planning.TaskConfig.TaskType task_type = 1;
inline bool TaskConfig::has_task_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskConfig::set_has_task_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskConfig::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskConfig::clear_task_type() {
  task_type_ = 1;
  clear_has_task_type();
}
inline ::apollo::planning::TaskConfig_TaskType TaskConfig::task_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.task_type)
  return static_cast< ::apollo::planning::TaskConfig_TaskType >(task_type_);
}
inline void TaskConfig::set_task_type(::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  set_has_task_type();
  task_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TaskConfig.task_type)
}

// optional .apollo.planning.CreepDeciderConfig creep_decider_config = 2;
inline bool TaskConfig::has_creep_decider_config() const {
  return task_config_case() == kCreepDeciderConfig;
}
inline void TaskConfig::set_has_creep_decider_config() {
  _oneof_case_[0] = kCreepDeciderConfig;
}
inline const ::apollo::planning::CreepDeciderConfig& TaskConfig::_internal_creep_decider_config() const {
  return *task_config_.creep_decider_config_;
}
inline ::apollo::planning::CreepDeciderConfig* TaskConfig::release_creep_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.creep_decider_config)
  if (has_creep_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::CreepDeciderConfig* temp = task_config_.creep_decider_config_;
    task_config_.creep_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::CreepDeciderConfig& TaskConfig::creep_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.creep_decider_config)
  return has_creep_decider_config()
      ? *task_config_.creep_decider_config_
      : *reinterpret_cast< ::apollo::planning::CreepDeciderConfig*>(&::apollo::planning::_CreepDeciderConfig_default_instance_);
}
inline ::apollo::planning::CreepDeciderConfig* TaskConfig::mutable_creep_decider_config() {
  if (!has_creep_decider_config()) {
    clear_task_config();
    set_has_creep_decider_config();
    task_config_.creep_decider_config_ = CreateMaybeMessage< ::apollo::planning::CreepDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.creep_decider_config)
  return task_config_.creep_decider_config_;
}

// optional .apollo.planning.LaneChangeDeciderConfig lane_change_decider_config = 3;
inline bool TaskConfig::has_lane_change_decider_config() const {
  return task_config_case() == kLaneChangeDeciderConfig;
}
inline void TaskConfig::set_has_lane_change_decider_config() {
  _oneof_case_[0] = kLaneChangeDeciderConfig;
}
inline const ::apollo::planning::LaneChangeDeciderConfig& TaskConfig::_internal_lane_change_decider_config() const {
  return *task_config_.lane_change_decider_config_;
}
inline ::apollo::planning::LaneChangeDeciderConfig* TaskConfig::release_lane_change_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.lane_change_decider_config)
  if (has_lane_change_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::LaneChangeDeciderConfig* temp = task_config_.lane_change_decider_config_;
    task_config_.lane_change_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::LaneChangeDeciderConfig& TaskConfig::lane_change_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.lane_change_decider_config)
  return has_lane_change_decider_config()
      ? *task_config_.lane_change_decider_config_
      : *reinterpret_cast< ::apollo::planning::LaneChangeDeciderConfig*>(&::apollo::planning::_LaneChangeDeciderConfig_default_instance_);
}
inline ::apollo::planning::LaneChangeDeciderConfig* TaskConfig::mutable_lane_change_decider_config() {
  if (!has_lane_change_decider_config()) {
    clear_task_config();
    set_has_lane_change_decider_config();
    task_config_.lane_change_decider_config_ = CreateMaybeMessage< ::apollo::planning::LaneChangeDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.lane_change_decider_config)
  return task_config_.lane_change_decider_config_;
}

// optional .apollo.planning.OpenSpaceFallBackDeciderConfig open_space_fallback_decider_config = 4;
inline bool TaskConfig::has_open_space_fallback_decider_config() const {
  return task_config_case() == kOpenSpaceFallbackDeciderConfig;
}
inline void TaskConfig::set_has_open_space_fallback_decider_config() {
  _oneof_case_[0] = kOpenSpaceFallbackDeciderConfig;
}
inline const ::apollo::planning::OpenSpaceFallBackDeciderConfig& TaskConfig::_internal_open_space_fallback_decider_config() const {
  return *task_config_.open_space_fallback_decider_config_;
}
inline ::apollo::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::release_open_space_fallback_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_fallback_decider_config)
  if (has_open_space_fallback_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceFallBackDeciderConfig* temp = task_config_.open_space_fallback_decider_config_;
    task_config_.open_space_fallback_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::OpenSpaceFallBackDeciderConfig& TaskConfig::open_space_fallback_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_fallback_decider_config)
  return has_open_space_fallback_decider_config()
      ? *task_config_.open_space_fallback_decider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceFallBackDeciderConfig*>(&::apollo::planning::_OpenSpaceFallBackDeciderConfig_default_instance_);
}
inline ::apollo::planning::OpenSpaceFallBackDeciderConfig* TaskConfig::mutable_open_space_fallback_decider_config() {
  if (!has_open_space_fallback_decider_config()) {
    clear_task_config();
    set_has_open_space_fallback_decider_config();
    task_config_.open_space_fallback_decider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceFallBackDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_fallback_decider_config)
  return task_config_.open_space_fallback_decider_config_;
}

// optional .apollo.planning.OpenSpacePreStopDeciderConfig open_space_pre_stop_decider_config = 5;
inline bool TaskConfig::has_open_space_pre_stop_decider_config() const {
  return task_config_case() == kOpenSpacePreStopDeciderConfig;
}
inline void TaskConfig::set_has_open_space_pre_stop_decider_config() {
  _oneof_case_[0] = kOpenSpacePreStopDeciderConfig;
}
inline const ::apollo::planning::OpenSpacePreStopDeciderConfig& TaskConfig::_internal_open_space_pre_stop_decider_config() const {
  return *task_config_.open_space_pre_stop_decider_config_;
}
inline ::apollo::planning::OpenSpacePreStopDeciderConfig* TaskConfig::release_open_space_pre_stop_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_pre_stop_decider_config)
  if (has_open_space_pre_stop_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpacePreStopDeciderConfig* temp = task_config_.open_space_pre_stop_decider_config_;
    task_config_.open_space_pre_stop_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::OpenSpacePreStopDeciderConfig& TaskConfig::open_space_pre_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_pre_stop_decider_config)
  return has_open_space_pre_stop_decider_config()
      ? *task_config_.open_space_pre_stop_decider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpacePreStopDeciderConfig*>(&::apollo::planning::_OpenSpacePreStopDeciderConfig_default_instance_);
}
inline ::apollo::planning::OpenSpacePreStopDeciderConfig* TaskConfig::mutable_open_space_pre_stop_decider_config() {
  if (!has_open_space_pre_stop_decider_config()) {
    clear_task_config();
    set_has_open_space_pre_stop_decider_config();
    task_config_.open_space_pre_stop_decider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpacePreStopDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_pre_stop_decider_config)
  return task_config_.open_space_pre_stop_decider_config_;
}

// optional .apollo.planning.OpenSpaceRoiDeciderConfig open_space_roi_decider_config = 6;
inline bool TaskConfig::has_open_space_roi_decider_config() const {
  return task_config_case() == kOpenSpaceRoiDeciderConfig;
}
inline void TaskConfig::set_has_open_space_roi_decider_config() {
  _oneof_case_[0] = kOpenSpaceRoiDeciderConfig;
}
inline const ::apollo::planning::OpenSpaceRoiDeciderConfig& TaskConfig::_internal_open_space_roi_decider_config() const {
  return *task_config_.open_space_roi_decider_config_;
}
inline ::apollo::planning::OpenSpaceRoiDeciderConfig* TaskConfig::release_open_space_roi_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_roi_decider_config)
  if (has_open_space_roi_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceRoiDeciderConfig* temp = task_config_.open_space_roi_decider_config_;
    task_config_.open_space_roi_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::OpenSpaceRoiDeciderConfig& TaskConfig::open_space_roi_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_roi_decider_config)
  return has_open_space_roi_decider_config()
      ? *task_config_.open_space_roi_decider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceRoiDeciderConfig*>(&::apollo::planning::_OpenSpaceRoiDeciderConfig_default_instance_);
}
inline ::apollo::planning::OpenSpaceRoiDeciderConfig* TaskConfig::mutable_open_space_roi_decider_config() {
  if (!has_open_space_roi_decider_config()) {
    clear_task_config();
    set_has_open_space_roi_decider_config();
    task_config_.open_space_roi_decider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceRoiDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_roi_decider_config)
  return task_config_.open_space_roi_decider_config_;
}

// optional .apollo.planning.PathAssessmentDeciderConfig path_assessment_decider_config = 7;
inline bool TaskConfig::has_path_assessment_decider_config() const {
  return task_config_case() == kPathAssessmentDeciderConfig;
}
inline void TaskConfig::set_has_path_assessment_decider_config() {
  _oneof_case_[0] = kPathAssessmentDeciderConfig;
}
inline const ::apollo::planning::PathAssessmentDeciderConfig& TaskConfig::_internal_path_assessment_decider_config() const {
  return *task_config_.path_assessment_decider_config_;
}
inline ::apollo::planning::PathAssessmentDeciderConfig* TaskConfig::release_path_assessment_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_assessment_decider_config)
  if (has_path_assessment_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathAssessmentDeciderConfig* temp = task_config_.path_assessment_decider_config_;
    task_config_.path_assessment_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PathAssessmentDeciderConfig& TaskConfig::path_assessment_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_assessment_decider_config)
  return has_path_assessment_decider_config()
      ? *task_config_.path_assessment_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathAssessmentDeciderConfig*>(&::apollo::planning::_PathAssessmentDeciderConfig_default_instance_);
}
inline ::apollo::planning::PathAssessmentDeciderConfig* TaskConfig::mutable_path_assessment_decider_config() {
  if (!has_path_assessment_decider_config()) {
    clear_task_config();
    set_has_path_assessment_decider_config();
    task_config_.path_assessment_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathAssessmentDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_assessment_decider_config)
  return task_config_.path_assessment_decider_config_;
}

// optional .apollo.planning.PathBoundsDeciderConfig path_bounds_decider_config = 8;
inline bool TaskConfig::has_path_bounds_decider_config() const {
  return task_config_case() == kPathBoundsDeciderConfig;
}
inline void TaskConfig::set_has_path_bounds_decider_config() {
  _oneof_case_[0] = kPathBoundsDeciderConfig;
}
inline const ::apollo::planning::PathBoundsDeciderConfig& TaskConfig::_internal_path_bounds_decider_config() const {
  return *task_config_.path_bounds_decider_config_;
}
inline ::apollo::planning::PathBoundsDeciderConfig* TaskConfig::release_path_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_bounds_decider_config)
  if (has_path_bounds_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathBoundsDeciderConfig* temp = task_config_.path_bounds_decider_config_;
    task_config_.path_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PathBoundsDeciderConfig& TaskConfig::path_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_bounds_decider_config)
  return has_path_bounds_decider_config()
      ? *task_config_.path_bounds_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathBoundsDeciderConfig*>(&::apollo::planning::_PathBoundsDeciderConfig_default_instance_);
}
inline ::apollo::planning::PathBoundsDeciderConfig* TaskConfig::mutable_path_bounds_decider_config() {
  if (!has_path_bounds_decider_config()) {
    clear_task_config();
    set_has_path_bounds_decider_config();
    task_config_.path_bounds_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathBoundsDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_bounds_decider_config)
  return task_config_.path_bounds_decider_config_;
}

// optional .apollo.planning.PathDeciderConfig path_decider_config = 9;
inline bool TaskConfig::has_path_decider_config() const {
  return task_config_case() == kPathDeciderConfig;
}
inline void TaskConfig::set_has_path_decider_config() {
  _oneof_case_[0] = kPathDeciderConfig;
}
inline const ::apollo::planning::PathDeciderConfig& TaskConfig::_internal_path_decider_config() const {
  return *task_config_.path_decider_config_;
}
inline ::apollo::planning::PathDeciderConfig* TaskConfig::release_path_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_decider_config)
  if (has_path_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathDeciderConfig* temp = task_config_.path_decider_config_;
    task_config_.path_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PathDeciderConfig& TaskConfig::path_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_decider_config)
  return has_path_decider_config()
      ? *task_config_.path_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathDeciderConfig*>(&::apollo::planning::_PathDeciderConfig_default_instance_);
}
inline ::apollo::planning::PathDeciderConfig* TaskConfig::mutable_path_decider_config() {
  if (!has_path_decider_config()) {
    clear_task_config();
    set_has_path_decider_config();
    task_config_.path_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_decider_config)
  return task_config_.path_decider_config_;
}

// optional .apollo.planning.PathLaneBorrowDeciderConfig path_lane_borrow_decider_config = 10;
inline bool TaskConfig::has_path_lane_borrow_decider_config() const {
  return task_config_case() == kPathLaneBorrowDeciderConfig;
}
inline void TaskConfig::set_has_path_lane_borrow_decider_config() {
  _oneof_case_[0] = kPathLaneBorrowDeciderConfig;
}
inline const ::apollo::planning::PathLaneBorrowDeciderConfig& TaskConfig::_internal_path_lane_borrow_decider_config() const {
  return *task_config_.path_lane_borrow_decider_config_;
}
inline ::apollo::planning::PathLaneBorrowDeciderConfig* TaskConfig::release_path_lane_borrow_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_lane_borrow_decider_config)
  if (has_path_lane_borrow_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathLaneBorrowDeciderConfig* temp = task_config_.path_lane_borrow_decider_config_;
    task_config_.path_lane_borrow_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PathLaneBorrowDeciderConfig& TaskConfig::path_lane_borrow_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_lane_borrow_decider_config)
  return has_path_lane_borrow_decider_config()
      ? *task_config_.path_lane_borrow_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathLaneBorrowDeciderConfig*>(&::apollo::planning::_PathLaneBorrowDeciderConfig_default_instance_);
}
inline ::apollo::planning::PathLaneBorrowDeciderConfig* TaskConfig::mutable_path_lane_borrow_decider_config() {
  if (!has_path_lane_borrow_decider_config()) {
    clear_task_config();
    set_has_path_lane_borrow_decider_config();
    task_config_.path_lane_borrow_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathLaneBorrowDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_lane_borrow_decider_config)
  return task_config_.path_lane_borrow_decider_config_;
}

// optional .apollo.planning.PathReferenceDeciderConfig path_reference_decider_config = 11;
inline bool TaskConfig::has_path_reference_decider_config() const {
  return task_config_case() == kPathReferenceDeciderConfig;
}
inline void TaskConfig::set_has_path_reference_decider_config() {
  _oneof_case_[0] = kPathReferenceDeciderConfig;
}
inline const ::apollo::planning::PathReferenceDeciderConfig& TaskConfig::_internal_path_reference_decider_config() const {
  return *task_config_.path_reference_decider_config_;
}
inline ::apollo::planning::PathReferenceDeciderConfig* TaskConfig::release_path_reference_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_reference_decider_config)
  if (has_path_reference_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathReferenceDeciderConfig* temp = task_config_.path_reference_decider_config_;
    task_config_.path_reference_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PathReferenceDeciderConfig& TaskConfig::path_reference_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_reference_decider_config)
  return has_path_reference_decider_config()
      ? *task_config_.path_reference_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathReferenceDeciderConfig*>(&::apollo::planning::_PathReferenceDeciderConfig_default_instance_);
}
inline ::apollo::planning::PathReferenceDeciderConfig* TaskConfig::mutable_path_reference_decider_config() {
  if (!has_path_reference_decider_config()) {
    clear_task_config();
    set_has_path_reference_decider_config();
    task_config_.path_reference_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathReferenceDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_reference_decider_config)
  return task_config_.path_reference_decider_config_;
}

// optional .apollo.planning.PathReuseDeciderConfig path_reuse_decider_config = 12;
inline bool TaskConfig::has_path_reuse_decider_config() const {
  return task_config_case() == kPathReuseDeciderConfig;
}
inline void TaskConfig::set_has_path_reuse_decider_config() {
  _oneof_case_[0] = kPathReuseDeciderConfig;
}
inline const ::apollo::planning::PathReuseDeciderConfig& TaskConfig::_internal_path_reuse_decider_config() const {
  return *task_config_.path_reuse_decider_config_;
}
inline ::apollo::planning::PathReuseDeciderConfig* TaskConfig::release_path_reuse_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.path_reuse_decider_config)
  if (has_path_reuse_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::PathReuseDeciderConfig* temp = task_config_.path_reuse_decider_config_;
    task_config_.path_reuse_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PathReuseDeciderConfig& TaskConfig::path_reuse_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.path_reuse_decider_config)
  return has_path_reuse_decider_config()
      ? *task_config_.path_reuse_decider_config_
      : *reinterpret_cast< ::apollo::planning::PathReuseDeciderConfig*>(&::apollo::planning::_PathReuseDeciderConfig_default_instance_);
}
inline ::apollo::planning::PathReuseDeciderConfig* TaskConfig::mutable_path_reuse_decider_config() {
  if (!has_path_reuse_decider_config()) {
    clear_task_config();
    set_has_path_reuse_decider_config();
    task_config_.path_reuse_decider_config_ = CreateMaybeMessage< ::apollo::planning::PathReuseDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.path_reuse_decider_config)
  return task_config_.path_reuse_decider_config_;
}

// optional .apollo.planning.RuleBasedStopDeciderConfig rule_based_stop_decider_config = 13;
inline bool TaskConfig::has_rule_based_stop_decider_config() const {
  return task_config_case() == kRuleBasedStopDeciderConfig;
}
inline void TaskConfig::set_has_rule_based_stop_decider_config() {
  _oneof_case_[0] = kRuleBasedStopDeciderConfig;
}
inline const ::apollo::planning::RuleBasedStopDeciderConfig& TaskConfig::_internal_rule_based_stop_decider_config() const {
  return *task_config_.rule_based_stop_decider_config_;
}
inline ::apollo::planning::RuleBasedStopDeciderConfig* TaskConfig::release_rule_based_stop_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.rule_based_stop_decider_config)
  if (has_rule_based_stop_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::RuleBasedStopDeciderConfig* temp = task_config_.rule_based_stop_decider_config_;
    task_config_.rule_based_stop_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::RuleBasedStopDeciderConfig& TaskConfig::rule_based_stop_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.rule_based_stop_decider_config)
  return has_rule_based_stop_decider_config()
      ? *task_config_.rule_based_stop_decider_config_
      : *reinterpret_cast< ::apollo::planning::RuleBasedStopDeciderConfig*>(&::apollo::planning::_RuleBasedStopDeciderConfig_default_instance_);
}
inline ::apollo::planning::RuleBasedStopDeciderConfig* TaskConfig::mutable_rule_based_stop_decider_config() {
  if (!has_rule_based_stop_decider_config()) {
    clear_task_config();
    set_has_rule_based_stop_decider_config();
    task_config_.rule_based_stop_decider_config_ = CreateMaybeMessage< ::apollo::planning::RuleBasedStopDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.rule_based_stop_decider_config)
  return task_config_.rule_based_stop_decider_config_;
}

// optional .apollo.planning.SpeedBoundsDeciderConfig speed_bounds_decider_config = 14;
inline bool TaskConfig::has_speed_bounds_decider_config() const {
  return task_config_case() == kSpeedBoundsDeciderConfig;
}
inline void TaskConfig::set_has_speed_bounds_decider_config() {
  _oneof_case_[0] = kSpeedBoundsDeciderConfig;
}
inline const ::apollo::planning::SpeedBoundsDeciderConfig& TaskConfig::_internal_speed_bounds_decider_config() const {
  return *task_config_.speed_bounds_decider_config_;
}
inline ::apollo::planning::SpeedBoundsDeciderConfig* TaskConfig::release_speed_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.speed_bounds_decider_config)
  if (has_speed_bounds_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::SpeedBoundsDeciderConfig* temp = task_config_.speed_bounds_decider_config_;
    task_config_.speed_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::SpeedBoundsDeciderConfig& TaskConfig::speed_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.speed_bounds_decider_config)
  return has_speed_bounds_decider_config()
      ? *task_config_.speed_bounds_decider_config_
      : *reinterpret_cast< ::apollo::planning::SpeedBoundsDeciderConfig*>(&::apollo::planning::_SpeedBoundsDeciderConfig_default_instance_);
}
inline ::apollo::planning::SpeedBoundsDeciderConfig* TaskConfig::mutable_speed_bounds_decider_config() {
  if (!has_speed_bounds_decider_config()) {
    clear_task_config();
    set_has_speed_bounds_decider_config();
    task_config_.speed_bounds_decider_config_ = CreateMaybeMessage< ::apollo::planning::SpeedBoundsDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.speed_bounds_decider_config)
  return task_config_.speed_bounds_decider_config_;
}

// optional .apollo.planning.STBoundsDeciderConfig st_bounds_decider_config = 15;
inline bool TaskConfig::has_st_bounds_decider_config() const {
  return task_config_case() == kStBoundsDeciderConfig;
}
inline void TaskConfig::set_has_st_bounds_decider_config() {
  _oneof_case_[0] = kStBoundsDeciderConfig;
}
inline const ::apollo::planning::STBoundsDeciderConfig& TaskConfig::_internal_st_bounds_decider_config() const {
  return *task_config_.st_bounds_decider_config_;
}
inline ::apollo::planning::STBoundsDeciderConfig* TaskConfig::release_st_bounds_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.st_bounds_decider_config)
  if (has_st_bounds_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::STBoundsDeciderConfig* temp = task_config_.st_bounds_decider_config_;
    task_config_.st_bounds_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::STBoundsDeciderConfig& TaskConfig::st_bounds_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.st_bounds_decider_config)
  return has_st_bounds_decider_config()
      ? *task_config_.st_bounds_decider_config_
      : *reinterpret_cast< ::apollo::planning::STBoundsDeciderConfig*>(&::apollo::planning::_STBoundsDeciderConfig_default_instance_);
}
inline ::apollo::planning::STBoundsDeciderConfig* TaskConfig::mutable_st_bounds_decider_config() {
  if (!has_st_bounds_decider_config()) {
    clear_task_config();
    set_has_st_bounds_decider_config();
    task_config_.st_bounds_decider_config_ = CreateMaybeMessage< ::apollo::planning::STBoundsDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.st_bounds_decider_config)
  return task_config_.st_bounds_decider_config_;
}

// optional .apollo.planning.OpenSpaceTrajectoryPartitionConfig open_space_trajectory_partition_config = 16;
inline bool TaskConfig::has_open_space_trajectory_partition_config() const {
  return task_config_case() == kOpenSpaceTrajectoryPartitionConfig;
}
inline void TaskConfig::set_has_open_space_trajectory_partition_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryPartitionConfig;
}
inline const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& TaskConfig::_internal_open_space_trajectory_partition_config() const {
  return *task_config_.open_space_trajectory_partition_config_;
}
inline ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::release_open_space_trajectory_partition_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_trajectory_partition_config)
  if (has_open_space_trajectory_partition_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* temp = task_config_.open_space_trajectory_partition_config_;
    task_config_.open_space_trajectory_partition_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::OpenSpaceTrajectoryPartitionConfig& TaskConfig::open_space_trajectory_partition_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_trajectory_partition_config)
  return has_open_space_trajectory_partition_config()
      ? *task_config_.open_space_trajectory_partition_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceTrajectoryPartitionConfig*>(&::apollo::planning::_OpenSpaceTrajectoryPartitionConfig_default_instance_);
}
inline ::apollo::planning::OpenSpaceTrajectoryPartitionConfig* TaskConfig::mutable_open_space_trajectory_partition_config() {
  if (!has_open_space_trajectory_partition_config()) {
    clear_task_config();
    set_has_open_space_trajectory_partition_config();
    task_config_.open_space_trajectory_partition_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceTrajectoryPartitionConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_trajectory_partition_config)
  return task_config_.open_space_trajectory_partition_config_;
}

// optional .apollo.planning.OpenSpaceTrajectoryProviderConfig open_space_trajectory_provider_config = 17;
inline bool TaskConfig::has_open_space_trajectory_provider_config() const {
  return task_config_case() == kOpenSpaceTrajectoryProviderConfig;
}
inline void TaskConfig::set_has_open_space_trajectory_provider_config() {
  _oneof_case_[0] = kOpenSpaceTrajectoryProviderConfig;
}
inline const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& TaskConfig::_internal_open_space_trajectory_provider_config() const {
  return *task_config_.open_space_trajectory_provider_config_;
}
inline ::apollo::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::release_open_space_trajectory_provider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.open_space_trajectory_provider_config)
  if (has_open_space_trajectory_provider_config()) {
    clear_has_task_config();
      ::apollo::planning::OpenSpaceTrajectoryProviderConfig* temp = task_config_.open_space_trajectory_provider_config_;
    task_config_.open_space_trajectory_provider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::OpenSpaceTrajectoryProviderConfig& TaskConfig::open_space_trajectory_provider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.open_space_trajectory_provider_config)
  return has_open_space_trajectory_provider_config()
      ? *task_config_.open_space_trajectory_provider_config_
      : *reinterpret_cast< ::apollo::planning::OpenSpaceTrajectoryProviderConfig*>(&::apollo::planning::_OpenSpaceTrajectoryProviderConfig_default_instance_);
}
inline ::apollo::planning::OpenSpaceTrajectoryProviderConfig* TaskConfig::mutable_open_space_trajectory_provider_config() {
  if (!has_open_space_trajectory_provider_config()) {
    clear_task_config();
    set_has_open_space_trajectory_provider_config();
    task_config_.open_space_trajectory_provider_config_ = CreateMaybeMessage< ::apollo::planning::OpenSpaceTrajectoryProviderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.open_space_trajectory_provider_config)
  return task_config_.open_space_trajectory_provider_config_;
}

// optional .apollo.planning.PiecewiseJerkNonlinearSpeedOptimizerConfig piecewise_jerk_nonlinear_speed_optimizer_config = 18;
inline bool TaskConfig::has_piecewise_jerk_nonlinear_speed_optimizer_config() const {
  return task_config_case() == kPiecewiseJerkNonlinearSpeedOptimizerConfig;
}
inline void TaskConfig::set_has_piecewise_jerk_nonlinear_speed_optimizer_config() {
  _oneof_case_[0] = kPiecewiseJerkNonlinearSpeedOptimizerConfig;
}
inline const ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig& TaskConfig::_internal_piecewise_jerk_nonlinear_speed_optimizer_config() const {
  return *task_config_.piecewise_jerk_nonlinear_speed_optimizer_config_;
}
inline ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* TaskConfig::release_piecewise_jerk_nonlinear_speed_optimizer_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.piecewise_jerk_nonlinear_speed_optimizer_config)
  if (has_piecewise_jerk_nonlinear_speed_optimizer_config()) {
    clear_has_task_config();
      ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* temp = task_config_.piecewise_jerk_nonlinear_speed_optimizer_config_;
    task_config_.piecewise_jerk_nonlinear_speed_optimizer_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig& TaskConfig::piecewise_jerk_nonlinear_speed_optimizer_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.piecewise_jerk_nonlinear_speed_optimizer_config)
  return has_piecewise_jerk_nonlinear_speed_optimizer_config()
      ? *task_config_.piecewise_jerk_nonlinear_speed_optimizer_config_
      : *reinterpret_cast< ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig*>(&::apollo::planning::_PiecewiseJerkNonlinearSpeedOptimizerConfig_default_instance_);
}
inline ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig* TaskConfig::mutable_piecewise_jerk_nonlinear_speed_optimizer_config() {
  if (!has_piecewise_jerk_nonlinear_speed_optimizer_config()) {
    clear_task_config();
    set_has_piecewise_jerk_nonlinear_speed_optimizer_config();
    task_config_.piecewise_jerk_nonlinear_speed_optimizer_config_ = CreateMaybeMessage< ::apollo::planning::PiecewiseJerkNonlinearSpeedOptimizerConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.piecewise_jerk_nonlinear_speed_optimizer_config)
  return task_config_.piecewise_jerk_nonlinear_speed_optimizer_config_;
}

// optional .apollo.planning.PiecewiseJerkPathOptimizerConfig piecewise_jerk_path_optimizer_config = 19;
inline bool TaskConfig::has_piecewise_jerk_path_optimizer_config() const {
  return task_config_case() == kPiecewiseJerkPathOptimizerConfig;
}
inline void TaskConfig::set_has_piecewise_jerk_path_optimizer_config() {
  _oneof_case_[0] = kPiecewiseJerkPathOptimizerConfig;
}
inline const ::apollo::planning::PiecewiseJerkPathOptimizerConfig& TaskConfig::_internal_piecewise_jerk_path_optimizer_config() const {
  return *task_config_.piecewise_jerk_path_optimizer_config_;
}
inline ::apollo::planning::PiecewiseJerkPathOptimizerConfig* TaskConfig::release_piecewise_jerk_path_optimizer_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.piecewise_jerk_path_optimizer_config)
  if (has_piecewise_jerk_path_optimizer_config()) {
    clear_has_task_config();
      ::apollo::planning::PiecewiseJerkPathOptimizerConfig* temp = task_config_.piecewise_jerk_path_optimizer_config_;
    task_config_.piecewise_jerk_path_optimizer_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PiecewiseJerkPathOptimizerConfig& TaskConfig::piecewise_jerk_path_optimizer_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.piecewise_jerk_path_optimizer_config)
  return has_piecewise_jerk_path_optimizer_config()
      ? *task_config_.piecewise_jerk_path_optimizer_config_
      : *reinterpret_cast< ::apollo::planning::PiecewiseJerkPathOptimizerConfig*>(&::apollo::planning::_PiecewiseJerkPathOptimizerConfig_default_instance_);
}
inline ::apollo::planning::PiecewiseJerkPathOptimizerConfig* TaskConfig::mutable_piecewise_jerk_path_optimizer_config() {
  if (!has_piecewise_jerk_path_optimizer_config()) {
    clear_task_config();
    set_has_piecewise_jerk_path_optimizer_config();
    task_config_.piecewise_jerk_path_optimizer_config_ = CreateMaybeMessage< ::apollo::planning::PiecewiseJerkPathOptimizerConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.piecewise_jerk_path_optimizer_config)
  return task_config_.piecewise_jerk_path_optimizer_config_;
}

// optional .apollo.planning.PiecewiseJerkSpeedOptimizerConfig piecewise_jerk_speed_optimizer_config = 20;
inline bool TaskConfig::has_piecewise_jerk_speed_optimizer_config() const {
  return task_config_case() == kPiecewiseJerkSpeedOptimizerConfig;
}
inline void TaskConfig::set_has_piecewise_jerk_speed_optimizer_config() {
  _oneof_case_[0] = kPiecewiseJerkSpeedOptimizerConfig;
}
inline const ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig& TaskConfig::_internal_piecewise_jerk_speed_optimizer_config() const {
  return *task_config_.piecewise_jerk_speed_optimizer_config_;
}
inline ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* TaskConfig::release_piecewise_jerk_speed_optimizer_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.piecewise_jerk_speed_optimizer_config)
  if (has_piecewise_jerk_speed_optimizer_config()) {
    clear_has_task_config();
      ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* temp = task_config_.piecewise_jerk_speed_optimizer_config_;
    task_config_.piecewise_jerk_speed_optimizer_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig& TaskConfig::piecewise_jerk_speed_optimizer_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.piecewise_jerk_speed_optimizer_config)
  return has_piecewise_jerk_speed_optimizer_config()
      ? *task_config_.piecewise_jerk_speed_optimizer_config_
      : *reinterpret_cast< ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig*>(&::apollo::planning::_PiecewiseJerkSpeedOptimizerConfig_default_instance_);
}
inline ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig* TaskConfig::mutable_piecewise_jerk_speed_optimizer_config() {
  if (!has_piecewise_jerk_speed_optimizer_config()) {
    clear_task_config();
    set_has_piecewise_jerk_speed_optimizer_config();
    task_config_.piecewise_jerk_speed_optimizer_config_ = CreateMaybeMessage< ::apollo::planning::PiecewiseJerkSpeedOptimizerConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.piecewise_jerk_speed_optimizer_config)
  return task_config_.piecewise_jerk_speed_optimizer_config_;
}

// optional .apollo.planning.SpeedHeuristicOptimizerConfig speed_heuristic_optimizer_config = 21;
inline bool TaskConfig::has_speed_heuristic_optimizer_config() const {
  return task_config_case() == kSpeedHeuristicOptimizerConfig;
}
inline void TaskConfig::set_has_speed_heuristic_optimizer_config() {
  _oneof_case_[0] = kSpeedHeuristicOptimizerConfig;
}
inline const ::apollo::planning::SpeedHeuristicOptimizerConfig& TaskConfig::_internal_speed_heuristic_optimizer_config() const {
  return *task_config_.speed_heuristic_optimizer_config_;
}
inline ::apollo::planning::SpeedHeuristicOptimizerConfig* TaskConfig::release_speed_heuristic_optimizer_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.speed_heuristic_optimizer_config)
  if (has_speed_heuristic_optimizer_config()) {
    clear_has_task_config();
      ::apollo::planning::SpeedHeuristicOptimizerConfig* temp = task_config_.speed_heuristic_optimizer_config_;
    task_config_.speed_heuristic_optimizer_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::SpeedHeuristicOptimizerConfig& TaskConfig::speed_heuristic_optimizer_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.speed_heuristic_optimizer_config)
  return has_speed_heuristic_optimizer_config()
      ? *task_config_.speed_heuristic_optimizer_config_
      : *reinterpret_cast< ::apollo::planning::SpeedHeuristicOptimizerConfig*>(&::apollo::planning::_SpeedHeuristicOptimizerConfig_default_instance_);
}
inline ::apollo::planning::SpeedHeuristicOptimizerConfig* TaskConfig::mutable_speed_heuristic_optimizer_config() {
  if (!has_speed_heuristic_optimizer_config()) {
    clear_task_config();
    set_has_speed_heuristic_optimizer_config();
    task_config_.speed_heuristic_optimizer_config_ = CreateMaybeMessage< ::apollo::planning::SpeedHeuristicOptimizerConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.speed_heuristic_optimizer_config)
  return task_config_.speed_heuristic_optimizer_config_;
}

// optional .apollo.planning.LearningModelInferenceTaskConfig learning_model_inference_task_config = 22;
inline bool TaskConfig::has_learning_model_inference_task_config() const {
  return task_config_case() == kLearningModelInferenceTaskConfig;
}
inline void TaskConfig::set_has_learning_model_inference_task_config() {
  _oneof_case_[0] = kLearningModelInferenceTaskConfig;
}
inline const ::apollo::planning::LearningModelInferenceTaskConfig& TaskConfig::_internal_learning_model_inference_task_config() const {
  return *task_config_.learning_model_inference_task_config_;
}
inline ::apollo::planning::LearningModelInferenceTaskConfig* TaskConfig::release_learning_model_inference_task_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.learning_model_inference_task_config)
  if (has_learning_model_inference_task_config()) {
    clear_has_task_config();
      ::apollo::planning::LearningModelInferenceTaskConfig* temp = task_config_.learning_model_inference_task_config_;
    task_config_.learning_model_inference_task_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::LearningModelInferenceTaskConfig& TaskConfig::learning_model_inference_task_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.learning_model_inference_task_config)
  return has_learning_model_inference_task_config()
      ? *task_config_.learning_model_inference_task_config_
      : *reinterpret_cast< ::apollo::planning::LearningModelInferenceTaskConfig*>(&::apollo::planning::_LearningModelInferenceTaskConfig_default_instance_);
}
inline ::apollo::planning::LearningModelInferenceTaskConfig* TaskConfig::mutable_learning_model_inference_task_config() {
  if (!has_learning_model_inference_task_config()) {
    clear_task_config();
    set_has_learning_model_inference_task_config();
    task_config_.learning_model_inference_task_config_ = CreateMaybeMessage< ::apollo::planning::LearningModelInferenceTaskConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.learning_model_inference_task_config)
  return task_config_.learning_model_inference_task_config_;
}

// optional .apollo.planning.LearningModelInferenceTrajectoryTaskConfig learning_model_inference_trajectory_task_config = 23;
inline bool TaskConfig::has_learning_model_inference_trajectory_task_config() const {
  return task_config_case() == kLearningModelInferenceTrajectoryTaskConfig;
}
inline void TaskConfig::set_has_learning_model_inference_trajectory_task_config() {
  _oneof_case_[0] = kLearningModelInferenceTrajectoryTaskConfig;
}
inline const ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig& TaskConfig::_internal_learning_model_inference_trajectory_task_config() const {
  return *task_config_.learning_model_inference_trajectory_task_config_;
}
inline ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* TaskConfig::release_learning_model_inference_trajectory_task_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.learning_model_inference_trajectory_task_config)
  if (has_learning_model_inference_trajectory_task_config()) {
    clear_has_task_config();
      ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* temp = task_config_.learning_model_inference_trajectory_task_config_;
    task_config_.learning_model_inference_trajectory_task_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig& TaskConfig::learning_model_inference_trajectory_task_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.learning_model_inference_trajectory_task_config)
  return has_learning_model_inference_trajectory_task_config()
      ? *task_config_.learning_model_inference_trajectory_task_config_
      : *reinterpret_cast< ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig*>(&::apollo::planning::_LearningModelInferenceTrajectoryTaskConfig_default_instance_);
}
inline ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig* TaskConfig::mutable_learning_model_inference_trajectory_task_config() {
  if (!has_learning_model_inference_trajectory_task_config()) {
    clear_task_config();
    set_has_learning_model_inference_trajectory_task_config();
    task_config_.learning_model_inference_trajectory_task_config_ = CreateMaybeMessage< ::apollo::planning::LearningModelInferenceTrajectoryTaskConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.learning_model_inference_trajectory_task_config)
  return task_config_.learning_model_inference_trajectory_task_config_;
}

// optional .apollo.planning.NewTestDeciderConfig new_test_decider_config = 24;
inline bool TaskConfig::has_new_test_decider_config() const {
  return task_config_case() == kNewTestDeciderConfig;
}
inline void TaskConfig::set_has_new_test_decider_config() {
  _oneof_case_[0] = kNewTestDeciderConfig;
}
inline const ::apollo::planning::NewTestDeciderConfig& TaskConfig::_internal_new_test_decider_config() const {
  return *task_config_.new_test_decider_config_;
}
inline ::apollo::planning::NewTestDeciderConfig* TaskConfig::release_new_test_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.new_test_decider_config)
  if (has_new_test_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::NewTestDeciderConfig* temp = task_config_.new_test_decider_config_;
    task_config_.new_test_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::NewTestDeciderConfig& TaskConfig::new_test_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.new_test_decider_config)
  return has_new_test_decider_config()
      ? *task_config_.new_test_decider_config_
      : *reinterpret_cast< ::apollo::planning::NewTestDeciderConfig*>(&::apollo::planning::_NewTestDeciderConfig_default_instance_);
}
inline ::apollo::planning::NewTestDeciderConfig* TaskConfig::mutable_new_test_decider_config() {
  if (!has_new_test_decider_config()) {
    clear_task_config();
    set_has_new_test_decider_config();
    task_config_.new_test_decider_config_ = CreateMaybeMessage< ::apollo::planning::NewTestDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.new_test_decider_config)
  return task_config_.new_test_decider_config_;
}

// optional .apollo.planning.StGenerateDeciderConfig st_generate_decider_config = 25;
inline bool TaskConfig::has_st_generate_decider_config() const {
  return task_config_case() == kStGenerateDeciderConfig;
}
inline void TaskConfig::set_has_st_generate_decider_config() {
  _oneof_case_[0] = kStGenerateDeciderConfig;
}
inline const ::apollo::planning::StGenerateDeciderConfig& TaskConfig::_internal_st_generate_decider_config() const {
  return *task_config_.st_generate_decider_config_;
}
inline ::apollo::planning::StGenerateDeciderConfig* TaskConfig::release_st_generate_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.TaskConfig.st_generate_decider_config)
  if (has_st_generate_decider_config()) {
    clear_has_task_config();
      ::apollo::planning::StGenerateDeciderConfig* temp = task_config_.st_generate_decider_config_;
    task_config_.st_generate_decider_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::StGenerateDeciderConfig& TaskConfig::st_generate_decider_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TaskConfig.st_generate_decider_config)
  return has_st_generate_decider_config()
      ? *task_config_.st_generate_decider_config_
      : *reinterpret_cast< ::apollo::planning::StGenerateDeciderConfig*>(&::apollo::planning::_StGenerateDeciderConfig_default_instance_);
}
inline ::apollo::planning::StGenerateDeciderConfig* TaskConfig::mutable_st_generate_decider_config() {
  if (!has_st_generate_decider_config()) {
    clear_task_config();
    set_has_st_generate_decider_config();
    task_config_.st_generate_decider_config_ = CreateMaybeMessage< ::apollo::planning::StGenerateDeciderConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TaskConfig.st_generate_decider_config)
  return task_config_.st_generate_decider_config_;
}

inline bool TaskConfig::has_task_config() const {
  return task_config_case() != TASK_CONFIG_NOT_SET;
}
inline void TaskConfig::clear_has_task_config() {
  _oneof_case_[0] = TASK_CONFIG_NOT_SET;
}
inline TaskConfig::TaskConfigCase TaskConfig::task_config_case() const {
  return TaskConfig::TaskConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ScenarioBareIntersectionUnprotectedConfig

// optional double start_bare_intersection_scenario_distance = 1 [default = 25];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_start_bare_intersection_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_start_bare_intersection_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_start_bare_intersection_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_start_bare_intersection_scenario_distance() {
  start_bare_intersection_scenario_distance_ = 25;
  clear_has_start_bare_intersection_scenario_distance();
}
inline double ScenarioBareIntersectionUnprotectedConfig::start_bare_intersection_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
  return start_bare_intersection_scenario_distance_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_start_bare_intersection_scenario_distance(double value) {
  set_has_start_bare_intersection_scenario_distance();
  start_bare_intersection_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.start_bare_intersection_scenario_distance)
}

// optional bool enable_explicit_stop = 2 [default = false];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_enable_explicit_stop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_enable_explicit_stop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_enable_explicit_stop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_enable_explicit_stop() {
  enable_explicit_stop_ = false;
  clear_has_enable_explicit_stop();
}
inline bool ScenarioBareIntersectionUnprotectedConfig::enable_explicit_stop() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
  return enable_explicit_stop_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_enable_explicit_stop(bool value) {
  set_has_enable_explicit_stop();
  enable_explicit_stop_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.enable_explicit_stop)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioBareIntersectionUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.min_pass_s_distance)
}

// optional double approach_cruise_speed = 4 [default = 6.7056];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_approach_cruise_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_approach_cruise_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_approach_cruise_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_approach_cruise_speed() {
  approach_cruise_speed_ = 6.7056;
  clear_has_approach_cruise_speed();
}
inline double ScenarioBareIntersectionUnprotectedConfig::approach_cruise_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.approach_cruise_speed)
  return approach_cruise_speed_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_approach_cruise_speed(double value) {
  set_has_approach_cruise_speed();
  approach_cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.approach_cruise_speed)
}

// optional double stop_distance = 5 [default = 0.5];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double ScenarioBareIntersectionUnprotectedConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
  return stop_distance_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_stop_timeout_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_stop_timeout_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_stop_timeout_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  clear_has_stop_timeout_sec();
}
inline float ScenarioBareIntersectionUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
  return stop_timeout_sec_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_stop_timeout_sec(float value) {
  set_has_stop_timeout_sec();
  stop_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
inline bool ScenarioBareIntersectionUnprotectedConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioBareIntersectionUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioBareIntersectionUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioBareIntersectionUnprotectedConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioBareIntersectionUnprotectedConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioEmergencyPullOverConfig

// optional double max_stop_deceleration = 1 [default = 3];
inline bool ScenarioEmergencyPullOverConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioEmergencyPullOverConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 3;
  clear_has_max_stop_deceleration();
}
inline double ScenarioEmergencyPullOverConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioEmergencyPullOverConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void ScenarioEmergencyPullOverConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioEmergencyPullOverConfig.max_stop_deceleration)
}

// optional double slow_down_deceleration_time = 2 [default = 3];
inline bool ScenarioEmergencyPullOverConfig::has_slow_down_deceleration_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_slow_down_deceleration_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_slow_down_deceleration_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioEmergencyPullOverConfig::clear_slow_down_deceleration_time() {
  slow_down_deceleration_time_ = 3;
  clear_has_slow_down_deceleration_time();
}
inline double ScenarioEmergencyPullOverConfig::slow_down_deceleration_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioEmergencyPullOverConfig.slow_down_deceleration_time)
  return slow_down_deceleration_time_;
}
inline void ScenarioEmergencyPullOverConfig::set_slow_down_deceleration_time(double value) {
  set_has_slow_down_deceleration_time();
  slow_down_deceleration_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioEmergencyPullOverConfig.slow_down_deceleration_time)
}

// optional double target_slow_down_speed = 3 [default = 2.5];
inline bool ScenarioEmergencyPullOverConfig::has_target_slow_down_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_target_slow_down_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_target_slow_down_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioEmergencyPullOverConfig::clear_target_slow_down_speed() {
  target_slow_down_speed_ = 2.5;
  clear_has_target_slow_down_speed();
}
inline double ScenarioEmergencyPullOverConfig::target_slow_down_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioEmergencyPullOverConfig.target_slow_down_speed)
  return target_slow_down_speed_;
}
inline void ScenarioEmergencyPullOverConfig::set_target_slow_down_speed(double value) {
  set_has_target_slow_down_speed();
  target_slow_down_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioEmergencyPullOverConfig.target_slow_down_speed)
}

// optional double stop_distance = 4 [default = 1.5];
inline bool ScenarioEmergencyPullOverConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioEmergencyPullOverConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioEmergencyPullOverConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioEmergencyPullOverConfig::clear_stop_distance() {
  stop_distance_ = 1.5;
  clear_has_stop_distance();
}
inline double ScenarioEmergencyPullOverConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioEmergencyPullOverConfig.stop_distance)
  return stop_distance_;
}
inline void ScenarioEmergencyPullOverConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioEmergencyPullOverConfig.stop_distance)
}

// -------------------------------------------------------------------

// ScenarioEmergencyStopConfig

// optional double max_stop_deceleration = 1 [default = 6];
inline bool ScenarioEmergencyStopConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioEmergencyStopConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioEmergencyStopConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioEmergencyStopConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 6;
  clear_has_max_stop_deceleration();
}
inline double ScenarioEmergencyStopConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioEmergencyStopConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void ScenarioEmergencyStopConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioEmergencyStopConfig.max_stop_deceleration)
}

// optional double stop_distance = 2 [default = 1];
inline bool ScenarioEmergencyStopConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioEmergencyStopConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioEmergencyStopConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioEmergencyStopConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double ScenarioEmergencyStopConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioEmergencyStopConfig.stop_distance)
  return stop_distance_;
}
inline void ScenarioEmergencyStopConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioEmergencyStopConfig.stop_distance)
}

// -------------------------------------------------------------------

// ScenarioLaneFollowConfig

// -------------------------------------------------------------------

// ScenarioLearningModelSampleConfig

// -------------------------------------------------------------------

// ScenarioNarrowStreetUTurnConfig

// -------------------------------------------------------------------

// ScenarioParkAndGoConfig

// optional double front_obstacle_buffer = 1 [default = 4];
inline bool ScenarioParkAndGoConfig::has_front_obstacle_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_front_obstacle_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioParkAndGoConfig::clear_has_front_obstacle_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioParkAndGoConfig::clear_front_obstacle_buffer() {
  front_obstacle_buffer_ = 4;
  clear_has_front_obstacle_buffer();
}
inline double ScenarioParkAndGoConfig::front_obstacle_buffer() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioParkAndGoConfig.front_obstacle_buffer)
  return front_obstacle_buffer_;
}
inline void ScenarioParkAndGoConfig::set_front_obstacle_buffer(double value) {
  set_has_front_obstacle_buffer();
  front_obstacle_buffer_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioParkAndGoConfig.front_obstacle_buffer)
}

// optional double heading_buffer = 2 [default = 0.5];
inline bool ScenarioParkAndGoConfig::has_heading_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_heading_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioParkAndGoConfig::clear_has_heading_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioParkAndGoConfig::clear_heading_buffer() {
  heading_buffer_ = 0.5;
  clear_has_heading_buffer();
}
inline double ScenarioParkAndGoConfig::heading_buffer() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioParkAndGoConfig.heading_buffer)
  return heading_buffer_;
}
inline void ScenarioParkAndGoConfig::set_heading_buffer(double value) {
  set_has_heading_buffer();
  heading_buffer_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioParkAndGoConfig.heading_buffer)
}

// optional double min_dist_to_dest = 3 [default = 25];
inline bool ScenarioParkAndGoConfig::has_min_dist_to_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_min_dist_to_dest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioParkAndGoConfig::clear_has_min_dist_to_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioParkAndGoConfig::clear_min_dist_to_dest() {
  min_dist_to_dest_ = 25;
  clear_has_min_dist_to_dest();
}
inline double ScenarioParkAndGoConfig::min_dist_to_dest() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioParkAndGoConfig.min_dist_to_dest)
  return min_dist_to_dest_;
}
inline void ScenarioParkAndGoConfig::set_min_dist_to_dest(double value) {
  set_has_min_dist_to_dest();
  min_dist_to_dest_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioParkAndGoConfig.min_dist_to_dest)
}

// optional double max_steering_percentage_when_cruise = 4 [default = 90];
inline bool ScenarioParkAndGoConfig::has_max_steering_percentage_when_cruise() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioParkAndGoConfig::set_has_max_steering_percentage_when_cruise() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioParkAndGoConfig::clear_has_max_steering_percentage_when_cruise() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioParkAndGoConfig::clear_max_steering_percentage_when_cruise() {
  max_steering_percentage_when_cruise_ = 90;
  clear_has_max_steering_percentage_when_cruise();
}
inline double ScenarioParkAndGoConfig::max_steering_percentage_when_cruise() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioParkAndGoConfig.max_steering_percentage_when_cruise)
  return max_steering_percentage_when_cruise_;
}
inline void ScenarioParkAndGoConfig::set_max_steering_percentage_when_cruise(double value) {
  set_has_max_steering_percentage_when_cruise();
  max_steering_percentage_when_cruise_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioParkAndGoConfig.max_steering_percentage_when_cruise)
}

// -------------------------------------------------------------------

// ScenarioPullOverConfig

// optional double start_pull_over_scenario_distance = 1 [default = 50];
inline bool ScenarioPullOverConfig::has_start_pull_over_scenario_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioPullOverConfig::set_has_start_pull_over_scenario_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioPullOverConfig::clear_has_start_pull_over_scenario_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioPullOverConfig::clear_start_pull_over_scenario_distance() {
  start_pull_over_scenario_distance_ = 50;
  clear_has_start_pull_over_scenario_distance();
}
inline double ScenarioPullOverConfig::start_pull_over_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
  return start_pull_over_scenario_distance_;
}
inline void ScenarioPullOverConfig::set_start_pull_over_scenario_distance(double value) {
  set_has_start_pull_over_scenario_distance();
  start_pull_over_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.start_pull_over_scenario_distance)
}

// optional double pull_over_min_distance_buffer = 2 [default = 10];
inline bool ScenarioPullOverConfig::has_pull_over_min_distance_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioPullOverConfig::set_has_pull_over_min_distance_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioPullOverConfig::clear_has_pull_over_min_distance_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioPullOverConfig::clear_pull_over_min_distance_buffer() {
  pull_over_min_distance_buffer_ = 10;
  clear_has_pull_over_min_distance_buffer();
}
inline double ScenarioPullOverConfig::pull_over_min_distance_buffer() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
  return pull_over_min_distance_buffer_;
}
inline void ScenarioPullOverConfig::set_pull_over_min_distance_buffer(double value) {
  set_has_pull_over_min_distance_buffer();
  pull_over_min_distance_buffer_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.pull_over_min_distance_buffer)
}

// optional double max_distance_stop_search = 3 [default = 25];
inline bool ScenarioPullOverConfig::has_max_distance_stop_search() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_distance_stop_search() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioPullOverConfig::clear_has_max_distance_stop_search() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioPullOverConfig::clear_max_distance_stop_search() {
  max_distance_stop_search_ = 25;
  clear_has_max_distance_stop_search();
}
inline double ScenarioPullOverConfig::max_distance_stop_search() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_distance_stop_search)
  return max_distance_stop_search_;
}
inline void ScenarioPullOverConfig::set_max_distance_stop_search(double value) {
  set_has_max_distance_stop_search();
  max_distance_stop_search_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_distance_stop_search)
}

// optional double max_s_error_to_end_point = 4 [default = 0.2];
inline bool ScenarioPullOverConfig::has_max_s_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_s_error_to_end_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioPullOverConfig::clear_has_max_s_error_to_end_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioPullOverConfig::clear_max_s_error_to_end_point() {
  max_s_error_to_end_point_ = 0.2;
  clear_has_max_s_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_s_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
  return max_s_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_s_error_to_end_point(double value) {
  set_has_max_s_error_to_end_point();
  max_s_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_s_error_to_end_point)
}

// optional double max_l_error_to_end_point = 5 [default = 0.5];
inline bool ScenarioPullOverConfig::has_max_l_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_l_error_to_end_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioPullOverConfig::clear_has_max_l_error_to_end_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioPullOverConfig::clear_max_l_error_to_end_point() {
  max_l_error_to_end_point_ = 0.5;
  clear_has_max_l_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_l_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
  return max_l_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_l_error_to_end_point(double value) {
  set_has_max_l_error_to_end_point();
  max_l_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_l_error_to_end_point)
}

// optional double max_theta_error_to_end_point = 6 [default = 0.2];
inline bool ScenarioPullOverConfig::has_max_theta_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_theta_error_to_end_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioPullOverConfig::clear_has_max_theta_error_to_end_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioPullOverConfig::clear_max_theta_error_to_end_point() {
  max_theta_error_to_end_point_ = 0.2;
  clear_has_max_theta_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_theta_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
  return max_theta_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_theta_error_to_end_point(double value) {
  set_has_max_theta_error_to_end_point();
  max_theta_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_theta_error_to_end_point)
}

// optional double max_distance_error_to_end_point = 7 [default = 0.2];
inline bool ScenarioPullOverConfig::has_max_distance_error_to_end_point() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_distance_error_to_end_point() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioPullOverConfig::clear_has_max_distance_error_to_end_point() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioPullOverConfig::clear_max_distance_error_to_end_point() {
  max_distance_error_to_end_point_ = 0.2;
  clear_has_max_distance_error_to_end_point();
}
inline double ScenarioPullOverConfig::max_distance_error_to_end_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
  return max_distance_error_to_end_point_;
}
inline void ScenarioPullOverConfig::set_max_distance_error_to_end_point(double value) {
  set_has_max_distance_error_to_end_point();
  max_distance_error_to_end_point_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_distance_error_to_end_point)
}

// optional double pass_destination_threshold = 8 [default = 10];
inline bool ScenarioPullOverConfig::has_pass_destination_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScenarioPullOverConfig::set_has_pass_destination_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScenarioPullOverConfig::clear_has_pass_destination_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScenarioPullOverConfig::clear_pass_destination_threshold() {
  pass_destination_threshold_ = 10;
  clear_has_pass_destination_threshold();
}
inline double ScenarioPullOverConfig::pass_destination_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.pass_destination_threshold)
  return pass_destination_threshold_;
}
inline void ScenarioPullOverConfig::set_pass_destination_threshold(double value) {
  set_has_pass_destination_threshold();
  pass_destination_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.pass_destination_threshold)
}

// optional double max_valid_stop_distance = 9 [default = 1];
inline bool ScenarioPullOverConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScenarioPullOverConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScenarioPullOverConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScenarioPullOverConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioPullOverConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioPullOverConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.max_valid_stop_distance)
}

// optional double s_distance_to_stop_for_open_space_parking = 10 [default = 7];
inline bool ScenarioPullOverConfig::has_s_distance_to_stop_for_open_space_parking() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScenarioPullOverConfig::set_has_s_distance_to_stop_for_open_space_parking() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScenarioPullOverConfig::clear_has_s_distance_to_stop_for_open_space_parking() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScenarioPullOverConfig::clear_s_distance_to_stop_for_open_space_parking() {
  s_distance_to_stop_for_open_space_parking_ = 7;
  clear_has_s_distance_to_stop_for_open_space_parking();
}
inline double ScenarioPullOverConfig::s_distance_to_stop_for_open_space_parking() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
  return s_distance_to_stop_for_open_space_parking_;
}
inline void ScenarioPullOverConfig::set_s_distance_to_stop_for_open_space_parking(double value) {
  set_has_s_distance_to_stop_for_open_space_parking();
  s_distance_to_stop_for_open_space_parking_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioPullOverConfig.s_distance_to_stop_for_open_space_parking)
}

// -------------------------------------------------------------------

// ScenarioStopSignUnprotectedConfig

// optional double start_stop_sign_scenario_distance = 1 [default = 5];
inline bool ScenarioStopSignUnprotectedConfig::has_start_stop_sign_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_start_stop_sign_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_start_stop_sign_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_start_stop_sign_scenario_distance() {
  start_stop_sign_scenario_distance_ = 5;
  clear_has_start_stop_sign_scenario_distance();
}
inline double ScenarioStopSignUnprotectedConfig::start_stop_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
  return start_stop_sign_scenario_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_start_stop_sign_scenario_distance(double value) {
  set_has_start_stop_sign_scenario_distance();
  start_stop_sign_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.start_stop_sign_scenario_distance)
}

// optional double watch_vehicle_max_valid_stop_distance = 2 [default = 5];
inline bool ScenarioStopSignUnprotectedConfig::has_watch_vehicle_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_watch_vehicle_max_valid_stop_distance() {
  watch_vehicle_max_valid_stop_distance_ = 5;
  clear_has_watch_vehicle_max_valid_stop_distance();
}
inline double ScenarioStopSignUnprotectedConfig::watch_vehicle_max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
  return watch_vehicle_max_valid_stop_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_watch_vehicle_max_valid_stop_distance(double value) {
  set_has_watch_vehicle_max_valid_stop_distance();
  watch_vehicle_max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.watch_vehicle_max_valid_stop_distance)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioStopSignUnprotectedConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioStopSignUnprotectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.max_valid_stop_distance)
}

// optional float stop_duration_sec = 4 [default = 1];
inline bool ScenarioStopSignUnprotectedConfig::has_stop_duration_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_stop_duration_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_stop_duration_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_stop_duration_sec() {
  stop_duration_sec_ = 1;
  clear_has_stop_duration_sec();
}
inline float ScenarioStopSignUnprotectedConfig::stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
  return stop_duration_sec_;
}
inline void ScenarioStopSignUnprotectedConfig::set_stop_duration_sec(float value) {
  set_has_stop_duration_sec();
  stop_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_duration_sec)
}

// optional double min_pass_s_distance = 5 [default = 3];
inline bool ScenarioStopSignUnprotectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioStopSignUnprotectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioStopSignUnprotectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.min_pass_s_distance)
}

// optional float stop_timeout_sec = 6 [default = 8];
inline bool ScenarioStopSignUnprotectedConfig::has_stop_timeout_sec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_stop_timeout_sec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_stop_timeout_sec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_stop_timeout_sec() {
  stop_timeout_sec_ = 8;
  clear_has_stop_timeout_sec();
}
inline float ScenarioStopSignUnprotectedConfig::stop_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
  return stop_timeout_sec_;
}
inline void ScenarioStopSignUnprotectedConfig::set_stop_timeout_sec(float value) {
  set_has_stop_timeout_sec();
  stop_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.stop_timeout_sec)
}

// optional float creep_timeout_sec = 7 [default = 10];
inline bool ScenarioStopSignUnprotectedConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioStopSignUnprotectedConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioStopSignUnprotectedConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioStopSignUnprotectedConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioStopSignUnprotectedConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioStopSignUnprotectedConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightProtectedConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightProtectedConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTrafficLightProtectedConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
inline double ScenarioTrafficLightProtectedConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
inline void ScenarioTrafficLightProtectedConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.start_traffic_light_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 2];
inline bool ScenarioTrafficLightProtectedConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTrafficLightProtectedConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 2;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioTrafficLightProtectedConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioTrafficLightProtectedConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioTrafficLightProtectedConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioTrafficLightProtectedConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioTrafficLightProtectedConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioTrafficLightProtectedConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioTrafficLightProtectedConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightProtectedConfig.min_pass_s_distance)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightUnprotectedLeftTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.start_traffic_light_scenario_distance)
}

// optional double approach_cruise_speed = 2 [default = 2.78];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_approach_cruise_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_approach_cruise_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_approach_cruise_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_approach_cruise_speed() {
  approach_cruise_speed_ = 2.78;
  clear_has_approach_cruise_speed();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::approach_cruise_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.approach_cruise_speed)
  return approach_cruise_speed_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_approach_cruise_speed(double value) {
  set_has_approach_cruise_speed();
  approach_cruise_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.approach_cruise_speed)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 4 [default = 3];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 5 [default = 10];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioTrafficLightUnprotectedLeftTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.creep_timeout_sec)
}

// optional double max_adc_speed_before_creep = 6 [default = 5.56];
inline bool ScenarioTrafficLightUnprotectedLeftTurnConfig::has_max_adc_speed_before_creep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_has_max_adc_speed_before_creep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_has_max_adc_speed_before_creep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::clear_max_adc_speed_before_creep() {
  max_adc_speed_before_creep_ = 5.56;
  clear_has_max_adc_speed_before_creep();
}
inline double ScenarioTrafficLightUnprotectedLeftTurnConfig::max_adc_speed_before_creep() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_speed_before_creep)
  return max_adc_speed_before_creep_;
}
inline void ScenarioTrafficLightUnprotectedLeftTurnConfig::set_max_adc_speed_before_creep(double value) {
  set_has_max_adc_speed_before_creep();
  max_adc_speed_before_creep_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig.max_adc_speed_before_creep)
}

// -------------------------------------------------------------------

// ScenarioTrafficLightUnprotectedRightTurnConfig

// optional double start_traffic_light_scenario_distance = 1 [default = 5];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_start_traffic_light_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_start_traffic_light_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_start_traffic_light_scenario_distance() {
  start_traffic_light_scenario_distance_ = 5;
  clear_has_start_traffic_light_scenario_distance();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::start_traffic_light_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
  return start_traffic_light_scenario_distance_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_start_traffic_light_scenario_distance(double value) {
  set_has_start_traffic_light_scenario_distance();
  start_traffic_light_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.start_traffic_light_scenario_distance)
}

// optional bool enable_right_turn_on_red = 2 [default = false];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_enable_right_turn_on_red() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_enable_right_turn_on_red() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_enable_right_turn_on_red() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_enable_right_turn_on_red() {
  enable_right_turn_on_red_ = false;
  clear_has_enable_right_turn_on_red();
}
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::enable_right_turn_on_red() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
  return enable_right_turn_on_red_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_enable_right_turn_on_red(bool value) {
  set_has_enable_right_turn_on_red();
  enable_right_turn_on_red_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.enable_right_turn_on_red)
}

// optional double max_valid_stop_distance = 3 [default = 3.5];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 4 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.min_pass_s_distance)
}

// optional float red_light_right_turn_stop_duration_sec = 5 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_red_light_right_turn_stop_duration_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_red_light_right_turn_stop_duration_sec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_red_light_right_turn_stop_duration_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_red_light_right_turn_stop_duration_sec() {
  red_light_right_turn_stop_duration_sec_ = 3;
  clear_has_red_light_right_turn_stop_duration_sec();
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::red_light_right_turn_stop_duration_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
  return red_light_right_turn_stop_duration_sec_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_red_light_right_turn_stop_duration_sec(float value) {
  set_has_red_light_right_turn_stop_duration_sec();
  red_light_right_turn_stop_duration_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.red_light_right_turn_stop_duration_sec)
}

// optional float creep_timeout_sec = 6 [default = 10];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioTrafficLightUnprotectedRightTurnConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.creep_timeout_sec)
}

// optional double max_adc_speed_before_creep = 7 [default = 3];
inline bool ScenarioTrafficLightUnprotectedRightTurnConfig::has_max_adc_speed_before_creep() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_has_max_adc_speed_before_creep() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_has_max_adc_speed_before_creep() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::clear_max_adc_speed_before_creep() {
  max_adc_speed_before_creep_ = 3;
  clear_has_max_adc_speed_before_creep();
}
inline double ScenarioTrafficLightUnprotectedRightTurnConfig::max_adc_speed_before_creep() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_speed_before_creep)
  return max_adc_speed_before_creep_;
}
inline void ScenarioTrafficLightUnprotectedRightTurnConfig::set_max_adc_speed_before_creep(double value) {
  set_has_max_adc_speed_before_creep();
  max_adc_speed_before_creep_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig.max_adc_speed_before_creep)
}

// -------------------------------------------------------------------

// ScenarioValetParkingConfig

// optional double parking_spot_range_to_start = 1 [default = 20];
inline bool ScenarioValetParkingConfig::has_parking_spot_range_to_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioValetParkingConfig::set_has_parking_spot_range_to_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioValetParkingConfig::clear_has_parking_spot_range_to_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioValetParkingConfig::clear_parking_spot_range_to_start() {
  parking_spot_range_to_start_ = 20;
  clear_has_parking_spot_range_to_start();
}
inline double ScenarioValetParkingConfig::parking_spot_range_to_start() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
  return parking_spot_range_to_start_;
}
inline void ScenarioValetParkingConfig::set_parking_spot_range_to_start(double value) {
  set_has_parking_spot_range_to_start();
  parking_spot_range_to_start_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioValetParkingConfig.parking_spot_range_to_start)
}

// optional double max_valid_stop_distance = 2 [default = 1];
inline bool ScenarioValetParkingConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioValetParkingConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioValetParkingConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioValetParkingConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioValetParkingConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioValetParkingConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioValetParkingConfig.max_valid_stop_distance)
}

// -------------------------------------------------------------------

// ScenarioDeadEndTurnAroundConfig

// optional double dead_end_start_range = 1 [default = 20];
inline bool ScenarioDeadEndTurnAroundConfig::has_dead_end_start_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioDeadEndTurnAroundConfig::set_has_dead_end_start_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioDeadEndTurnAroundConfig::clear_has_dead_end_start_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioDeadEndTurnAroundConfig::clear_dead_end_start_range() {
  dead_end_start_range_ = 20;
  clear_has_dead_end_start_range();
}
inline double ScenarioDeadEndTurnAroundConfig::dead_end_start_range() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioDeadEndTurnAroundConfig.dead_end_start_range)
  return dead_end_start_range_;
}
inline void ScenarioDeadEndTurnAroundConfig::set_dead_end_start_range(double value) {
  set_has_dead_end_start_range();
  dead_end_start_range_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioDeadEndTurnAroundConfig.dead_end_start_range)
}

// optional double max_valid_stop_distance = 2 [default = 1];
inline bool ScenarioDeadEndTurnAroundConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioDeadEndTurnAroundConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioDeadEndTurnAroundConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioDeadEndTurnAroundConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 1;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioDeadEndTurnAroundConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioDeadEndTurnAroundConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioDeadEndTurnAroundConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioDeadEndTurnAroundConfig.max_valid_stop_distance)
}

// -------------------------------------------------------------------

// ScenarioYieldSignConfig

// optional double start_yield_sign_scenario_distance = 1 [default = 10];
inline bool ScenarioYieldSignConfig::has_start_yield_sign_scenario_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_start_yield_sign_scenario_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioYieldSignConfig::clear_has_start_yield_sign_scenario_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioYieldSignConfig::clear_start_yield_sign_scenario_distance() {
  start_yield_sign_scenario_distance_ = 10;
  clear_has_start_yield_sign_scenario_distance();
}
inline double ScenarioYieldSignConfig::start_yield_sign_scenario_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioYieldSignConfig.start_yield_sign_scenario_distance)
  return start_yield_sign_scenario_distance_;
}
inline void ScenarioYieldSignConfig::set_start_yield_sign_scenario_distance(double value) {
  set_has_start_yield_sign_scenario_distance();
  start_yield_sign_scenario_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioYieldSignConfig.start_yield_sign_scenario_distance)
}

// optional double max_valid_stop_distance = 2 [default = 4.5];
inline bool ScenarioYieldSignConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScenarioYieldSignConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScenarioYieldSignConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 4.5;
  clear_has_max_valid_stop_distance();
}
inline double ScenarioYieldSignConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioYieldSignConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void ScenarioYieldSignConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioYieldSignConfig.max_valid_stop_distance)
}

// optional double min_pass_s_distance = 3 [default = 3];
inline bool ScenarioYieldSignConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScenarioYieldSignConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScenarioYieldSignConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 3;
  clear_has_min_pass_s_distance();
}
inline double ScenarioYieldSignConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioYieldSignConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void ScenarioYieldSignConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioYieldSignConfig.min_pass_s_distance)
}

// optional float creep_timeout_sec = 4 [default = 10];
inline bool ScenarioYieldSignConfig::has_creep_timeout_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioYieldSignConfig::set_has_creep_timeout_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioYieldSignConfig::clear_has_creep_timeout_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioYieldSignConfig::clear_creep_timeout_sec() {
  creep_timeout_sec_ = 10;
  clear_has_creep_timeout_sec();
}
inline float ScenarioYieldSignConfig::creep_timeout_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioYieldSignConfig.creep_timeout_sec)
  return creep_timeout_sec_;
}
inline void ScenarioYieldSignConfig::set_creep_timeout_sec(float value) {
  set_has_creep_timeout_sec();
  creep_timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioYieldSignConfig.creep_timeout_sec)
}

// -------------------------------------------------------------------

// ScenarioConfig_StageConfig

// optional .apollo.planning.ScenarioConfig.StageType stage_type = 1;
inline bool ScenarioConfig_StageConfig::has_stage_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioConfig_StageConfig::set_has_stage_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioConfig_StageConfig::clear_has_stage_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioConfig_StageConfig::clear_stage_type() {
  stage_type_ = 0;
  clear_has_stage_type();
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioConfig_StageConfig::stage_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.stage_type)
  return static_cast< ::apollo::planning::ScenarioConfig_StageType >(stage_type_);
}
inline void ScenarioConfig_StageConfig::set_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  set_has_stage_type();
  stage_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.StageConfig.stage_type)
}

// optional bool enabled = 2 [default = true];
inline bool ScenarioConfig_StageConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScenarioConfig_StageConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScenarioConfig_StageConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScenarioConfig_StageConfig::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool ScenarioConfig_StageConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.enabled)
  return enabled_;
}
inline void ScenarioConfig_StageConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.StageConfig.enabled)
}

// repeated .apollo.planning.TaskConfig.TaskType task_type = 3;
inline int ScenarioConfig_StageConfig::task_type_size() const {
  return task_type_.size();
}
inline void ScenarioConfig_StageConfig::clear_task_type() {
  task_type_.Clear();
}
inline ::apollo::planning::TaskConfig_TaskType ScenarioConfig_StageConfig::task_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.task_type)
  return static_cast< ::apollo::planning::TaskConfig_TaskType >(task_type_.Get(index));
}
inline void ScenarioConfig_StageConfig::set_task_type(int index, ::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.StageConfig.task_type)
}
inline void ScenarioConfig_StageConfig::add_task_type(::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_type_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.StageConfig.task_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ScenarioConfig_StageConfig::task_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.StageConfig.task_type)
  return task_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ScenarioConfig_StageConfig::mutable_task_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.StageConfig.task_type)
  return &task_type_;
}

// repeated .apollo.planning.TaskConfig task_config = 4;
inline int ScenarioConfig_StageConfig::task_config_size() const {
  return task_config_.size();
}
inline void ScenarioConfig_StageConfig::clear_task_config() {
  task_config_.Clear();
}
inline ::apollo::planning::TaskConfig* ScenarioConfig_StageConfig::mutable_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >*
ScenarioConfig_StageConfig::mutable_task_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return &task_config_;
}
inline const ::apollo::planning::TaskConfig& ScenarioConfig_StageConfig::task_config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Get(index);
}
inline ::apollo::planning::TaskConfig* ScenarioConfig_StageConfig::add_task_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >&
ScenarioConfig_StageConfig::task_config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.StageConfig.task_config)
  return task_config_;
}

// -------------------------------------------------------------------

// ScenarioConfig

// optional .apollo.planning.ScenarioConfig.ScenarioType scenario_type = 1;
inline bool ScenarioConfig::has_scenario_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScenarioConfig::set_has_scenario_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScenarioConfig::clear_has_scenario_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScenarioConfig::clear_scenario_type() {
  scenario_type_ = 0;
  clear_has_scenario_type();
}
inline ::apollo::planning::ScenarioConfig_ScenarioType ScenarioConfig::scenario_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.scenario_type)
  return static_cast< ::apollo::planning::ScenarioConfig_ScenarioType >(scenario_type_);
}
inline void ScenarioConfig::set_scenario_type(::apollo::planning::ScenarioConfig_ScenarioType value) {
  assert(::apollo::planning::ScenarioConfig_ScenarioType_IsValid(value));
  set_has_scenario_type();
  scenario_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.scenario_type)
}

// optional .apollo.planning.ScenarioLaneFollowConfig lane_follow_config = 2;
inline bool ScenarioConfig::has_lane_follow_config() const {
  return scenario_config_case() == kLaneFollowConfig;
}
inline void ScenarioConfig::set_has_lane_follow_config() {
  _oneof_case_[0] = kLaneFollowConfig;
}
inline void ScenarioConfig::clear_lane_follow_config() {
  if (has_lane_follow_config()) {
    delete scenario_config_.lane_follow_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioLaneFollowConfig& ScenarioConfig::_internal_lane_follow_config() const {
  return *scenario_config_.lane_follow_config_;
}
inline ::apollo::planning::ScenarioLaneFollowConfig* ScenarioConfig::release_lane_follow_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.lane_follow_config)
  if (has_lane_follow_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioLaneFollowConfig* temp = scenario_config_.lane_follow_config_;
    scenario_config_.lane_follow_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioLaneFollowConfig& ScenarioConfig::lane_follow_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.lane_follow_config)
  return has_lane_follow_config()
      ? *scenario_config_.lane_follow_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioLaneFollowConfig*>(&::apollo::planning::_ScenarioLaneFollowConfig_default_instance_);
}
inline ::apollo::planning::ScenarioLaneFollowConfig* ScenarioConfig::mutable_lane_follow_config() {
  if (!has_lane_follow_config()) {
    clear_scenario_config();
    set_has_lane_follow_config();
    scenario_config_.lane_follow_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioLaneFollowConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.lane_follow_config)
  return scenario_config_.lane_follow_config_;
}

// optional .apollo.planning.ScenarioBareIntersectionUnprotectedConfig bare_intersection_unprotected_config = 3;
inline bool ScenarioConfig::has_bare_intersection_unprotected_config() const {
  return scenario_config_case() == kBareIntersectionUnprotectedConfig;
}
inline void ScenarioConfig::set_has_bare_intersection_unprotected_config() {
  _oneof_case_[0] = kBareIntersectionUnprotectedConfig;
}
inline void ScenarioConfig::clear_bare_intersection_unprotected_config() {
  if (has_bare_intersection_unprotected_config()) {
    delete scenario_config_.bare_intersection_unprotected_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& ScenarioConfig::_internal_bare_intersection_unprotected_config() const {
  return *scenario_config_.bare_intersection_unprotected_config_;
}
inline ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::release_bare_intersection_unprotected_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.bare_intersection_unprotected_config)
  if (has_bare_intersection_unprotected_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* temp = scenario_config_.bare_intersection_unprotected_config_;
    scenario_config_.bare_intersection_unprotected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig& ScenarioConfig::bare_intersection_unprotected_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return has_bare_intersection_unprotected_config()
      ? *scenario_config_.bare_intersection_unprotected_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig*>(&::apollo::planning::_ScenarioBareIntersectionUnprotectedConfig_default_instance_);
}
inline ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig* ScenarioConfig::mutable_bare_intersection_unprotected_config() {
  if (!has_bare_intersection_unprotected_config()) {
    clear_scenario_config();
    set_has_bare_intersection_unprotected_config();
    scenario_config_.bare_intersection_unprotected_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioBareIntersectionUnprotectedConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.bare_intersection_unprotected_config)
  return scenario_config_.bare_intersection_unprotected_config_;
}

// optional .apollo.planning.ScenarioEmergencyPullOverConfig emergency_pull_over_config = 4;
inline bool ScenarioConfig::has_emergency_pull_over_config() const {
  return scenario_config_case() == kEmergencyPullOverConfig;
}
inline void ScenarioConfig::set_has_emergency_pull_over_config() {
  _oneof_case_[0] = kEmergencyPullOverConfig;
}
inline void ScenarioConfig::clear_emergency_pull_over_config() {
  if (has_emergency_pull_over_config()) {
    delete scenario_config_.emergency_pull_over_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioEmergencyPullOverConfig& ScenarioConfig::_internal_emergency_pull_over_config() const {
  return *scenario_config_.emergency_pull_over_config_;
}
inline ::apollo::planning::ScenarioEmergencyPullOverConfig* ScenarioConfig::release_emergency_pull_over_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.emergency_pull_over_config)
  if (has_emergency_pull_over_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioEmergencyPullOverConfig* temp = scenario_config_.emergency_pull_over_config_;
    scenario_config_.emergency_pull_over_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioEmergencyPullOverConfig& ScenarioConfig::emergency_pull_over_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.emergency_pull_over_config)
  return has_emergency_pull_over_config()
      ? *scenario_config_.emergency_pull_over_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioEmergencyPullOverConfig*>(&::apollo::planning::_ScenarioEmergencyPullOverConfig_default_instance_);
}
inline ::apollo::planning::ScenarioEmergencyPullOverConfig* ScenarioConfig::mutable_emergency_pull_over_config() {
  if (!has_emergency_pull_over_config()) {
    clear_scenario_config();
    set_has_emergency_pull_over_config();
    scenario_config_.emergency_pull_over_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioEmergencyPullOverConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.emergency_pull_over_config)
  return scenario_config_.emergency_pull_over_config_;
}

// optional .apollo.planning.ScenarioEmergencyStopConfig emergency_stop_config = 5;
inline bool ScenarioConfig::has_emergency_stop_config() const {
  return scenario_config_case() == kEmergencyStopConfig;
}
inline void ScenarioConfig::set_has_emergency_stop_config() {
  _oneof_case_[0] = kEmergencyStopConfig;
}
inline void ScenarioConfig::clear_emergency_stop_config() {
  if (has_emergency_stop_config()) {
    delete scenario_config_.emergency_stop_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioEmergencyStopConfig& ScenarioConfig::_internal_emergency_stop_config() const {
  return *scenario_config_.emergency_stop_config_;
}
inline ::apollo::planning::ScenarioEmergencyStopConfig* ScenarioConfig::release_emergency_stop_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.emergency_stop_config)
  if (has_emergency_stop_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioEmergencyStopConfig* temp = scenario_config_.emergency_stop_config_;
    scenario_config_.emergency_stop_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioEmergencyStopConfig& ScenarioConfig::emergency_stop_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.emergency_stop_config)
  return has_emergency_stop_config()
      ? *scenario_config_.emergency_stop_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioEmergencyStopConfig*>(&::apollo::planning::_ScenarioEmergencyStopConfig_default_instance_);
}
inline ::apollo::planning::ScenarioEmergencyStopConfig* ScenarioConfig::mutable_emergency_stop_config() {
  if (!has_emergency_stop_config()) {
    clear_scenario_config();
    set_has_emergency_stop_config();
    scenario_config_.emergency_stop_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioEmergencyStopConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.emergency_stop_config)
  return scenario_config_.emergency_stop_config_;
}

// optional .apollo.planning.ScenarioLearningModelSampleConfig learning_model_sample_config = 6;
inline bool ScenarioConfig::has_learning_model_sample_config() const {
  return scenario_config_case() == kLearningModelSampleConfig;
}
inline void ScenarioConfig::set_has_learning_model_sample_config() {
  _oneof_case_[0] = kLearningModelSampleConfig;
}
inline void ScenarioConfig::clear_learning_model_sample_config() {
  if (has_learning_model_sample_config()) {
    delete scenario_config_.learning_model_sample_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioLearningModelSampleConfig& ScenarioConfig::_internal_learning_model_sample_config() const {
  return *scenario_config_.learning_model_sample_config_;
}
inline ::apollo::planning::ScenarioLearningModelSampleConfig* ScenarioConfig::release_learning_model_sample_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.learning_model_sample_config)
  if (has_learning_model_sample_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioLearningModelSampleConfig* temp = scenario_config_.learning_model_sample_config_;
    scenario_config_.learning_model_sample_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioLearningModelSampleConfig& ScenarioConfig::learning_model_sample_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.learning_model_sample_config)
  return has_learning_model_sample_config()
      ? *scenario_config_.learning_model_sample_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioLearningModelSampleConfig*>(&::apollo::planning::_ScenarioLearningModelSampleConfig_default_instance_);
}
inline ::apollo::planning::ScenarioLearningModelSampleConfig* ScenarioConfig::mutable_learning_model_sample_config() {
  if (!has_learning_model_sample_config()) {
    clear_scenario_config();
    set_has_learning_model_sample_config();
    scenario_config_.learning_model_sample_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioLearningModelSampleConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.learning_model_sample_config)
  return scenario_config_.learning_model_sample_config_;
}

// optional .apollo.planning.ScenarioNarrowStreetUTurnConfig narrow_street_u_turn_config = 7;
inline bool ScenarioConfig::has_narrow_street_u_turn_config() const {
  return scenario_config_case() == kNarrowStreetUTurnConfig;
}
inline void ScenarioConfig::set_has_narrow_street_u_turn_config() {
  _oneof_case_[0] = kNarrowStreetUTurnConfig;
}
inline void ScenarioConfig::clear_narrow_street_u_turn_config() {
  if (has_narrow_street_u_turn_config()) {
    delete scenario_config_.narrow_street_u_turn_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& ScenarioConfig::_internal_narrow_street_u_turn_config() const {
  return *scenario_config_.narrow_street_u_turn_config_;
}
inline ::apollo::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::release_narrow_street_u_turn_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.narrow_street_u_turn_config)
  if (has_narrow_street_u_turn_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioNarrowStreetUTurnConfig* temp = scenario_config_.narrow_street_u_turn_config_;
    scenario_config_.narrow_street_u_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioNarrowStreetUTurnConfig& ScenarioConfig::narrow_street_u_turn_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.narrow_street_u_turn_config)
  return has_narrow_street_u_turn_config()
      ? *scenario_config_.narrow_street_u_turn_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioNarrowStreetUTurnConfig*>(&::apollo::planning::_ScenarioNarrowStreetUTurnConfig_default_instance_);
}
inline ::apollo::planning::ScenarioNarrowStreetUTurnConfig* ScenarioConfig::mutable_narrow_street_u_turn_config() {
  if (!has_narrow_street_u_turn_config()) {
    clear_scenario_config();
    set_has_narrow_street_u_turn_config();
    scenario_config_.narrow_street_u_turn_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioNarrowStreetUTurnConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.narrow_street_u_turn_config)
  return scenario_config_.narrow_street_u_turn_config_;
}

// optional .apollo.planning.ScenarioParkAndGoConfig park_and_go_config = 8;
inline bool ScenarioConfig::has_park_and_go_config() const {
  return scenario_config_case() == kParkAndGoConfig;
}
inline void ScenarioConfig::set_has_park_and_go_config() {
  _oneof_case_[0] = kParkAndGoConfig;
}
inline void ScenarioConfig::clear_park_and_go_config() {
  if (has_park_and_go_config()) {
    delete scenario_config_.park_and_go_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioParkAndGoConfig& ScenarioConfig::_internal_park_and_go_config() const {
  return *scenario_config_.park_and_go_config_;
}
inline ::apollo::planning::ScenarioParkAndGoConfig* ScenarioConfig::release_park_and_go_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.park_and_go_config)
  if (has_park_and_go_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioParkAndGoConfig* temp = scenario_config_.park_and_go_config_;
    scenario_config_.park_and_go_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioParkAndGoConfig& ScenarioConfig::park_and_go_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.park_and_go_config)
  return has_park_and_go_config()
      ? *scenario_config_.park_and_go_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioParkAndGoConfig*>(&::apollo::planning::_ScenarioParkAndGoConfig_default_instance_);
}
inline ::apollo::planning::ScenarioParkAndGoConfig* ScenarioConfig::mutable_park_and_go_config() {
  if (!has_park_and_go_config()) {
    clear_scenario_config();
    set_has_park_and_go_config();
    scenario_config_.park_and_go_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioParkAndGoConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.park_and_go_config)
  return scenario_config_.park_and_go_config_;
}

// optional .apollo.planning.ScenarioPullOverConfig pull_over_config = 9;
inline bool ScenarioConfig::has_pull_over_config() const {
  return scenario_config_case() == kPullOverConfig;
}
inline void ScenarioConfig::set_has_pull_over_config() {
  _oneof_case_[0] = kPullOverConfig;
}
inline void ScenarioConfig::clear_pull_over_config() {
  if (has_pull_over_config()) {
    delete scenario_config_.pull_over_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioPullOverConfig& ScenarioConfig::_internal_pull_over_config() const {
  return *scenario_config_.pull_over_config_;
}
inline ::apollo::planning::ScenarioPullOverConfig* ScenarioConfig::release_pull_over_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.pull_over_config)
  if (has_pull_over_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioPullOverConfig* temp = scenario_config_.pull_over_config_;
    scenario_config_.pull_over_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioPullOverConfig& ScenarioConfig::pull_over_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.pull_over_config)
  return has_pull_over_config()
      ? *scenario_config_.pull_over_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioPullOverConfig*>(&::apollo::planning::_ScenarioPullOverConfig_default_instance_);
}
inline ::apollo::planning::ScenarioPullOverConfig* ScenarioConfig::mutable_pull_over_config() {
  if (!has_pull_over_config()) {
    clear_scenario_config();
    set_has_pull_over_config();
    scenario_config_.pull_over_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioPullOverConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.pull_over_config)
  return scenario_config_.pull_over_config_;
}

// optional .apollo.planning.ScenarioStopSignUnprotectedConfig stop_sign_unprotected_config = 10;
inline bool ScenarioConfig::has_stop_sign_unprotected_config() const {
  return scenario_config_case() == kStopSignUnprotectedConfig;
}
inline void ScenarioConfig::set_has_stop_sign_unprotected_config() {
  _oneof_case_[0] = kStopSignUnprotectedConfig;
}
inline void ScenarioConfig::clear_stop_sign_unprotected_config() {
  if (has_stop_sign_unprotected_config()) {
    delete scenario_config_.stop_sign_unprotected_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioStopSignUnprotectedConfig& ScenarioConfig::_internal_stop_sign_unprotected_config() const {
  return *scenario_config_.stop_sign_unprotected_config_;
}
inline ::apollo::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::release_stop_sign_unprotected_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.stop_sign_unprotected_config)
  if (has_stop_sign_unprotected_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioStopSignUnprotectedConfig* temp = scenario_config_.stop_sign_unprotected_config_;
    scenario_config_.stop_sign_unprotected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioStopSignUnprotectedConfig& ScenarioConfig::stop_sign_unprotected_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.stop_sign_unprotected_config)
  return has_stop_sign_unprotected_config()
      ? *scenario_config_.stop_sign_unprotected_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioStopSignUnprotectedConfig*>(&::apollo::planning::_ScenarioStopSignUnprotectedConfig_default_instance_);
}
inline ::apollo::planning::ScenarioStopSignUnprotectedConfig* ScenarioConfig::mutable_stop_sign_unprotected_config() {
  if (!has_stop_sign_unprotected_config()) {
    clear_scenario_config();
    set_has_stop_sign_unprotected_config();
    scenario_config_.stop_sign_unprotected_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioStopSignUnprotectedConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.stop_sign_unprotected_config)
  return scenario_config_.stop_sign_unprotected_config_;
}

// optional .apollo.planning.ScenarioTrafficLightProtectedConfig traffic_light_protected_config = 11;
inline bool ScenarioConfig::has_traffic_light_protected_config() const {
  return scenario_config_case() == kTrafficLightProtectedConfig;
}
inline void ScenarioConfig::set_has_traffic_light_protected_config() {
  _oneof_case_[0] = kTrafficLightProtectedConfig;
}
inline void ScenarioConfig::clear_traffic_light_protected_config() {
  if (has_traffic_light_protected_config()) {
    delete scenario_config_.traffic_light_protected_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioTrafficLightProtectedConfig& ScenarioConfig::_internal_traffic_light_protected_config() const {
  return *scenario_config_.traffic_light_protected_config_;
}
inline ::apollo::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::release_traffic_light_protected_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.traffic_light_protected_config)
  if (has_traffic_light_protected_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioTrafficLightProtectedConfig* temp = scenario_config_.traffic_light_protected_config_;
    scenario_config_.traffic_light_protected_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioTrafficLightProtectedConfig& ScenarioConfig::traffic_light_protected_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.traffic_light_protected_config)
  return has_traffic_light_protected_config()
      ? *scenario_config_.traffic_light_protected_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioTrafficLightProtectedConfig*>(&::apollo::planning::_ScenarioTrafficLightProtectedConfig_default_instance_);
}
inline ::apollo::planning::ScenarioTrafficLightProtectedConfig* ScenarioConfig::mutable_traffic_light_protected_config() {
  if (!has_traffic_light_protected_config()) {
    clear_scenario_config();
    set_has_traffic_light_protected_config();
    scenario_config_.traffic_light_protected_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioTrafficLightProtectedConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.traffic_light_protected_config)
  return scenario_config_.traffic_light_protected_config_;
}

// optional .apollo.planning.ScenarioTrafficLightUnprotectedLeftTurnConfig traffic_light_unprotected_left_turn_config = 12;
inline bool ScenarioConfig::has_traffic_light_unprotected_left_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedLeftTurnConfig;
}
inline void ScenarioConfig::set_has_traffic_light_unprotected_left_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedLeftTurnConfig;
}
inline void ScenarioConfig::clear_traffic_light_unprotected_left_turn_config() {
  if (has_traffic_light_unprotected_left_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_left_turn_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioConfig::_internal_traffic_light_unprotected_left_turn_config() const {
  return *scenario_config_.traffic_light_unprotected_left_turn_config_;
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::release_traffic_light_unprotected_left_turn_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  if (has_traffic_light_unprotected_left_turn_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* temp = scenario_config_.traffic_light_unprotected_left_turn_config_;
    scenario_config_.traffic_light_unprotected_left_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig& ScenarioConfig::traffic_light_unprotected_left_turn_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return has_traffic_light_unprotected_left_turn_config()
      ? *scenario_config_.traffic_light_unprotected_left_turn_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig*>(&::apollo::planning::_ScenarioTrafficLightUnprotectedLeftTurnConfig_default_instance_);
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_left_turn_config() {
  if (!has_traffic_light_unprotected_left_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_left_turn_config();
    scenario_config_.traffic_light_unprotected_left_turn_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioTrafficLightUnprotectedLeftTurnConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.traffic_light_unprotected_left_turn_config)
  return scenario_config_.traffic_light_unprotected_left_turn_config_;
}

// optional .apollo.planning.ScenarioTrafficLightUnprotectedRightTurnConfig traffic_light_unprotected_right_turn_config = 13;
inline bool ScenarioConfig::has_traffic_light_unprotected_right_turn_config() const {
  return scenario_config_case() == kTrafficLightUnprotectedRightTurnConfig;
}
inline void ScenarioConfig::set_has_traffic_light_unprotected_right_turn_config() {
  _oneof_case_[0] = kTrafficLightUnprotectedRightTurnConfig;
}
inline void ScenarioConfig::clear_traffic_light_unprotected_right_turn_config() {
  if (has_traffic_light_unprotected_right_turn_config()) {
    delete scenario_config_.traffic_light_unprotected_right_turn_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioConfig::_internal_traffic_light_unprotected_right_turn_config() const {
  return *scenario_config_.traffic_light_unprotected_right_turn_config_;
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::release_traffic_light_unprotected_right_turn_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  if (has_traffic_light_unprotected_right_turn_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* temp = scenario_config_.traffic_light_unprotected_right_turn_config_;
    scenario_config_.traffic_light_unprotected_right_turn_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig& ScenarioConfig::traffic_light_unprotected_right_turn_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return has_traffic_light_unprotected_right_turn_config()
      ? *scenario_config_.traffic_light_unprotected_right_turn_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig*>(&::apollo::planning::_ScenarioTrafficLightUnprotectedRightTurnConfig_default_instance_);
}
inline ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig* ScenarioConfig::mutable_traffic_light_unprotected_right_turn_config() {
  if (!has_traffic_light_unprotected_right_turn_config()) {
    clear_scenario_config();
    set_has_traffic_light_unprotected_right_turn_config();
    scenario_config_.traffic_light_unprotected_right_turn_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioTrafficLightUnprotectedRightTurnConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.traffic_light_unprotected_right_turn_config)
  return scenario_config_.traffic_light_unprotected_right_turn_config_;
}

// optional .apollo.planning.ScenarioValetParkingConfig valet_parking_config = 14;
inline bool ScenarioConfig::has_valet_parking_config() const {
  return scenario_config_case() == kValetParkingConfig;
}
inline void ScenarioConfig::set_has_valet_parking_config() {
  _oneof_case_[0] = kValetParkingConfig;
}
inline void ScenarioConfig::clear_valet_parking_config() {
  if (has_valet_parking_config()) {
    delete scenario_config_.valet_parking_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioValetParkingConfig& ScenarioConfig::_internal_valet_parking_config() const {
  return *scenario_config_.valet_parking_config_;
}
inline ::apollo::planning::ScenarioValetParkingConfig* ScenarioConfig::release_valet_parking_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.valet_parking_config)
  if (has_valet_parking_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioValetParkingConfig* temp = scenario_config_.valet_parking_config_;
    scenario_config_.valet_parking_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioValetParkingConfig& ScenarioConfig::valet_parking_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.valet_parking_config)
  return has_valet_parking_config()
      ? *scenario_config_.valet_parking_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioValetParkingConfig*>(&::apollo::planning::_ScenarioValetParkingConfig_default_instance_);
}
inline ::apollo::planning::ScenarioValetParkingConfig* ScenarioConfig::mutable_valet_parking_config() {
  if (!has_valet_parking_config()) {
    clear_scenario_config();
    set_has_valet_parking_config();
    scenario_config_.valet_parking_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioValetParkingConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.valet_parking_config)
  return scenario_config_.valet_parking_config_;
}

// optional .apollo.planning.ScenarioYieldSignConfig yield_sign_config = 15;
inline bool ScenarioConfig::has_yield_sign_config() const {
  return scenario_config_case() == kYieldSignConfig;
}
inline void ScenarioConfig::set_has_yield_sign_config() {
  _oneof_case_[0] = kYieldSignConfig;
}
inline void ScenarioConfig::clear_yield_sign_config() {
  if (has_yield_sign_config()) {
    delete scenario_config_.yield_sign_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioYieldSignConfig& ScenarioConfig::_internal_yield_sign_config() const {
  return *scenario_config_.yield_sign_config_;
}
inline ::apollo::planning::ScenarioYieldSignConfig* ScenarioConfig::release_yield_sign_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.yield_sign_config)
  if (has_yield_sign_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioYieldSignConfig* temp = scenario_config_.yield_sign_config_;
    scenario_config_.yield_sign_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioYieldSignConfig& ScenarioConfig::yield_sign_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.yield_sign_config)
  return has_yield_sign_config()
      ? *scenario_config_.yield_sign_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioYieldSignConfig*>(&::apollo::planning::_ScenarioYieldSignConfig_default_instance_);
}
inline ::apollo::planning::ScenarioYieldSignConfig* ScenarioConfig::mutable_yield_sign_config() {
  if (!has_yield_sign_config()) {
    clear_scenario_config();
    set_has_yield_sign_config();
    scenario_config_.yield_sign_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioYieldSignConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.yield_sign_config)
  return scenario_config_.yield_sign_config_;
}

// optional .apollo.planning.ScenarioDeadEndTurnAroundConfig deadend_turnaround_config = 18;
inline bool ScenarioConfig::has_deadend_turnaround_config() const {
  return scenario_config_case() == kDeadendTurnaroundConfig;
}
inline void ScenarioConfig::set_has_deadend_turnaround_config() {
  _oneof_case_[0] = kDeadendTurnaroundConfig;
}
inline void ScenarioConfig::clear_deadend_turnaround_config() {
  if (has_deadend_turnaround_config()) {
    delete scenario_config_.deadend_turnaround_config_;
    clear_has_scenario_config();
  }
}
inline const ::apollo::planning::ScenarioDeadEndTurnAroundConfig& ScenarioConfig::_internal_deadend_turnaround_config() const {
  return *scenario_config_.deadend_turnaround_config_;
}
inline ::apollo::planning::ScenarioDeadEndTurnAroundConfig* ScenarioConfig::release_deadend_turnaround_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.ScenarioConfig.deadend_turnaround_config)
  if (has_deadend_turnaround_config()) {
    clear_has_scenario_config();
      ::apollo::planning::ScenarioDeadEndTurnAroundConfig* temp = scenario_config_.deadend_turnaround_config_;
    scenario_config_.deadend_turnaround_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::ScenarioDeadEndTurnAroundConfig& ScenarioConfig::deadend_turnaround_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.deadend_turnaround_config)
  return has_deadend_turnaround_config()
      ? *scenario_config_.deadend_turnaround_config_
      : *reinterpret_cast< ::apollo::planning::ScenarioDeadEndTurnAroundConfig*>(&::apollo::planning::_ScenarioDeadEndTurnAroundConfig_default_instance_);
}
inline ::apollo::planning::ScenarioDeadEndTurnAroundConfig* ScenarioConfig::mutable_deadend_turnaround_config() {
  if (!has_deadend_turnaround_config()) {
    clear_scenario_config();
    set_has_deadend_turnaround_config();
    scenario_config_.deadend_turnaround_config_ = CreateMaybeMessage< ::apollo::planning::ScenarioDeadEndTurnAroundConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.deadend_turnaround_config)
  return scenario_config_.deadend_turnaround_config_;
}

// repeated .apollo.planning.ScenarioConfig.StageType stage_type = 16;
inline int ScenarioConfig::stage_type_size() const {
  return stage_type_.size();
}
inline void ScenarioConfig::clear_stage_type() {
  stage_type_.Clear();
}
inline ::apollo::planning::ScenarioConfig_StageType ScenarioConfig::stage_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.stage_type)
  return static_cast< ::apollo::planning::ScenarioConfig_StageType >(stage_type_.Get(index));
}
inline void ScenarioConfig::set_stage_type(int index, ::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.ScenarioConfig.stage_type)
}
inline void ScenarioConfig::add_stage_type(::apollo::planning::ScenarioConfig_StageType value) {
  assert(::apollo::planning::ScenarioConfig_StageType_IsValid(value));
  stage_type_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.stage_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ScenarioConfig::stage_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.stage_type)
  return stage_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ScenarioConfig::mutable_stage_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.stage_type)
  return &stage_type_;
}

// repeated .apollo.planning.ScenarioConfig.StageConfig stage_config = 17;
inline int ScenarioConfig::stage_config_size() const {
  return stage_config_.size();
}
inline void ScenarioConfig::clear_stage_config() {
  stage_config_.Clear();
}
inline ::apollo::planning::ScenarioConfig_StageConfig* ScenarioConfig::mutable_stage_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.ScenarioConfig.stage_config)
  return stage_config_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >*
ScenarioConfig::mutable_stage_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.ScenarioConfig.stage_config)
  return &stage_config_;
}
inline const ::apollo::planning::ScenarioConfig_StageConfig& ScenarioConfig::stage_config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.ScenarioConfig.stage_config)
  return stage_config_.Get(index);
}
inline ::apollo::planning::ScenarioConfig_StageConfig* ScenarioConfig::add_stage_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.ScenarioConfig.stage_config)
  return stage_config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::ScenarioConfig_StageConfig >&
ScenarioConfig::stage_config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.ScenarioConfig.stage_config)
  return stage_config_;
}

inline bool ScenarioConfig::has_scenario_config() const {
  return scenario_config_case() != SCENARIO_CONFIG_NOT_SET;
}
inline void ScenarioConfig::clear_has_scenario_config() {
  _oneof_case_[0] = SCENARIO_CONFIG_NOT_SET;
}
inline ScenarioConfig::ScenarioConfigCase ScenarioConfig::scenario_config_case() const {
  return ScenarioConfig::ScenarioConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlannerPublicRoadConfig

// -------------------------------------------------------------------

// PlannerNaviConfig

// repeated .apollo.planning.TaskConfig.TaskType task = 1;
inline int PlannerNaviConfig::task_size() const {
  return task_.size();
}
inline void PlannerNaviConfig::clear_task() {
  task_.Clear();
}
inline ::apollo::planning::TaskConfig_TaskType PlannerNaviConfig::task(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.task)
  return static_cast< ::apollo::planning::TaskConfig_TaskType >(task_.Get(index));
}
inline void PlannerNaviConfig::set_task(int index, ::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.PlannerNaviConfig.task)
}
inline void PlannerNaviConfig::add_task(::apollo::planning::TaskConfig_TaskType value) {
  assert(::apollo::planning::TaskConfig_TaskType_IsValid(value));
  task_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.PlannerNaviConfig.task)
}
inline const ::google::protobuf::RepeatedField<int>&
PlannerNaviConfig::task() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PlannerNaviConfig.task)
  return task_;
}
inline ::google::protobuf::RepeatedField<int>*
PlannerNaviConfig::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PlannerNaviConfig.task)
  return &task_;
}

// optional .apollo.planning.NaviPathDeciderConfig navi_path_decider_config = 2;
inline bool PlannerNaviConfig::has_navi_path_decider_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerNaviConfig::set_has_navi_path_decider_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlannerNaviConfig::clear_has_navi_path_decider_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::planning::NaviPathDeciderConfig& PlannerNaviConfig::_internal_navi_path_decider_config() const {
  return *navi_path_decider_config_;
}
inline const ::apollo::planning::NaviPathDeciderConfig& PlannerNaviConfig::navi_path_decider_config() const {
  const ::apollo::planning::NaviPathDeciderConfig* p = navi_path_decider_config_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::NaviPathDeciderConfig*>(
      &::apollo::planning::_NaviPathDeciderConfig_default_instance_);
}
inline ::apollo::planning::NaviPathDeciderConfig* PlannerNaviConfig::release_navi_path_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
  clear_has_navi_path_decider_config();
  ::apollo::planning::NaviPathDeciderConfig* temp = navi_path_decider_config_;
  navi_path_decider_config_ = NULL;
  return temp;
}
inline ::apollo::planning::NaviPathDeciderConfig* PlannerNaviConfig::mutable_navi_path_decider_config() {
  set_has_navi_path_decider_config();
  if (navi_path_decider_config_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::NaviPathDeciderConfig>(GetArenaNoVirtual());
    navi_path_decider_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
  return navi_path_decider_config_;
}
inline void PlannerNaviConfig::set_allocated_navi_path_decider_config(::apollo::planning::NaviPathDeciderConfig* navi_path_decider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(navi_path_decider_config_);
  }
  if (navi_path_decider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navi_path_decider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navi_path_decider_config, submessage_arena);
    }
    set_has_navi_path_decider_config();
  } else {
    clear_has_navi_path_decider_config();
  }
  navi_path_decider_config_ = navi_path_decider_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlannerNaviConfig.navi_path_decider_config)
}

// optional .apollo.planning.NaviSpeedDeciderConfig navi_speed_decider_config = 3;
inline bool PlannerNaviConfig::has_navi_speed_decider_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerNaviConfig::set_has_navi_speed_decider_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlannerNaviConfig::clear_has_navi_speed_decider_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::apollo::planning::NaviSpeedDeciderConfig& PlannerNaviConfig::_internal_navi_speed_decider_config() const {
  return *navi_speed_decider_config_;
}
inline const ::apollo::planning::NaviSpeedDeciderConfig& PlannerNaviConfig::navi_speed_decider_config() const {
  const ::apollo::planning::NaviSpeedDeciderConfig* p = navi_speed_decider_config_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::NaviSpeedDeciderConfig*>(
      &::apollo::planning::_NaviSpeedDeciderConfig_default_instance_);
}
inline ::apollo::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::release_navi_speed_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
  clear_has_navi_speed_decider_config();
  ::apollo::planning::NaviSpeedDeciderConfig* temp = navi_speed_decider_config_;
  navi_speed_decider_config_ = NULL;
  return temp;
}
inline ::apollo::planning::NaviSpeedDeciderConfig* PlannerNaviConfig::mutable_navi_speed_decider_config() {
  set_has_navi_speed_decider_config();
  if (navi_speed_decider_config_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::NaviSpeedDeciderConfig>(GetArenaNoVirtual());
    navi_speed_decider_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
  return navi_speed_decider_config_;
}
inline void PlannerNaviConfig::set_allocated_navi_speed_decider_config(::apollo::planning::NaviSpeedDeciderConfig* navi_speed_decider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(navi_speed_decider_config_);
  }
  if (navi_speed_decider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navi_speed_decider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navi_speed_decider_config, submessage_arena);
    }
    set_has_navi_speed_decider_config();
  } else {
    clear_has_navi_speed_decider_config();
  }
  navi_speed_decider_config_ = navi_speed_decider_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlannerNaviConfig.navi_speed_decider_config)
}

// optional .apollo.planning.NaviObstacleDeciderConfig navi_obstacle_decider_config = 4;
inline bool PlannerNaviConfig::has_navi_obstacle_decider_config() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerNaviConfig::set_has_navi_obstacle_decider_config() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlannerNaviConfig::clear_has_navi_obstacle_decider_config() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::apollo::planning::NaviObstacleDeciderConfig& PlannerNaviConfig::_internal_navi_obstacle_decider_config() const {
  return *navi_obstacle_decider_config_;
}
inline const ::apollo::planning::NaviObstacleDeciderConfig& PlannerNaviConfig::navi_obstacle_decider_config() const {
  const ::apollo::planning::NaviObstacleDeciderConfig* p = navi_obstacle_decider_config_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::NaviObstacleDeciderConfig*>(
      &::apollo::planning::_NaviObstacleDeciderConfig_default_instance_);
}
inline ::apollo::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::release_navi_obstacle_decider_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  clear_has_navi_obstacle_decider_config();
  ::apollo::planning::NaviObstacleDeciderConfig* temp = navi_obstacle_decider_config_;
  navi_obstacle_decider_config_ = NULL;
  return temp;
}
inline ::apollo::planning::NaviObstacleDeciderConfig* PlannerNaviConfig::mutable_navi_obstacle_decider_config() {
  set_has_navi_obstacle_decider_config();
  if (navi_obstacle_decider_config_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::NaviObstacleDeciderConfig>(GetArenaNoVirtual());
    navi_obstacle_decider_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
  return navi_obstacle_decider_config_;
}
inline void PlannerNaviConfig::set_allocated_navi_obstacle_decider_config(::apollo::planning::NaviObstacleDeciderConfig* navi_obstacle_decider_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(navi_obstacle_decider_config_);
  }
  if (navi_obstacle_decider_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      navi_obstacle_decider_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navi_obstacle_decider_config, submessage_arena);
    }
    set_has_navi_obstacle_decider_config();
  } else {
    clear_has_navi_obstacle_decider_config();
  }
  navi_obstacle_decider_config_ = navi_obstacle_decider_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlannerNaviConfig.navi_obstacle_decider_config)
}

// -------------------------------------------------------------------

// RtkPlanningConfig

// optional .apollo.planning.PlannerType planner_type = 1;
inline bool RtkPlanningConfig::has_planner_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtkPlanningConfig::set_has_planner_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtkPlanningConfig::clear_has_planner_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtkPlanningConfig::clear_planner_type() {
  planner_type_ = 0;
  clear_has_planner_type();
}
inline ::apollo::planning::PlannerType RtkPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_get:apollo.planning.RtkPlanningConfig.planner_type)
  return static_cast< ::apollo::planning::PlannerType >(planner_type_);
}
inline void RtkPlanningConfig::set_planner_type(::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  set_has_planner_type();
  planner_type_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.RtkPlanningConfig.planner_type)
}

// -------------------------------------------------------------------

// StandardPlanningConfig

// repeated .apollo.planning.PlannerType planner_type = 1;
inline int StandardPlanningConfig::planner_type_size() const {
  return planner_type_.size();
}
inline void StandardPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
inline ::apollo::planning::PlannerType StandardPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StandardPlanningConfig.planner_type)
  return static_cast< ::apollo::planning::PlannerType >(planner_type_.Get(index));
}
inline void StandardPlanningConfig::set_planner_type(int index, ::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.StandardPlanningConfig.planner_type)
}
inline void StandardPlanningConfig::add_planner_type(::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.StandardPlanningConfig.planner_type)
}
inline const ::google::protobuf::RepeatedField<int>&
StandardPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StandardPlanningConfig.planner_type)
  return planner_type_;
}
inline ::google::protobuf::RepeatedField<int>*
StandardPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StandardPlanningConfig.planner_type)
  return &planner_type_;
}

// optional .apollo.planning.PlannerPublicRoadConfig planner_public_road_config = 2;
inline bool StandardPlanningConfig::has_planner_public_road_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StandardPlanningConfig::set_has_planner_public_road_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StandardPlanningConfig::clear_has_planner_public_road_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StandardPlanningConfig::clear_planner_public_road_config() {
  if (planner_public_road_config_ != NULL) planner_public_road_config_->Clear();
  clear_has_planner_public_road_config();
}
inline const ::apollo::planning::PlannerPublicRoadConfig& StandardPlanningConfig::_internal_planner_public_road_config() const {
  return *planner_public_road_config_;
}
inline const ::apollo::planning::PlannerPublicRoadConfig& StandardPlanningConfig::planner_public_road_config() const {
  const ::apollo::planning::PlannerPublicRoadConfig* p = planner_public_road_config_;
  // @@protoc_insertion_point(field_get:apollo.planning.StandardPlanningConfig.planner_public_road_config)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::PlannerPublicRoadConfig*>(
      &::apollo::planning::_PlannerPublicRoadConfig_default_instance_);
}
inline ::apollo::planning::PlannerPublicRoadConfig* StandardPlanningConfig::release_planner_public_road_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.StandardPlanningConfig.planner_public_road_config)
  clear_has_planner_public_road_config();
  ::apollo::planning::PlannerPublicRoadConfig* temp = planner_public_road_config_;
  planner_public_road_config_ = NULL;
  return temp;
}
inline ::apollo::planning::PlannerPublicRoadConfig* StandardPlanningConfig::mutable_planner_public_road_config() {
  set_has_planner_public_road_config();
  if (planner_public_road_config_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlannerPublicRoadConfig>(GetArenaNoVirtual());
    planner_public_road_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.StandardPlanningConfig.planner_public_road_config)
  return planner_public_road_config_;
}
inline void StandardPlanningConfig::set_allocated_planner_public_road_config(::apollo::planning::PlannerPublicRoadConfig* planner_public_road_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete planner_public_road_config_;
  }
  if (planner_public_road_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      planner_public_road_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, planner_public_road_config, submessage_arena);
    }
    set_has_planner_public_road_config();
  } else {
    clear_has_planner_public_road_config();
  }
  planner_public_road_config_ = planner_public_road_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StandardPlanningConfig.planner_public_road_config)
}

// -------------------------------------------------------------------

// NavigationPlanningConfig

// repeated .apollo.planning.PlannerType planner_type = 1;
inline int NavigationPlanningConfig::planner_type_size() const {
  return planner_type_.size();
}
inline void NavigationPlanningConfig::clear_planner_type() {
  planner_type_.Clear();
}
inline ::apollo::planning::PlannerType NavigationPlanningConfig::planner_type(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.NavigationPlanningConfig.planner_type)
  return static_cast< ::apollo::planning::PlannerType >(planner_type_.Get(index));
}
inline void NavigationPlanningConfig::set_planner_type(int index, ::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.NavigationPlanningConfig.planner_type)
}
inline void NavigationPlanningConfig::add_planner_type(::apollo::planning::PlannerType value) {
  assert(::apollo::planning::PlannerType_IsValid(value));
  planner_type_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.NavigationPlanningConfig.planner_type)
}
inline const ::google::protobuf::RepeatedField<int>&
NavigationPlanningConfig::planner_type() const {
  // @@protoc_insertion_point(field_list:apollo.planning.NavigationPlanningConfig.planner_type)
  return planner_type_;
}
inline ::google::protobuf::RepeatedField<int>*
NavigationPlanningConfig::mutable_planner_type() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.NavigationPlanningConfig.planner_type)
  return &planner_type_;
}

// optional .apollo.planning.PlannerNaviConfig planner_navi_config = 4;
inline bool NavigationPlanningConfig::has_planner_navi_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigationPlanningConfig::set_has_planner_navi_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigationPlanningConfig::clear_has_planner_navi_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigationPlanningConfig::clear_planner_navi_config() {
  if (planner_navi_config_ != NULL) planner_navi_config_->Clear();
  clear_has_planner_navi_config();
}
inline const ::apollo::planning::PlannerNaviConfig& NavigationPlanningConfig::_internal_planner_navi_config() const {
  return *planner_navi_config_;
}
inline const ::apollo::planning::PlannerNaviConfig& NavigationPlanningConfig::planner_navi_config() const {
  const ::apollo::planning::PlannerNaviConfig* p = planner_navi_config_;
  // @@protoc_insertion_point(field_get:apollo.planning.NavigationPlanningConfig.planner_navi_config)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::PlannerNaviConfig*>(
      &::apollo::planning::_PlannerNaviConfig_default_instance_);
}
inline ::apollo::planning::PlannerNaviConfig* NavigationPlanningConfig::release_planner_navi_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.NavigationPlanningConfig.planner_navi_config)
  clear_has_planner_navi_config();
  ::apollo::planning::PlannerNaviConfig* temp = planner_navi_config_;
  planner_navi_config_ = NULL;
  return temp;
}
inline ::apollo::planning::PlannerNaviConfig* NavigationPlanningConfig::mutable_planner_navi_config() {
  set_has_planner_navi_config();
  if (planner_navi_config_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::PlannerNaviConfig>(GetArenaNoVirtual());
    planner_navi_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.NavigationPlanningConfig.planner_navi_config)
  return planner_navi_config_;
}
inline void NavigationPlanningConfig::set_allocated_planner_navi_config(::apollo::planning::PlannerNaviConfig* planner_navi_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete planner_navi_config_;
  }
  if (planner_navi_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      planner_navi_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, planner_navi_config, submessage_arena);
    }
    set_has_planner_navi_config();
  } else {
    clear_has_planner_navi_config();
  }
  planner_navi_config_ = planner_navi_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.NavigationPlanningConfig.planner_navi_config)
}

// -------------------------------------------------------------------

// TopicConfig

// optional string chassis_topic = 1;
inline bool TopicConfig::has_chassis_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicConfig::set_has_chassis_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicConfig::clear_has_chassis_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicConfig::clear_chassis_topic() {
  chassis_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_chassis_topic();
}
inline const ::std::string& TopicConfig::chassis_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.chassis_topic)
  return chassis_topic_.GetNoArena();
}
inline void TopicConfig::set_chassis_topic(const ::std::string& value) {
  set_has_chassis_topic();
  chassis_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.chassis_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_chassis_topic(::std::string&& value) {
  set_has_chassis_topic();
  chassis_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.chassis_topic)
}
#endif
inline void TopicConfig::set_chassis_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_chassis_topic();
  chassis_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.chassis_topic)
}
inline void TopicConfig::set_chassis_topic(const char* value, size_t size) {
  set_has_chassis_topic();
  chassis_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.chassis_topic)
}
inline ::std::string* TopicConfig::mutable_chassis_topic() {
  set_has_chassis_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.chassis_topic)
  return chassis_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_chassis_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.chassis_topic)
  if (!has_chassis_topic()) {
    return NULL;
  }
  clear_has_chassis_topic();
  return chassis_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_chassis_topic(::std::string* chassis_topic) {
  if (chassis_topic != NULL) {
    set_has_chassis_topic();
  } else {
    clear_has_chassis_topic();
  }
  chassis_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chassis_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.chassis_topic)
}

// optional string hmi_status_topic = 2;
inline bool TopicConfig::has_hmi_status_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicConfig::set_has_hmi_status_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicConfig::clear_has_hmi_status_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicConfig::clear_hmi_status_topic() {
  hmi_status_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hmi_status_topic();
}
inline const ::std::string& TopicConfig::hmi_status_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.hmi_status_topic)
  return hmi_status_topic_.GetNoArena();
}
inline void TopicConfig::set_hmi_status_topic(const ::std::string& value) {
  set_has_hmi_status_topic();
  hmi_status_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.hmi_status_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_hmi_status_topic(::std::string&& value) {
  set_has_hmi_status_topic();
  hmi_status_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.hmi_status_topic)
}
#endif
inline void TopicConfig::set_hmi_status_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hmi_status_topic();
  hmi_status_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.hmi_status_topic)
}
inline void TopicConfig::set_hmi_status_topic(const char* value, size_t size) {
  set_has_hmi_status_topic();
  hmi_status_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.hmi_status_topic)
}
inline ::std::string* TopicConfig::mutable_hmi_status_topic() {
  set_has_hmi_status_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.hmi_status_topic)
  return hmi_status_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_hmi_status_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.hmi_status_topic)
  if (!has_hmi_status_topic()) {
    return NULL;
  }
  clear_has_hmi_status_topic();
  return hmi_status_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_hmi_status_topic(::std::string* hmi_status_topic) {
  if (hmi_status_topic != NULL) {
    set_has_hmi_status_topic();
  } else {
    clear_has_hmi_status_topic();
  }
  hmi_status_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmi_status_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.hmi_status_topic)
}

// optional string localization_topic = 3;
inline bool TopicConfig::has_localization_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicConfig::set_has_localization_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicConfig::clear_has_localization_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicConfig::clear_localization_topic() {
  localization_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_localization_topic();
}
inline const ::std::string& TopicConfig::localization_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.localization_topic)
  return localization_topic_.GetNoArena();
}
inline void TopicConfig::set_localization_topic(const ::std::string& value) {
  set_has_localization_topic();
  localization_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.localization_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_localization_topic(::std::string&& value) {
  set_has_localization_topic();
  localization_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.localization_topic)
}
#endif
inline void TopicConfig::set_localization_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_localization_topic();
  localization_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.localization_topic)
}
inline void TopicConfig::set_localization_topic(const char* value, size_t size) {
  set_has_localization_topic();
  localization_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.localization_topic)
}
inline ::std::string* TopicConfig::mutable_localization_topic() {
  set_has_localization_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.localization_topic)
  return localization_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_localization_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.localization_topic)
  if (!has_localization_topic()) {
    return NULL;
  }
  clear_has_localization_topic();
  return localization_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_localization_topic(::std::string* localization_topic) {
  if (localization_topic != NULL) {
    set_has_localization_topic();
  } else {
    clear_has_localization_topic();
  }
  localization_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), localization_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.localization_topic)
}

// optional string planning_pad_topic = 4;
inline bool TopicConfig::has_planning_pad_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopicConfig::set_has_planning_pad_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopicConfig::clear_has_planning_pad_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopicConfig::clear_planning_pad_topic() {
  planning_pad_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_planning_pad_topic();
}
inline const ::std::string& TopicConfig::planning_pad_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.planning_pad_topic)
  return planning_pad_topic_.GetNoArena();
}
inline void TopicConfig::set_planning_pad_topic(const ::std::string& value) {
  set_has_planning_pad_topic();
  planning_pad_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.planning_pad_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_planning_pad_topic(::std::string&& value) {
  set_has_planning_pad_topic();
  planning_pad_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.planning_pad_topic)
}
#endif
inline void TopicConfig::set_planning_pad_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_planning_pad_topic();
  planning_pad_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.planning_pad_topic)
}
inline void TopicConfig::set_planning_pad_topic(const char* value, size_t size) {
  set_has_planning_pad_topic();
  planning_pad_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.planning_pad_topic)
}
inline ::std::string* TopicConfig::mutable_planning_pad_topic() {
  set_has_planning_pad_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.planning_pad_topic)
  return planning_pad_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_planning_pad_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.planning_pad_topic)
  if (!has_planning_pad_topic()) {
    return NULL;
  }
  clear_has_planning_pad_topic();
  return planning_pad_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_planning_pad_topic(::std::string* planning_pad_topic) {
  if (planning_pad_topic != NULL) {
    set_has_planning_pad_topic();
  } else {
    clear_has_planning_pad_topic();
  }
  planning_pad_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), planning_pad_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.planning_pad_topic)
}

// optional string planning_trajectory_topic = 5;
inline bool TopicConfig::has_planning_trajectory_topic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopicConfig::set_has_planning_trajectory_topic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopicConfig::clear_has_planning_trajectory_topic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopicConfig::clear_planning_trajectory_topic() {
  planning_trajectory_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_planning_trajectory_topic();
}
inline const ::std::string& TopicConfig::planning_trajectory_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.planning_trajectory_topic)
  return planning_trajectory_topic_.GetNoArena();
}
inline void TopicConfig::set_planning_trajectory_topic(const ::std::string& value) {
  set_has_planning_trajectory_topic();
  planning_trajectory_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.planning_trajectory_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_planning_trajectory_topic(::std::string&& value) {
  set_has_planning_trajectory_topic();
  planning_trajectory_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.planning_trajectory_topic)
}
#endif
inline void TopicConfig::set_planning_trajectory_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_planning_trajectory_topic();
  planning_trajectory_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.planning_trajectory_topic)
}
inline void TopicConfig::set_planning_trajectory_topic(const char* value, size_t size) {
  set_has_planning_trajectory_topic();
  planning_trajectory_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.planning_trajectory_topic)
}
inline ::std::string* TopicConfig::mutable_planning_trajectory_topic() {
  set_has_planning_trajectory_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.planning_trajectory_topic)
  return planning_trajectory_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_planning_trajectory_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.planning_trajectory_topic)
  if (!has_planning_trajectory_topic()) {
    return NULL;
  }
  clear_has_planning_trajectory_topic();
  return planning_trajectory_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_planning_trajectory_topic(::std::string* planning_trajectory_topic) {
  if (planning_trajectory_topic != NULL) {
    set_has_planning_trajectory_topic();
  } else {
    clear_has_planning_trajectory_topic();
  }
  planning_trajectory_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), planning_trajectory_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.planning_trajectory_topic)
}

// optional string prediction_topic = 6;
inline bool TopicConfig::has_prediction_topic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopicConfig::set_has_prediction_topic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopicConfig::clear_has_prediction_topic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopicConfig::clear_prediction_topic() {
  prediction_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prediction_topic();
}
inline const ::std::string& TopicConfig::prediction_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.prediction_topic)
  return prediction_topic_.GetNoArena();
}
inline void TopicConfig::set_prediction_topic(const ::std::string& value) {
  set_has_prediction_topic();
  prediction_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.prediction_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_prediction_topic(::std::string&& value) {
  set_has_prediction_topic();
  prediction_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.prediction_topic)
}
#endif
inline void TopicConfig::set_prediction_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prediction_topic();
  prediction_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.prediction_topic)
}
inline void TopicConfig::set_prediction_topic(const char* value, size_t size) {
  set_has_prediction_topic();
  prediction_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.prediction_topic)
}
inline ::std::string* TopicConfig::mutable_prediction_topic() {
  set_has_prediction_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.prediction_topic)
  return prediction_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_prediction_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.prediction_topic)
  if (!has_prediction_topic()) {
    return NULL;
  }
  clear_has_prediction_topic();
  return prediction_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_prediction_topic(::std::string* prediction_topic) {
  if (prediction_topic != NULL) {
    set_has_prediction_topic();
  } else {
    clear_has_prediction_topic();
  }
  prediction_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prediction_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.prediction_topic)
}

// optional string relative_map_topic = 7;
inline bool TopicConfig::has_relative_map_topic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TopicConfig::set_has_relative_map_topic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TopicConfig::clear_has_relative_map_topic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TopicConfig::clear_relative_map_topic() {
  relative_map_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_relative_map_topic();
}
inline const ::std::string& TopicConfig::relative_map_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.relative_map_topic)
  return relative_map_topic_.GetNoArena();
}
inline void TopicConfig::set_relative_map_topic(const ::std::string& value) {
  set_has_relative_map_topic();
  relative_map_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.relative_map_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_relative_map_topic(::std::string&& value) {
  set_has_relative_map_topic();
  relative_map_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.relative_map_topic)
}
#endif
inline void TopicConfig::set_relative_map_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_relative_map_topic();
  relative_map_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.relative_map_topic)
}
inline void TopicConfig::set_relative_map_topic(const char* value, size_t size) {
  set_has_relative_map_topic();
  relative_map_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.relative_map_topic)
}
inline ::std::string* TopicConfig::mutable_relative_map_topic() {
  set_has_relative_map_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.relative_map_topic)
  return relative_map_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_relative_map_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.relative_map_topic)
  if (!has_relative_map_topic()) {
    return NULL;
  }
  clear_has_relative_map_topic();
  return relative_map_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_relative_map_topic(::std::string* relative_map_topic) {
  if (relative_map_topic != NULL) {
    set_has_relative_map_topic();
  } else {
    clear_has_relative_map_topic();
  }
  relative_map_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), relative_map_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.relative_map_topic)
}

// optional string routing_request_topic = 8;
inline bool TopicConfig::has_routing_request_topic() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TopicConfig::set_has_routing_request_topic() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TopicConfig::clear_has_routing_request_topic() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TopicConfig::clear_routing_request_topic() {
  routing_request_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_routing_request_topic();
}
inline const ::std::string& TopicConfig::routing_request_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.routing_request_topic)
  return routing_request_topic_.GetNoArena();
}
inline void TopicConfig::set_routing_request_topic(const ::std::string& value) {
  set_has_routing_request_topic();
  routing_request_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.routing_request_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_routing_request_topic(::std::string&& value) {
  set_has_routing_request_topic();
  routing_request_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.routing_request_topic)
}
#endif
inline void TopicConfig::set_routing_request_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_routing_request_topic();
  routing_request_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.routing_request_topic)
}
inline void TopicConfig::set_routing_request_topic(const char* value, size_t size) {
  set_has_routing_request_topic();
  routing_request_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.routing_request_topic)
}
inline ::std::string* TopicConfig::mutable_routing_request_topic() {
  set_has_routing_request_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.routing_request_topic)
  return routing_request_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_routing_request_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.routing_request_topic)
  if (!has_routing_request_topic()) {
    return NULL;
  }
  clear_has_routing_request_topic();
  return routing_request_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_routing_request_topic(::std::string* routing_request_topic) {
  if (routing_request_topic != NULL) {
    set_has_routing_request_topic();
  } else {
    clear_has_routing_request_topic();
  }
  routing_request_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), routing_request_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.routing_request_topic)
}

// optional string routing_response_topic = 9;
inline bool TopicConfig::has_routing_response_topic() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TopicConfig::set_has_routing_response_topic() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TopicConfig::clear_has_routing_response_topic() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TopicConfig::clear_routing_response_topic() {
  routing_response_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_routing_response_topic();
}
inline const ::std::string& TopicConfig::routing_response_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.routing_response_topic)
  return routing_response_topic_.GetNoArena();
}
inline void TopicConfig::set_routing_response_topic(const ::std::string& value) {
  set_has_routing_response_topic();
  routing_response_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.routing_response_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_routing_response_topic(::std::string&& value) {
  set_has_routing_response_topic();
  routing_response_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.routing_response_topic)
}
#endif
inline void TopicConfig::set_routing_response_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_routing_response_topic();
  routing_response_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.routing_response_topic)
}
inline void TopicConfig::set_routing_response_topic(const char* value, size_t size) {
  set_has_routing_response_topic();
  routing_response_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.routing_response_topic)
}
inline ::std::string* TopicConfig::mutable_routing_response_topic() {
  set_has_routing_response_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.routing_response_topic)
  return routing_response_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_routing_response_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.routing_response_topic)
  if (!has_routing_response_topic()) {
    return NULL;
  }
  clear_has_routing_response_topic();
  return routing_response_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_routing_response_topic(::std::string* routing_response_topic) {
  if (routing_response_topic != NULL) {
    set_has_routing_response_topic();
  } else {
    clear_has_routing_response_topic();
  }
  routing_response_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), routing_response_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.routing_response_topic)
}

// optional string story_telling_topic = 10;
inline bool TopicConfig::has_story_telling_topic() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TopicConfig::set_has_story_telling_topic() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TopicConfig::clear_has_story_telling_topic() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TopicConfig::clear_story_telling_topic() {
  story_telling_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_story_telling_topic();
}
inline const ::std::string& TopicConfig::story_telling_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.story_telling_topic)
  return story_telling_topic_.GetNoArena();
}
inline void TopicConfig::set_story_telling_topic(const ::std::string& value) {
  set_has_story_telling_topic();
  story_telling_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.story_telling_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_story_telling_topic(::std::string&& value) {
  set_has_story_telling_topic();
  story_telling_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.story_telling_topic)
}
#endif
inline void TopicConfig::set_story_telling_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_story_telling_topic();
  story_telling_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.story_telling_topic)
}
inline void TopicConfig::set_story_telling_topic(const char* value, size_t size) {
  set_has_story_telling_topic();
  story_telling_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.story_telling_topic)
}
inline ::std::string* TopicConfig::mutable_story_telling_topic() {
  set_has_story_telling_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.story_telling_topic)
  return story_telling_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_story_telling_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.story_telling_topic)
  if (!has_story_telling_topic()) {
    return NULL;
  }
  clear_has_story_telling_topic();
  return story_telling_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_story_telling_topic(::std::string* story_telling_topic) {
  if (story_telling_topic != NULL) {
    set_has_story_telling_topic();
  } else {
    clear_has_story_telling_topic();
  }
  story_telling_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), story_telling_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.story_telling_topic)
}

// optional string traffic_light_detection_topic = 11;
inline bool TopicConfig::has_traffic_light_detection_topic() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TopicConfig::set_has_traffic_light_detection_topic() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TopicConfig::clear_has_traffic_light_detection_topic() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TopicConfig::clear_traffic_light_detection_topic() {
  traffic_light_detection_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_traffic_light_detection_topic();
}
inline const ::std::string& TopicConfig::traffic_light_detection_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.traffic_light_detection_topic)
  return traffic_light_detection_topic_.GetNoArena();
}
inline void TopicConfig::set_traffic_light_detection_topic(const ::std::string& value) {
  set_has_traffic_light_detection_topic();
  traffic_light_detection_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.traffic_light_detection_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_traffic_light_detection_topic(::std::string&& value) {
  set_has_traffic_light_detection_topic();
  traffic_light_detection_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.traffic_light_detection_topic)
}
#endif
inline void TopicConfig::set_traffic_light_detection_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_traffic_light_detection_topic();
  traffic_light_detection_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.traffic_light_detection_topic)
}
inline void TopicConfig::set_traffic_light_detection_topic(const char* value, size_t size) {
  set_has_traffic_light_detection_topic();
  traffic_light_detection_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.traffic_light_detection_topic)
}
inline ::std::string* TopicConfig::mutable_traffic_light_detection_topic() {
  set_has_traffic_light_detection_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.traffic_light_detection_topic)
  return traffic_light_detection_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_traffic_light_detection_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.traffic_light_detection_topic)
  if (!has_traffic_light_detection_topic()) {
    return NULL;
  }
  clear_has_traffic_light_detection_topic();
  return traffic_light_detection_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_traffic_light_detection_topic(::std::string* traffic_light_detection_topic) {
  if (traffic_light_detection_topic != NULL) {
    set_has_traffic_light_detection_topic();
  } else {
    clear_has_traffic_light_detection_topic();
  }
  traffic_light_detection_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), traffic_light_detection_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.traffic_light_detection_topic)
}

// optional string planning_learning_data_topic = 12;
inline bool TopicConfig::has_planning_learning_data_topic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TopicConfig::set_has_planning_learning_data_topic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TopicConfig::clear_has_planning_learning_data_topic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TopicConfig::clear_planning_learning_data_topic() {
  planning_learning_data_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_planning_learning_data_topic();
}
inline const ::std::string& TopicConfig::planning_learning_data_topic() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TopicConfig.planning_learning_data_topic)
  return planning_learning_data_topic_.GetNoArena();
}
inline void TopicConfig::set_planning_learning_data_topic(const ::std::string& value) {
  set_has_planning_learning_data_topic();
  planning_learning_data_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TopicConfig.planning_learning_data_topic)
}
#if LANG_CXX11
inline void TopicConfig::set_planning_learning_data_topic(::std::string&& value) {
  set_has_planning_learning_data_topic();
  planning_learning_data_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:apollo.planning.TopicConfig.planning_learning_data_topic)
}
#endif
inline void TopicConfig::set_planning_learning_data_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_planning_learning_data_topic();
  planning_learning_data_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TopicConfig.planning_learning_data_topic)
}
inline void TopicConfig::set_planning_learning_data_topic(const char* value, size_t size) {
  set_has_planning_learning_data_topic();
  planning_learning_data_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TopicConfig.planning_learning_data_topic)
}
inline ::std::string* TopicConfig::mutable_planning_learning_data_topic() {
  set_has_planning_learning_data_topic();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TopicConfig.planning_learning_data_topic)
  return planning_learning_data_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicConfig::release_planning_learning_data_topic() {
  // @@protoc_insertion_point(field_release:apollo.planning.TopicConfig.planning_learning_data_topic)
  if (!has_planning_learning_data_topic()) {
    return NULL;
  }
  clear_has_planning_learning_data_topic();
  return planning_learning_data_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicConfig::set_allocated_planning_learning_data_topic(::std::string* planning_learning_data_topic) {
  if (planning_learning_data_topic != NULL) {
    set_has_planning_learning_data_topic();
  } else {
    clear_has_planning_learning_data_topic();
  }
  planning_learning_data_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), planning_learning_data_topic);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TopicConfig.planning_learning_data_topic)
}

// -------------------------------------------------------------------

// PlanningConfig

// optional .apollo.planning.TopicConfig topic_config = 1;
inline bool PlanningConfig::has_topic_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningConfig::set_has_topic_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningConfig::clear_has_topic_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningConfig::clear_topic_config() {
  if (topic_config_ != NULL) topic_config_->Clear();
  clear_has_topic_config();
}
inline const ::apollo::planning::TopicConfig& PlanningConfig::_internal_topic_config() const {
  return *topic_config_;
}
inline const ::apollo::planning::TopicConfig& PlanningConfig::topic_config() const {
  const ::apollo::planning::TopicConfig* p = topic_config_;
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.topic_config)
  return p != NULL ? *p : *reinterpret_cast<const ::apollo::planning::TopicConfig*>(
      &::apollo::planning::_TopicConfig_default_instance_);
}
inline ::apollo::planning::TopicConfig* PlanningConfig::release_topic_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.topic_config)
  clear_has_topic_config();
  ::apollo::planning::TopicConfig* temp = topic_config_;
  topic_config_ = NULL;
  return temp;
}
inline ::apollo::planning::TopicConfig* PlanningConfig::mutable_topic_config() {
  set_has_topic_config();
  if (topic_config_ == NULL) {
    auto* p = CreateMaybeMessage<::apollo::planning::TopicConfig>(GetArenaNoVirtual());
    topic_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.topic_config)
  return topic_config_;
}
inline void PlanningConfig::set_allocated_topic_config(::apollo::planning::TopicConfig* topic_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete topic_config_;
  }
  if (topic_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      topic_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, topic_config, submessage_arena);
    }
    set_has_topic_config();
  } else {
    clear_has_topic_config();
  }
  topic_config_ = topic_config;
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningConfig.topic_config)
}

// optional .apollo.planning.PlanningConfig.PlanningLearningMode learning_mode = 2;
inline bool PlanningConfig::has_learning_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningConfig::set_has_learning_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningConfig::clear_has_learning_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningConfig::clear_learning_mode() {
  learning_mode_ = 0;
  clear_has_learning_mode();
}
inline ::apollo::planning::PlanningConfig_PlanningLearningMode PlanningConfig::learning_mode() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.learning_mode)
  return static_cast< ::apollo::planning::PlanningConfig_PlanningLearningMode >(learning_mode_);
}
inline void PlanningConfig::set_learning_mode(::apollo::planning::PlanningConfig_PlanningLearningMode value) {
  assert(::apollo::planning::PlanningConfig_PlanningLearningMode_IsValid(value));
  set_has_learning_mode();
  learning_mode_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PlanningConfig.learning_mode)
}

// optional .apollo.planning.RtkPlanningConfig rtk_planning_config = 3;
inline bool PlanningConfig::has_rtk_planning_config() const {
  return planning_config_case() == kRtkPlanningConfig;
}
inline void PlanningConfig::set_has_rtk_planning_config() {
  _oneof_case_[0] = kRtkPlanningConfig;
}
inline void PlanningConfig::clear_rtk_planning_config() {
  if (has_rtk_planning_config()) {
    delete planning_config_.rtk_planning_config_;
    clear_has_planning_config();
  }
}
inline const ::apollo::planning::RtkPlanningConfig& PlanningConfig::_internal_rtk_planning_config() const {
  return *planning_config_.rtk_planning_config_;
}
inline ::apollo::planning::RtkPlanningConfig* PlanningConfig::release_rtk_planning_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.rtk_planning_config)
  if (has_rtk_planning_config()) {
    clear_has_planning_config();
      ::apollo::planning::RtkPlanningConfig* temp = planning_config_.rtk_planning_config_;
    planning_config_.rtk_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::RtkPlanningConfig& PlanningConfig::rtk_planning_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.rtk_planning_config)
  return has_rtk_planning_config()
      ? *planning_config_.rtk_planning_config_
      : *reinterpret_cast< ::apollo::planning::RtkPlanningConfig*>(&::apollo::planning::_RtkPlanningConfig_default_instance_);
}
inline ::apollo::planning::RtkPlanningConfig* PlanningConfig::mutable_rtk_planning_config() {
  if (!has_rtk_planning_config()) {
    clear_planning_config();
    set_has_rtk_planning_config();
    planning_config_.rtk_planning_config_ = CreateMaybeMessage< ::apollo::planning::RtkPlanningConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.rtk_planning_config)
  return planning_config_.rtk_planning_config_;
}

// optional .apollo.planning.StandardPlanningConfig standard_planning_config = 4;
inline bool PlanningConfig::has_standard_planning_config() const {
  return planning_config_case() == kStandardPlanningConfig;
}
inline void PlanningConfig::set_has_standard_planning_config() {
  _oneof_case_[0] = kStandardPlanningConfig;
}
inline void PlanningConfig::clear_standard_planning_config() {
  if (has_standard_planning_config()) {
    delete planning_config_.standard_planning_config_;
    clear_has_planning_config();
  }
}
inline const ::apollo::planning::StandardPlanningConfig& PlanningConfig::_internal_standard_planning_config() const {
  return *planning_config_.standard_planning_config_;
}
inline ::apollo::planning::StandardPlanningConfig* PlanningConfig::release_standard_planning_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.standard_planning_config)
  if (has_standard_planning_config()) {
    clear_has_planning_config();
      ::apollo::planning::StandardPlanningConfig* temp = planning_config_.standard_planning_config_;
    planning_config_.standard_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::StandardPlanningConfig& PlanningConfig::standard_planning_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.standard_planning_config)
  return has_standard_planning_config()
      ? *planning_config_.standard_planning_config_
      : *reinterpret_cast< ::apollo::planning::StandardPlanningConfig*>(&::apollo::planning::_StandardPlanningConfig_default_instance_);
}
inline ::apollo::planning::StandardPlanningConfig* PlanningConfig::mutable_standard_planning_config() {
  if (!has_standard_planning_config()) {
    clear_planning_config();
    set_has_standard_planning_config();
    planning_config_.standard_planning_config_ = CreateMaybeMessage< ::apollo::planning::StandardPlanningConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.standard_planning_config)
  return planning_config_.standard_planning_config_;
}

// optional .apollo.planning.NavigationPlanningConfig navigation_planning_config = 5;
inline bool PlanningConfig::has_navigation_planning_config() const {
  return planning_config_case() == kNavigationPlanningConfig;
}
inline void PlanningConfig::set_has_navigation_planning_config() {
  _oneof_case_[0] = kNavigationPlanningConfig;
}
inline void PlanningConfig::clear_navigation_planning_config() {
  if (has_navigation_planning_config()) {
    delete planning_config_.navigation_planning_config_;
    clear_has_planning_config();
  }
}
inline const ::apollo::planning::NavigationPlanningConfig& PlanningConfig::_internal_navigation_planning_config() const {
  return *planning_config_.navigation_planning_config_;
}
inline ::apollo::planning::NavigationPlanningConfig* PlanningConfig::release_navigation_planning_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningConfig.navigation_planning_config)
  if (has_navigation_planning_config()) {
    clear_has_planning_config();
      ::apollo::planning::NavigationPlanningConfig* temp = planning_config_.navigation_planning_config_;
    planning_config_.navigation_planning_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::apollo::planning::NavigationPlanningConfig& PlanningConfig::navigation_planning_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.navigation_planning_config)
  return has_navigation_planning_config()
      ? *planning_config_.navigation_planning_config_
      : *reinterpret_cast< ::apollo::planning::NavigationPlanningConfig*>(&::apollo::planning::_NavigationPlanningConfig_default_instance_);
}
inline ::apollo::planning::NavigationPlanningConfig* PlanningConfig::mutable_navigation_planning_config() {
  if (!has_navigation_planning_config()) {
    clear_planning_config();
    set_has_navigation_planning_config();
    planning_config_.navigation_planning_config_ = CreateMaybeMessage< ::apollo::planning::NavigationPlanningConfig >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.navigation_planning_config)
  return planning_config_.navigation_planning_config_;
}

// repeated .apollo.planning.TaskConfig default_task_config = 6;
inline int PlanningConfig::default_task_config_size() const {
  return default_task_config_.size();
}
inline void PlanningConfig::clear_default_task_config() {
  default_task_config_.Clear();
}
inline ::apollo::planning::TaskConfig* PlanningConfig::mutable_default_task_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningConfig.default_task_config)
  return default_task_config_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >*
PlanningConfig::mutable_default_task_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.PlanningConfig.default_task_config)
  return &default_task_config_;
}
inline const ::apollo::planning::TaskConfig& PlanningConfig::default_task_config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningConfig.default_task_config)
  return default_task_config_.Get(index);
}
inline ::apollo::planning::TaskConfig* PlanningConfig::add_default_task_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.PlanningConfig.default_task_config)
  return default_task_config_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TaskConfig >&
PlanningConfig::default_task_config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.PlanningConfig.default_task_config)
  return default_task_config_;
}

inline bool PlanningConfig::has_planning_config() const {
  return planning_config_case() != PLANNING_CONFIG_NOT_SET;
}
inline void PlanningConfig::clear_has_planning_config() {
  _oneof_case_[0] = PLANNING_CONFIG_NOT_SET;
}
inline PlanningConfig::PlanningConfigCase PlanningConfig::planning_config_case() const {
  return PlanningConfig::PlanningConfigCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::planning::TaskConfig_TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::TaskConfig_TaskType>() {
  return ::apollo::planning::TaskConfig_TaskType_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::ScenarioConfig_ScenarioType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ScenarioConfig_ScenarioType>() {
  return ::apollo::planning::ScenarioConfig_ScenarioType_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::ScenarioConfig_StageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ScenarioConfig_StageType>() {
  return ::apollo::planning::ScenarioConfig_StageType_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PlanningConfig_PlanningLearningMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PlanningConfig_PlanningLearningMode>() {
  return ::apollo::planning::PlanningConfig_PlanningLearningMode_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PlannerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PlannerType>() {
  return ::apollo::planning::PlannerType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2fplanning_5fconfig_2eproto
